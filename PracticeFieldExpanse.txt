settings
{
    main
    {
        Description: "Practice Field: Expanse is a tool for practicing against dummy bots with AI for all Heroes. (한국어 옵션 포함!)\n♥  This is a Pre-Release Beta Version!\n♥  Import Code: 5DPKQ\n♥  Created by Snow#15707\n♥  If you modify this mode and share your modification, please prepend \"Modified by: [your battletag]\"to this description."
    }
    lobby
    {
        Allow Players Who Are In Queue: Yes
        Max Spectators: 4
        Max Team 2 Players: 0
        Return To Lobby: Never
    }
    modes
    {
        Skirmish
        {
            enabled maps
            {
                Workshop Expanse
            }
        }
        General
        {
            Game Mode Start: Immediately
            Hero Limit: Off
            Respawn Time Scalar: 0%
            Spawn Health Packs: Disabled
        }
    }
    heroes
    {
        Team 1
        {
            Mercy
            {
                Weapons Enabled: Caduceus Blaster Only
            }
        }
        General
        {
            Ultimate Generation: 200%
            Wrecking Ball
            {
                Jump Vertical Speed: 300%
            }
        }
    }
}
variables
{
    global:
        0:    c_BotNamesConst
        1:    c_BubbleRadius
        2:    c_BuildDate
        3:    c_Color_DarkPink
        4:    c_Color_DarkTeal
        5:    c_Color_EffectColors
        6:    c_Color_LightGrey
        7:    c_Color_LightPink
        8:    c_Color_LightTeal
        9:    c_DeveloperName
        10:    c_DiscordLink
        11:    c_GithubURL
        12:    c_HeroClasses
        13:    c_LargeZoneHeroes
        14:    c_LongDistance
        15:    c_LongRangeHeroes
        16:    c_MaxDifficulty
        17:    c_MediumDistance
        18:    c_MediumRangeHeroes
        19:    c_MoveDir_All
        20:    c_MoveDir_Backward
        21:    c_MoveDir_Forward
        22:    c_MoveDir_Strafe
        23:    c_ProjectileHeroes
        24:    c_PseudoInfinity
        25:    c_ScopeHeroes
        26:    c_ShortDistance
        27:    c_ShortRangeHeroes
        28:    c_TwitchURL
        29:    c_Version
        30:    c_VeryShortDistance
        31:    c_VeryShortRangeHeroes
        32:    c_WorkshopCode
        33:    c_ZoneRadiusDefault
        34:    g_BotHealing
        35:    g_BotNames
        36:    g_DebugHero
        37:    g_DebugHUD
        38:    g_DebugMode
        39:    g_Difficulty
        40:    g_HeroClass
        41:    g_Initialized
        42:    g_KillGoal
        43:    g_Language
        44:    g_OneSecCooldown
        45:    g_PlayerHealing
        46:    g_PlayerNames
        48:    g_Tick
        49:    g_UseBotNames
        50:    hud_InfoVisibleToEN
        51:    hud_InfoVisibleToKR
        52:    hud_MainVisibleToEN
        53:    hud_MainVisibleToKR
    player:
        0:   ai_AbilityButton
        1:   ai_AbilityOpt
        2:   ai_AIEnabled
        3:   ai_AimBase
        4:   ai_AimBaseDefault
        5:   ai_AimDistanceMod
        6:   ai_AimModX
        7:   ai_AimModY
        8:   ai_AimStopTime
        9:   ai_AimTurnRate
        10:  ai_AimType
        11:  ai_AimTypeDefault
        12:  ai_BMVoiceLine
        13:  ai_CanAim
        14:  ai_CanAttack
        15:  ai_CanUseAbilities
        16:  ai_ChanceMod
        17:  ai_DoomfistPunchDamage
        18:  ai_DoomfistPunchTime
        19:  ai_FacingAngleMod
        20:  ai_FacingAnglePow
        21:  ai_FacingCapMax
        22:  ai_FacingCapMin
        23:  ai_FacingPadMax
        24:  ai_FacingPadMin
        25:  ai_FacingRelPosMod
        26:  ai_HeroInitialized
        27:  ai_IsInAbilitySub
        28:  ai_LookAtVector
        29:  ai_McCreeDeadeyeCharge
        30:  ai_McCreeDeadeyeRate
        31:  ai_OptimalDistance
        32:  ai_OptimalDistanceDefault
        33:  ai_ProjectileSpeed
        34:  ai_ProjectileSpeeds
        35:  ai_ReactionTime
        36:  ai_StrafeDistanceMod
        37:  ai_UltimateDisabled
        38:  ai_ViewAngleMod
        39:  ai_WeaponChargeTime
        40:  all_ChangingHero
        41:  all_HealingEnabled
        42:  all_Index
        43:  all_InspireHealID
        44:  all_InspireHealTime
        45:  all_Kills
        46:  all_SubArg
        47:  bot_BotResetComplete
        48:  bot_FlickerEnabled
        49:  bot_MoveCrouchChanceMod
        50:  bot_MoveCrouchEnabled
        51:  bot_MoveCrouchTimeMod
        52:  bot_MoveJumpChanceMod
        53:  bot_MoveJumpEnabled
        54:  bot_MoveJumpTimeMod
        55:  bot_MoveWASDEnabled
        56:  bot_MoveWASDTimeMod
        57:  bot_Name
        58:  bot_ThrottleDir
        59:  hud_Debug
        60:  hud_DebugEnabled
        61:  hud_i
        62:  hud_Info
        63:  hud_InfoEnabled
        64:  hud_Main
        65:  hud_SkyMenu
        66:  hud_SkyMenuArrowsVisibleTo
        67:  hud_SkyMenuIsOpen
        68:  hud_SkyMenuSelection
        69:  hud_SkyMenuSound
        70:  hud_SkyMenuVectors
        71:  hud_SkyMenuVisibleTo
        72:  p_BotHeroClass
        73:  p_BotHeroNumber
        74:  p_BotHeroNumberNext
        75:  p_BotTPDistance
        76:  p_CameraEyePos
        77:  p_CameraLookAtPos
        78:  p_DamageModDealtID
        79:  p_DamageModReceivedID
        80:  p_Difficulty
        81:  p_DifficultyNames
        82:  p_Effects
        83:  p_EffectsColor
        84:  p_ElevatorEnabled
        85:  p_ElevatorHeight
        86:  p_ElevatorPosition
        87:  p_EnemyDistanceMax
        88:  p_EnemyDistanceMod
        89:  p_HelpTargetIndicator
        90:  p_HeroClassNames
        91:  p_HeroList
        92:  p_HeroListName
        93:  p_HeroNumberMod
        94:  p_HomeVector
        95:  p_KillGoal
        96:  p_Language
        97:  p_MinusKillOnDeath
        98:  p_MirrorModeEnabled
        99:  p_OneSecCooldown
        100: p_PlayerHero
        101: p_PlayerInitialized
        102: p_QuickModeEnabled
        103: p_Unkillable
        104: p_ZoneRadius
}
subroutines
{
    0: aiSub_Abilities_Ana
    1: aiSub_Abilities_Ashe
    2: aiSub_Abilities_Baptiste
    3: aiSub_Abilities_Bastion
    4: aiSub_Abilities_Brigitte
    5: aiSub_Abilities_Doomfist
    6: aiSub_Abilities_DVa
    7: aiSub_Abilities_Echo
    8: aiSub_Abilities_Genji
    9: aiSub_Abilities_Hanzo
    10: aiSub_Abilities_Junkrat
    11: aiSub_Abilities_Lucio
    12: aiSub_Abilities_McCree
    13: aiSub_Abilities_Mei
    14: aiSub_Abilities_Mercy
    15: aiSub_Abilities_Moira
    16: aiSub_Abilities_Orisa
    17: aiSub_Abilities_Pharah
    18: aiSub_Abilities_Reaper
    19: aiSub_Abilities_Reinhardt
    20: aiSub_Abilities_Roadhog
    21: aiSub_Abilities_Sigma
    22: aiSub_Abilities_Soldier76
    23: aiSub_Abilities_Sombra
    24: aiSub_Abilities_Symmetra
    25: aiSub_Abilities_Torbjorn
    26: aiSub_Abilities_Tracer
    27: aiSub_Abilities_Widowmaker
    28: aiSub_Abilities_Winston
    29: aiSub_Abilities_WreckingBall
    30: aiSub_Abilities_Zarya
    31: aiSub_Abilities_Zenyatta
    32: aiSub_AimCalculation
    33: aiSub_AimModSet
    34: aiSub_ButtonsReset
    35: aiSub_EnableAI
    36: aiSub_FacingLookAt
    37: aiSub_FacingReset
    38: aiSub_FacingStart
    39: aiSub_FlickIn
    40: aiSub_FlickOut
    41: aiSub_ReactionDelay
    42: allSub_ButtonsAllow
    43: allSub_ButtonsDisallow
    44: allSub_WaitForFrame
    45: botSub_MoveCrouch
    46: botSub_MoveJump
    47: botSub_MoveWASD
    48: botSub_ResetBot
    49: botSub_SetHero
    50: botSub_TeleportBot
    51: botSub_ThrottleStop
    52: hudSub_DebugToggle
    53: hudSub_InfoToggle
    54: hudSub_MainToggle
    55: hudSub_SkyMenuArrowSet
    56: hudSub_SkyMenuPlaySound
    57: hudSub_SkyMenuToggle
    58: pSub_Elevator
    59: pSub_QuickMode
    60: pSub_SetDifficulty
    61: pSub_SetDistances
    62: pSub_SetHeroClass
    63: pSub_SetNames
    64: pSub_SetLanguage
}
rule("Global Settings")
{
    event
    {
        Ongoing - Global;
    }
    actions
    {
        Global.g_Language = Workshop Setting Combo(Custom String("Default Settings / 기본 설정"), Custom String("Language / 언어"), 0, Array(
            Custom String("English"), Custom String("한국어")), 0);
        Global.g_Difficulty = Workshop Setting Combo(Custom String("Default Settings / 기본 설정"), Custom String("Difficulty / 난이도"), 6,
            Array(Custom String("No AI Easy"), Custom String("No AI Medium"), Custom String("No AI Hard"), Custom String("AI Bronze"),
            Custom String("AI Silver"), Custom String("AI Gold"), Custom String("AI Platinum"), Custom String("AI Diamond"), Custom String(
            "AI Master"), Custom String("AI Grand Master"), Custom String("AI Top 500")), 1);
        Global.g_KillGoal = Workshop Setting Integer(Custom String("Default Settings / 기본 설정"), Custom String("Kill Goal / 필요한 킬 수"), 4, 4,
            64, 2);
        If(Global.g_KillGoal % 4 != 0 && Global.g_KillGoal > 4);
            Global.g_KillGoal = Global.g_KillGoal - Global.g_KillGoal % 4;
        End;
        Global.g_HeroClass = Workshop Setting Combo(Custom String("Default Settings / 기본 설정"), Custom String("Hero Class / 영웅 유형"), 0,
            Array(Custom String("All"), Custom String("Tank"), Custom String("Damage"), Custom String("Support")), 3);
        Global.g_PlayerHealing = Workshop Setting Toggle(Custom String("Default Settings / 기본 설정"), Custom String(
            "Player Healing / 플레이어 치유"), True, 4);
        Global.g_BotHealing = Workshop Setting Toggle(Custom String("Default Settings / 기본 설정"), Custom String("Bot Healing / 인공지는 치유"),
            False, 5);
        Global.g_UseBotNames = Workshop Setting Toggle(Custom String("Default Settings / 기본 설정"), Custom String("Random Names For Bots"),
            True, 5.5);
        Global.g_DebugMode = Workshop Setting Toggle(Custom String("Debug Settings / 디버그 설정"), Custom String("Debug Mode / 디버그 모드"), False,
            6);
        Global.g_DebugHUD = Workshop Setting Toggle(Custom String("Debug Settings / 디버그 설정"), Custom String("Debug HUD / 디버그 HUD"), False,
            7);
        Global.g_OneSecCooldown = Workshop Setting Toggle(Custom String("Debug Settings / 디버그 설정"), Custom String(
            "Global 1 Second Cooldown Mode / 글로벌 쿨 다운 새로 고침"), False, 8);
        Global.g_DebugHero = Empty Array;
        Global.g_DebugHero[0] = Workshop Setting Toggle(Custom String("Debug Settings / 디버그 설정"), Custom String(
            "Debug Hero Enabled / 디버그 영웅 활성화"), False, 9);
        If(Global.g_DebugHero[0] == True);
            Global.g_DebugHero[1] = Workshop Setting Hero(Custom String("Debug Settings / 디버그 설정"), Custom String("Debug Hero / 디버그 영웅"),
                Genji, 10);
        End;
        If(Global.g_DebugMode == True);
            Enable Inspector Recording;
        Else;
            Disable Inspector Recording;
        End;
        Disable Built-In Game Mode Completion;
    }
}
rule("Global Main Tick Loop")
{
    event
    {
        Ongoing - Global;
    }
    conditions
    {
        Is Game In Progress == True;
    }
    actions
    {
        For Global Variable(g_Tick, 0, 60, 1);
            "Dynamically lower the tick rate under high load"
            If(Server Load >= 240);
                Wait(2 / 60, Ignore Condition);
            Else If(Server Load >= 225);
                Wait(1 / 60, Ignore Condition);
            Else;
                Wait(0.500 / 60, Ignore Condition);
            End;
        End;
        Loop If Condition Is True;
    }
}
rule("Global Defines")
{
    event
    {
        Ongoing - Global;
    }
    actions
    {
        Global.c_Version = Custom String("0.14.0-test.2");
        Global.c_BuildDate = Custom String("20210513");
        Global.c_WorkshopCode = Custom String("5DPKQ");
        Global.c_DeveloperName = Custom String("Snow#15707");
        Global.c_TwitchURL = Custom String("twitch.tv/SnowwwLuna");
        Global.c_GithubURL = Custom String("github.com/SnowLune/PracticeFieldExpanse/tree/dev");
        Global.c_DiscordLink = Custom String("TBA");
        Global.c_LongDistance = 65;
        Global.c_MediumDistance = 50;
        Global.c_ShortDistance = 35;
        Global.c_VeryShortDistance = 20;
        Global.c_ZoneRadiusDefault = 20;
        Global.c_BubbleRadius = 80;
        Global.c_MaxDifficulty = 10;
        Global.c_PseudoInfinity = 999999;
        Global.c_HeroClasses = Array();
        Global.c_HeroClasses[0] = All Heroes;
        Global.c_HeroClasses[1] = All Tank Heroes;
        Global.c_HeroClasses[2] = All Damage Heroes;
        Global.c_HeroClasses[3] = All Support Heroes;
        Global.c_LongRangeHeroes = Array();
        Global.c_LongRangeHeroes[0] = Hero(Widowmaker);
        Global.c_MediumRangeHeroes = Array();
        Global.c_MediumRangeHeroes[0] = Hero(Ana);
        Global.c_MediumRangeHeroes[1] = Hero(Ashe);
        Global.c_MediumRangeHeroes[2] = Hero(Baptiste);
        Global.c_MediumRangeHeroes[3] = Hero(Hanzo);
        Global.c_ShortRangeHeroes = Array();
        Global.c_ShortRangeHeroes[0] = Hero(Bastion);
        Global.c_ShortRangeHeroes[1] = Hero(Lúcio);
        Global.c_ShortRangeHeroes[2] = Hero(McCree);
        Global.c_ShortRangeHeroes[3] = Hero(Mei);
        Global.c_ShortRangeHeroes[4] = Hero(Orisa);
        Global.c_ShortRangeHeroes[5] = Hero(Soldier: 76);
        Global.c_ShortRangeHeroes[6] = Hero(Torbjörn);
        Global.c_ShortRangeHeroes[7] = Hero(Zenyatta);
        Global.c_VeryShortRangeHeroes = Array();
        Global.c_VeryShortRangeHeroes[0] = Hero(Brigitte);
        Global.c_VeryShortRangeHeroes[1] = Hero(D.Va);
        Global.c_VeryShortRangeHeroes[2] = Hero(Moira);
        Global.c_VeryShortRangeHeroes[3] = Hero(Reaper);
        Global.c_VeryShortRangeHeroes[4] = Hero(Reinhardt);
        Global.c_VeryShortRangeHeroes[5] = Hero(Roadhog);
        Global.c_VeryShortRangeHeroes[6] = Hero(Sigma);
        Global.c_VeryShortRangeHeroes[7] = Hero(Symmetra);
        Global.c_VeryShortRangeHeroes[8] = Hero(Winston);
        Global.c_VeryShortRangeHeroes[9] = Hero(Zarya);
        Global.c_ProjectileHeroes = Array();
        Global.c_ProjectileHeroes[0] = Hero(Ana);
        Global.c_ProjectileHeroes[1] = Hero(Ashe);
        Global.c_ProjectileHeroes[2] = Hero(Baptiste);
        Global.c_ProjectileHeroes[3] = Hero(Bastion);
        Global.c_ProjectileHeroes[4] = Hero(D.Va);
        Global.c_ProjectileHeroes[5] = Hero(Echo);
        Global.c_ProjectileHeroes[6] = Hero(Genji);
        Global.c_ProjectileHeroes[7] = Hero(Hanzo);
        Global.c_ProjectileHeroes[8] = Hero(Junkrat);
        Global.c_ProjectileHeroes[9] = Hero(Lúcio);
        Global.c_ProjectileHeroes[10] = Hero(McCree);
        Global.c_ProjectileHeroes[11] = Hero(Mercy);
        Global.c_ProjectileHeroes[12] = Hero(Orisa);
        Global.c_ProjectileHeroes[13] = Hero(Pharah);
        Global.c_ProjectileHeroes[14] = Hero(Reaper);
        Global.c_ProjectileHeroes[15] = Hero(Roadhog);
        Global.c_ProjectileHeroes[16] = Hero(Sigma);
        Global.c_ProjectileHeroes[17] = Hero(Soldier: 76);
        Global.c_ProjectileHeroes[18] = Hero(Sombra);
        Global.c_ProjectileHeroes[19] = Hero(Torbjörn);
        Global.c_ProjectileHeroes[20] = Hero(Tracer);
        Global.c_ProjectileHeroes[21] = Hero(Widowmaker);
        Global.c_ProjectileHeroes[22] = Hero(Wrecking Ball);
        Global.c_ProjectileHeroes[23] = Hero(Zenyatta);
        Global.c_LargeZoneHeroes = Array();
        Global.c_LargeZoneHeroes[0] = Hero(Doomfist);
        Global.c_LargeZoneHeroes[1] = Hero(Echo);
        Global.c_LargeZoneHeroes[2] = Hero(Genji);
        Global.c_LargeZoneHeroes[3] = Hero(Junkrat);
        Global.c_LargeZoneHeroes[4] = Hero(Mercy);
        Global.c_LargeZoneHeroes[5] = Hero(Pharah);
        Global.c_LargeZoneHeroes[6] = Hero(Sombra);
        Global.c_LargeZoneHeroes[7] = Hero(Tracer);
        Global.c_LargeZoneHeroes[8] = Hero(Wrecking Ball);
        Global.c_ScopeHeroes = Array();
        Global.c_ScopeHeroes[0] = Hero(Ana);
        Global.c_ScopeHeroes[1] = Hero(Ashe);
        Global.c_ScopeHeroes[2] = Hero(Widowmaker);
        Global.c_MoveDir_All = Array();
        Global.c_MoveDir_All[0] = Forward;
        Global.c_MoveDir_All[1] = Backward;
        Global.c_MoveDir_All[2] = Left;
        Global.c_MoveDir_All[3] = Right;
        Global.c_MoveDir_All[4] = Vector(1, 0, 1);        
        Global.c_MoveDir_All[5] = Vector(-1, 0, 1);        
        Global.c_MoveDir_All[6] = Vector(1, 0, -1);        
        Global.c_MoveDir_All[7] = Vector(-1, 0, -1);    
        Global.c_MoveDir_Forward = Array();
        Global.c_MoveDir_Forward[0] = Forward;
        Global.c_MoveDir_Forward[1] = Left;
        Global.c_MoveDir_Forward[2] = Right;
        Global.c_MoveDir_Forward[3] = Vector(1, 0, 1);
        Global.c_MoveDir_Forward[4] = Vector(-1, 0, 1);
        Global.c_MoveDir_Backward = Array();
        Global.c_MoveDir_Backward[0] = Backward;
        Global.c_MoveDir_Backward[1] = Left;
        Global.c_MoveDir_Backward[2] = Right;
        Global.c_MoveDir_Backward[3] = Vector(1, 0, -1);
        Global.c_MoveDir_Backward[4] = Vector(-1, 0, -1);
        Global.c_MoveDir_Strafe = Array();
        Global.c_MoveDir_Strafe[0] = Left;
        Global.c_MoveDir_Strafe[1] = Right;
        Global.c_Color_LightPink = Custom Color(255, 195, 216, 255);
        Global.c_Color_DarkPink = Custom Color(255, 135, 176, 255);
        Global.c_Color_LightTeal = Custom Color(190, 235, 233, 255);
        Global.c_Color_DarkTeal = Custom Color(138, 198, 209, 255);
        Global.c_Color_LightGrey = Custom Color(230, 230, 230, 255);
        Global.c_Color_EffectColors = Array();
        Global.c_Color_EffectColors[0] = Color(White);
        Global.c_Color_EffectColors[1] = Color(Gray);
        Global.c_Color_EffectColors[2] = Color(Black);
        Global.c_Color_EffectColors[3] = Color(Red);
        Global.c_Color_EffectColors[4] = Color(Green);
        Global.c_Color_EffectColors[5] = Color(Blue);
        Global.c_Color_EffectColors[6] = Color(Rose);
        Global.c_Color_EffectColors[7] = Color(Lime Green);
        Global.c_Color_EffectColors[8] = Color(Sky Blue);
        Global.c_Color_EffectColors[9] = Color(Violet);
        Global.g_BotNames = Array();
        Global.c_BotNamesConst = Array();
        Global.c_BotNamesConst[0]  = Custom String("Amanda");
        Global.c_BotNamesConst[1]  = Custom String("Amber");
        Global.c_BotNamesConst[2]  = Custom String("Aphrodite");
        Global.c_BotNamesConst[3]  = Custom String("CatShark");
        Global.c_BotNamesConst[4]  = Custom String("BeepBoop");
        Global.c_BotNamesConst[5]  = Custom String("BitsAndBytes");
        Global.c_BotNamesConst[6]  = Custom String("Blue");
        Global.c_BotNamesConst[7]  = Custom String("Bread");
        Global.c_BotNamesConst[8]  = Custom String("BronzeSmurf");
        Global.c_BotNamesConst[9]  = Custom String("Comfort");
        Global.c_BotNamesConst[10] = Custom String("CoolGamer");
        Global.c_BotNamesConst[11] = Custom String("Dirt");
        Global.c_BotNamesConst[12] = Custom String("DontLeaveMe");
        Global.c_BotNamesConst[13] = Custom String("DoomfistOTP");
        Global.c_BotNamesConst[14] = Custom String("DoomSlayer");
        Global.c_BotNamesConst[15] = Custom String("DPSDiff");
        Global.c_BotNamesConst[16] = Custom String("DPSLucio");
        Global.c_BotNamesConst[17] = Custom String("DPSMercy");
        Global.c_BotNamesConst[18] = Custom String("Ecofriendly");
        Global.c_BotNamesConst[19] = Custom String("Error");
        Global.c_BotNamesConst[20] = Custom String("Fallout");
        Global.c_BotNamesConst[21] = Custom String("Fear");
        Global.c_BotNamesConst[22] = Custom String("Friend");
        Global.c_BotNamesConst[23] = Custom String("GenjiMain");
        Global.c_BotNamesConst[24] = Custom String("GGILY");
        Global.c_BotNamesConst[25] = Custom String("GiveMeHanzo");
        Global.c_BotNamesConst[26] = Custom String("GlaDOS");
        Global.c_BotNamesConst[27] = Custom String("Granola");
        Global.c_BotNamesConst[28] = Custom String("Greg");
        Global.c_BotNamesConst[29] = Custom String("HammerOnly");
        Global.c_BotNamesConst[30] = Custom String("HealPls");
        Global.c_BotNamesConst[31] = Custom String("Healz");
        Global.c_BotNamesConst[32] = Custom String("Holden");
        Global.c_BotNamesConst[33] = Custom String("HotTopic");
        Global.c_BotNamesConst[34] = Custom String("IBMPC");
        Global.c_BotNamesConst[35] = Custom String("IDontMiss");
        Global.c_BotNamesConst[36] = Custom String("IMainSupport");
        Global.c_BotNamesConst[37] = Custom String("ImSorry");
        Global.c_BotNamesConst[38] = Custom String("Instalock");
        Global.c_BotNamesConst[39] = Custom String("IntMain");
        Global.c_BotNamesConst[40] = Custom String("JustLikeBart");
        Global.c_BotNamesConst[41] = Custom String("Kachow");
        Global.c_BotNamesConst[42] = Custom String("Kyle");
        Global.c_BotNamesConst[43] = Custom String("Player");
        Global.c_BotNamesConst[44] = Custom String("Mars");
        Global.c_BotNamesConst[45] = Custom String("Mercury");
        Global.c_BotNamesConst[46] = Custom String("MercyMainBTW");
        Global.c_BotNamesConst[47] = Custom String("MercyOnly");
        Global.c_BotNamesConst[48] = Custom String("Mint");
        Global.c_BotNamesConst[49] = Custom String("MoicyIsCanon");
        Global.c_BotNamesConst[50] = Custom String("Mother");
        Global.c_BotNamesConst[51] = Custom String("Neptune");
        Global.c_BotNamesConst[52] = Custom String("NotABot");
        Global.c_BotNamesConst[53] = Custom String("NotASmurf");
        Global.c_BotNamesConst[54] = Custom String("NotScripting");
        Global.c_BotNamesConst[55] = Custom String("NotSmurfing");
        Global.c_BotNamesConst[56] = Custom String("OatMilk");
        Global.c_BotNamesConst[57] = Custom String("OnesAndZeros");
        Global.c_BotNamesConst[58] = Custom String("Overclocked");
        Global.c_BotNamesConst[59] = Custom String("Paul");
        Global.c_BotNamesConst[60] = Custom String("Persephone");
        Global.c_BotNamesConst[61] = Custom String("Pizza");
        Global.c_BotNamesConst[62] = Custom String("Princess");
        Global.c_BotNamesConst[63] = Custom String("Ramen");
        Global.c_BotNamesConst[64] = Custom String("Reboot");
        Global.c_BotNamesConst[65] = Custom String("Samantha");
        Global.c_BotNamesConst[66] = Custom String("Sedna");
        Global.c_BotNamesConst[67] = Custom String("Deadbeat");
        Global.c_BotNamesConst[68] = Custom String("SupportDiff");
        Global.c_BotNamesConst[69] = Custom String("Takoyaki");
        Global.c_BotNamesConst[70] = Custom String("TankDiff");
        Global.c_BotNamesConst[71] = Custom String("Tempest");
        Global.c_BotNamesConst[72] = Custom String("TheBoyMayor");
        Global.c_BotNamesConst[73] = Custom String("Titan");
        Global.c_BotNamesConst[74] = Custom String("TokyoFool");
        Global.c_BotNamesConst[75] = Custom String("TryRustLang");
        Global.c_BotNamesConst[76] = Custom String("Venus");
        Global.c_BotNamesConst[77] = Custom String("Veronica");
        Global.c_BotNamesConst[78] = Custom String("ZaryaMain");
        Global.c_BotNamesConst[79] = Custom String("ZenMainBTW");
        Global.c_BotNamesConst[80] = Custom String("HelloWorld");
        Global.c_BotNamesConst[81] = Custom String("Alien");
        Global.c_BotNamesConst[82] = Custom String("MyMainIsT500");
        Global.g_PlayerNames = Array();
    }
}
rule("hudSub_DebugToggle")
{
    event
    {
        Subroutine;
        hudSub_DebugToggle;
    }
    actions
    {
        If(Count Of(Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenu) > 0);
            Call Subroutine(hudSub_SkyMenuToggle);
        End;
        If(Count Of(Players In Slot(Slot Of(Event Player), Team 1).hud_Info) > 0);
            Call Subroutine(hudSub_InfoToggle);
        End;
        If(Count Of(Players In Slot(Slot Of(Event Player), Team 1).hud_Main) > 0);
            Call Subroutine(hudSub_MainToggle);
        End;
        Wait(3 / 60, Ignore Condition);
        If(Count Of(Players In Slot(Slot Of(Event Player), Team 1).hud_Debug) > 0);
            For Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_i, Count Of(Players In Slot(Slot Of(Event Player), Team 1)
                .hud_Debug), -1, -1);
                Destroy HUD Text(Players In Slot(Slot Of(Event Player), Team 1).hud_Debug[Players In Slot(Slot Of(Event Player), Team 1).hud_i]);
                Players In Slot(Slot Of(Event Player), Team 1).hud_Debug = Remove From Array(Players In Slot(Slot Of(Event Player), Team 1)
                    .hud_Debug, Players In Slot(Slot Of(Event Player), Team 1).hud_Debug[Players In Slot(Slot Of(Event Player), Team 1).hud_i]);
            End;
            Players In Slot(Slot Of(Event Player), Team 1).hud_DebugEnabled = False;
            If(Count Of(Players In Slot(Slot Of(Event Player), Team 1).hud_Main) <= 0);
                Call Subroutine(hudSub_MainToggle);
            End;
        Else;
            Players In Slot(Slot Of(Event Player), Team 1).hud_Debug = Empty Array;
            Players In Slot(Slot Of(Event Player), Team 1).hud_DebugEnabled = True;
            Create HUD Text(Players In Slot(Slot Of(Event Player), Team 1), Custom String("Server Load: {0}% ({1})", Round To Integer(
                Server Load / 2.550, Down), Server Load), Custom String("Average: {0}% ({1})", Round To Integer(Server Load Average / 2.550,
                Down), Server Load Average), Custom String("Peak: {0}% ({1})", Round To Integer(Server Load Peak / 2.550, Down),
                Server Load Peak), Top, 100, Global.c_Color_LightPink, Global.c_Color_LightTeal, Global.c_Color_DarkTeal, Visible To and String,
                Default Visibility);
            Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_Debug, Append To Array, Last Text ID);
            Create HUD Text(Players In Slot(Slot Of(Event Player), Team 1), Null, Custom String("Enemy Pos: {0}", Position Of(Players In Slot(
                Slot Of(Event Player), Team 2))), Custom String("Player Pos: {0}", Position Of(Event Player)), Left, 4, Color(White),
                Global.c_Color_LightPink, Global.c_Color_LightTeal, Visible To and String, Default Visibility);
            Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_Debug, Append To Array, Last Text ID);
            Create HUD Text(Players In Slot(Slot Of(Event Player), Team 1), Null, Custom String("Enemy Dist From Home: {0}", Distance Between(
                Players In Slot(Slot Of(Event Player), Team 2), Players In Slot(Slot Of(Event Player), Team 1).p_HomeVector)), Custom String(
                "Player Dist From Home: {0}", Distance Between(Players In Slot(Slot Of(Event Player), Team 1), Players In Slot(Slot Of(
                Event Player), Team 1).p_HomeVector)), Left, 5, Color(White), Global.c_Color_LightPink, Global.c_Color_LightTeal,
                Visible To and String, Default Visibility);
            Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_Debug, Append To Array, Last Text ID);
            Create HUD Text(Players In Slot(Slot Of(Event Player), Team 1), Custom String("Enemy Distance From Player: {0}", Distance Between(
                Players In Slot(Slot Of(Event Player), Team 1), Players In Slot(Slot Of(Event Player), Team 2))), Null, Null, Left, 5.200,
                Global.c_Color_LightPink, Color(White), Color(White), Visible To and String, Default Visibility);
            Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_Debug, Append To Array, Last Text ID);
            Create HUD Text(Players In Slot(Slot Of(Event Player), Team 1), Custom String("Enemy Ult Charge: {0}", Ultimate Charge Percent(
                Players In Slot(Slot Of(Event Player), Team 2))), Null, Null, Right, 6, Global.c_Color_LightGrey, Color(White), Color(White),
                Visible To and String, Default Visibility);
            Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_Debug, Append To Array, Last Text ID);
            Create HUD Text(Players In Slot(Slot Of(Event Player), Team 1), Custom String("Player Facing Dir: {0}", Facing Direction Of(
                Event Player)), Null, Custom String("Enemy Facing Dir: {0}", Facing Direction Of(Players In Slot(Slot Of(Event Player),
                Team 2))), Left, 6.100, Global.c_Color_LightTeal, Color(White), Global.c_Color_LightPink, Visible To and String, Default Visibility);
            Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_Debug, Append To Array, Last Text ID);
        End;
    }
}
rule("hudSub_InfoToggle")
{
    event
    {
        Subroutine;
        hudSub_InfoToggle;
    }
    actions
    {
        If(Count Of(Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenu) > 0);
            Call Subroutine(hudSub_SkyMenuToggle);
        End;
        If(Count Of(Players In Slot(Slot Of(Event Player), Team 1).hud_Debug) > 0);
            Call Subroutine(hudSub_DebugToggle);
        End;
        Wait(3 / 60, Ignore Condition);
        If(Players In Slot(Slot Of(Event Player), Team 1).hud_InfoEnabled == True);
            Modify Global Variable(hud_InfoVisibleToEN, Remove From Array By Value, Event Player);
            Modify Global Variable(hud_InfoVisibleToKR, Remove From Array By Value, Event Player);
            Players In Slot(Slot Of(Event Player), Team 1).hud_InfoEnabled = False;
        Else;
            If(Players In Slot(Slot Of(Event Player), Team 1).p_Language == 1);
                Modify Global Variable(hud_InfoVisibleToEN, Remove From Array By Value, Event Player);
                Modify Global Variable(hud_InfoVisibleToKR, Append To Array, Event Player);
            Else;
                Modify Global Variable(hud_InfoVisibleToKR, Remove From Array By Value, Event Player);
                Modify Global Variable(hud_InfoVisibleToEN, Append To Array, Event Player);
            End;
            Players In Slot(Slot Of(Event Player), Team 1).hud_InfoEnabled = True;
            "Auto-close after 20 seconds open"
            Wait(20, Ignore Condition);
            If(Event Player.hud_InfoEnabled == True);
                Call Subroutine(hudSub_InfoToggle);
            End;
        End;
    }
}
rule("hudSub_MainToggle")
{
    event
    {
        Subroutine;
        hudSub_MainToggle;
    }
    actions
    {
        If(Count Of(Players In Slot(Slot Of(Event Player), Team 1).hud_Main) > 0);
            For Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_i, Count Of(Players In Slot(Slot Of(Event Player), Team 1)
                .hud_Main), -1, -1);
                Destroy HUD Text(Players In Slot(Slot Of(Event Player), Team 1).hud_Main[Players In Slot(Slot Of(Event Player), Team 1).hud_i]);
                Players In Slot(Slot Of(Event Player), Team 1).hud_Main = Remove From Array(Players In Slot(Slot Of(Event Player), Team 1)
                    .hud_Main, Players In Slot(Slot Of(Event Player), Team 1).hud_Main[Players In Slot(Slot Of(Event Player), Team 1).hud_i]);
            End;
        Else;
            Wait(3 / 60, Ignore Condition);
            Players In Slot(Slot Of(Event Player), Team 1).hud_Main = Empty Array;
            "Create Right Side HUD Text"
            Create HUD Text(Players In Slot(Slot Of(Event Player), Team 1), Players In Slot(Slot Of(Event Player), Team 1)
                .p_Language == 1 ? Custom String("{0} 킬: {1} / {2}", Hero Icon String(Players In Slot(Slot Of(Event Player), Team 1)
                .p_HeroList[Players In Slot(Slot Of(Event Player), Team 1).p_BotHeroNumber]), Players In Slot(Slot Of(Event Player), Team 1)
                .all_Kills, Players In Slot(Slot Of(Event Player), Team 1).p_KillGoal == Global.c_PseudoInfinity ? Custom String("무한")
                : Players In Slot(Slot Of(Event Player), Team 1).p_KillGoal) : Custom String("{0} Kills: {1} / {2}", Hero Icon String(
                Players In Slot(Slot Of(Event Player), Team 1).p_HeroList[Players In Slot(Slot Of(Event Player), Team 1).p_BotHeroNumber]),
                Players In Slot(Slot Of(Event Player), Team 1).all_Kills, Players In Slot(Slot Of(Event Player), Team 1)
                .p_KillGoal == Global.c_PseudoInfinity ? Custom String("Infinite") : Players In Slot(Slot Of(Event Player), Team 1).p_KillGoal),
                Null, Null, Right, -3, Color(White), Color(White), Color(White), Visible To and String, Default Visibility);
            Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_Main, Append To Array, Last Text ID);
            Create HUD Text(Players In Slot(Slot Of(Event Player), Team 1), Null, Players In Slot(Slot Of(Event Player), Team 1)
                .p_Language == 1 ? Custom String("{0} 당신을 {1} 번 죽였습니다", Hero Of(Players In Slot(Slot Of(Event Player), Team 2)),
                Players In Slot(Slot Of(Event Player), Team 2).all_Kills) : Custom String("{0} killed you {1} time(s).", Hero Of(
                Players In Slot(Slot Of(Event Player), Team 2)), Players In Slot(Slot Of(Event Player), Team 2).all_Kills), Null, Right,
                -2.900, Color(White), Global.c_Color_LightPink, Color(Red), Visible To and String, Default Visibility);
            Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_Main, Append To Array, Last Text ID);
            Create HUD Text(Players In Slot(Slot Of(Event Player), Team 1), Null, Players In Slot(Slot Of(Event Player), Team 1)
                .p_Language == 1 ? Custom String("영웅 유형: {0}", Players In Slot(Slot Of(Event Player), Team 1).p_HeroListName) : Custom String(
                "Hero Type: {0}", Players In Slot(Slot Of(Event Player), Team 1).p_HeroListName), Players In Slot(Slot Of(Event Player),
                Team 1).p_Language == 1 ? Custom String("영웅: {0} / {1}", 1 + Players In Slot(Slot Of(Event Player), Team 1).p_BotHeroNumber,
                Count Of(Players In Slot(Slot Of(Event Player), Team 1).p_HeroList)) : Custom String("Hero: {0} / {1}", 1 + Players In Slot(
                Slot Of(Event Player), Team 1).p_BotHeroNumber, Count Of(Players In Slot(Slot Of(Event Player), Team 1).p_HeroList)), Right,
                -2.200, Color(White), Color(White), Global.c_Color_LightTeal, Visible To and String, Default Visibility);
            Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_Main, Append To Array, Last Text ID);
            Create HUD Text(Players In Slot(Slot Of(Event Player), Team 1), Null, Players In Slot(Slot Of(Event Player), Team 1)
                .p_Language == 1 ? Custom String("다음 영웅: {0}", Players In Slot(Slot Of(Event Player), Team 1)
                .p_QuickModeEnabled == True ? Custom String("?") : Hero Icon String(Players In Slot(Slot Of(Event Player), Team 1)
                .p_HeroList[Players In Slot(Slot Of(Event Player), Team 1).p_BotHeroNumberNext])) : Custom String("Next Hero: {0}",
                Players In Slot(Slot Of(Event Player), Team 1).p_QuickModeEnabled == True ? Custom String("?") : Hero Icon String(
                Players In Slot(Slot Of(Event Player), Team 1).p_HeroList[Players In Slot(Slot Of(Event Player), Team 1)
                .p_BotHeroNumberNext])), Null, Right, -2, Color(White), Global.c_Color_DarkTeal, Color(Aqua), Visible To and String,
                Default Visibility);
            Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_Main, Append To Array, Last Text ID);
            Create HUD Text(Players In Slot(Slot Of(Event Player), Team 1), Null, Players In Slot(Slot Of(Event Player), Team 1)
                .p_Language == 1 ? Custom String("난이도: {0}", Players In Slot(Slot Of(Event Player), Team 1).p_DifficultyNames[Players In Slot(
                Slot Of(Event Player), Team 1).p_Difficulty]) : Custom String("Difficulty: {0}", Players In Slot(Slot Of(Event Player), Team 1)
                .p_DifficultyNames[Players In Slot(Slot Of(Event Player), Team 1).p_Difficulty]), Null, Right, -0.900, Color(White),
                Global.c_Color_LightGrey, Color(White), Visible To and String, Default Visibility);
            Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_Main, Append To Array, Last Text ID);
        End;
    }
}
rule("hudSub_SkyMenuPlaySound")
{
    event
    {
        Subroutine;
        hudSub_SkyMenuPlaySound;
    }
    actions
    {
        "On, Off, Neutral, Other"
        If(Event Player.hud_SkyMenuSound == 0);
            Play Effect(Players In Slot(Slot Of(Event Player), Team 1), Buff Impact Sound, Color(White), Players In Slot(Slot Of(Event Player),
                Team 1).hud_SkyMenuSelection - Vector(0, 15, 0), 20);
        Else If(Event Player.hud_SkyMenuSound == 1);
            Play Effect(Players In Slot(Slot Of(Event Player), Team 1), Debuff Impact Sound, Color(White), Players In Slot(Slot Of(
                Event Player), Team 1).hud_SkyMenuSelection - Vector(0, 15, 0), 20);
        Else If(Event Player.hud_SkyMenuSound == 2);
            Play Effect(Players In Slot(Slot Of(Event Player), Team 1), Explosion Sound, Color(White), Players In Slot(Slot Of(Event Player),
                Team 1).hud_SkyMenuSelection - Vector(0, 15, 0), 15);
        Else;
            Play Effect(Players In Slot(Slot Of(Event Player), Team 1), Explosion Sound, Color(White), Players In Slot(Slot Of(Event Player),
                Team 1).hud_SkyMenuSelection - Vector(0, 15, 0), 10);
        End;
    }
}
rule("hudSub_SkyMenuToggle")
{
    event
    {
        Subroutine;
        hudSub_SkyMenuToggle;
    }
    actions
    {
        If(Players In Slot(Slot Of(Event Player), Team 1).hud_InfoEnabled == True);
            Call Subroutine(hudSub_InfoToggle);
        End;
        If(Count Of(Players In Slot(Slot Of(Event Player), Team 1).hud_Debug) > 0);
            Call Subroutine(hudSub_DebugToggle);
        End;
        If(Count Of(Players In Slot(Slot Of(Event Player), Team 1).hud_Main) > 0);
            Call Subroutine(hudSub_MainToggle);
        End;
        Wait(3 / 60, Ignore Condition);
        If(Count Of(Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenu) > 0);
            For Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_i, Count Of(Players In Slot(Slot Of(Event Player), Team 1)
                .hud_SkyMenu), -1, -1);
                Destroy In-World Text(Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenu[Players In Slot(Slot Of(Event Player), Team 1)
                    .hud_i]);
                Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenu = Remove From Array(Players In Slot(Slot Of(Event Player), Team 1)
                    .hud_SkyMenu, Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenu[Players In Slot(Slot Of(Event Player), Team 1)
                    .hud_i]);
            End;
            Destroy Effect(Players In Slot(Slot Of(Event Player), Team 1).p_Effects[10]);
            Destroy Effect(Players In Slot(Slot Of(Event Player), Team 1).p_Effects[11]);
            Clear Status(Players In Slot(Slot Of(Event Player), Team 1), Phased Out);
            Stop Forcing Player Position(Players In Slot(Slot Of(Event Player), Team 1));
            Stop Facing(Players In Slot(Slot Of(Event Player), Team 1));
            Call Subroutine(allSub_ButtonsAllow);
            Wait(6 / 60, Ignore Condition);
            Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuIsOpen = False;
            Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuVisibleTo = Null;
            Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuArrowsVisibleTo[0] = Null;
            Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuArrowsVisibleTo[1] = Null;
            Stop Camera(Players In Slot(Slot Of(Event Player), Team 1));
            Enable Hero HUD(Players In Slot(Slot Of(Event Player), Team 1));
            Call Subroutine(hudSub_MainToggle);
            If(Players In Slot(Slot Of(Event Player), Team 1).p_HeroListName != Players In Slot(Slot Of(Event Player), Team 1)
                .p_HeroClassNames[Players In Slot(Slot Of(Event Player), Team 1).p_BotHeroClass]);
                Event Player.p_BotHeroNumber = 0;
                Event Player.p_HeroNumberMod = 0;
                Call Subroutine(pSub_SetHeroClass);
                Call Subroutine(botSub_SetHero);
            Else;
                Call Subroutine(botSub_TeleportBot);
            End;
        Else;
            If(Players In Slot(Slot Of(Event Player), Team 2).ai_AIEnabled == True);
                Call Subroutine(botSub_ResetBot);
            End;
            Set Status(Players In Slot(Slot Of(Event Player), Team 1), Null, Phased Out, 9999);
            If(Players In Slot(Slot Of(Event Player), Team 1).p_ElevatorEnabled == True);
                Start Forcing Player Position(Players In Slot(Slot Of(Event Player), Team 1), Players In Slot(Slot Of(Event Player), Team 1)
                    .p_HomeVector + Vector(0, Players In Slot(Slot Of(Event Player), Team 1).p_ElevatorHeight, 0), False);
            Else;
                Start Forcing Player Position(Players In Slot(Slot Of(Event Player), Team 1), Players In Slot(Slot Of(Event Player), Team 1)
                    .p_HomeVector, False);
            End;
            Start Facing(Players In Slot(Slot Of(Event Player), Team 1), Facing Direction Of(Players In Slot(Slot Of(Event Player), Team 1)),
                100, To World, Direction and Turn Rate);
            Call Subroutine(allSub_ButtonsDisallow);
            Heal(Players In Slot(Slot Of(Event Player), Team 1), Null, Max Health(Players In Slot(Slot Of(Event Player), Team 1)));
            Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuVisibleTo = Players In Slot(Slot Of(Event Player), Team 1);
            Call Subroutine(hudSub_SkyMenuArrowSet);
            Disable Hero HUD(Players In Slot(Slot Of(Event Player), Team 1));
            "Generate Menu"
            Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuVectors = Empty Array;
            For Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_i, -1, 14, 1);
                Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_SkyMenuVectors, Append To Array, Vector(0, 45,
                    1.250 * Players In Slot(Slot Of(Event Player), Team 1).hud_i));
            End;
            Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuSelection = Players In Slot(Slot Of(Event Player), Team 1)
                .hud_SkyMenuVectors[0];
            "Menu Selection Arrows"
            Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuArrowsVisibleTo = Array(Null, Null);
            Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenu = Empty Array;
            Create In-World Text(Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuArrowsVisibleTo[0], Icon String(Arrow: Left),
                Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuSelection + Vector(4.500, 0, 0), 1.250, Clip Against Surfaces,
                Visible To Position and String, Color(White), Default Visibility);
            Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_SkyMenu, Append To Array, Last Text ID);
            Create In-World Text(Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuArrowsVisibleTo[1], Icon String(Arrow: Right),
                Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuSelection + Vector(-4.500, 0, 0), 1.250, Clip Against Surfaces,
                Visible To Position and String, Color(White), Default Visibility);
            Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_SkyMenu, Append To Array, Last Text ID);
            Create Beam Effect(Players In Slot(Slot Of(Event Player), Team 1), Bad Beam, Players In Slot(Slot Of(Event Player), Team 1)
                .hud_SkyMenuSelection + Vector(-4.500, 0, -0.500), Players In Slot(Slot Of(Event Player), Team 1)
                .hud_SkyMenuSelection + Vector(4.500, 0, -0.500), Event Player.p_EffectsColor, Position Radius and Color);
            Players In Slot(Slot Of(Event Player), Team 1).p_Effects[10] = Last Created Entity;
            Create Beam Effect(Players In Slot(Slot Of(Event Player), Team 1), Bad Beam, Players In Slot(Slot Of(Event Player), Team 1)
                .hud_SkyMenuSelection + Vector(-4.500, 0, -1.500), Players In Slot(Slot Of(Event Player), Team 1)
                .hud_SkyMenuSelection + Vector(4.500, 0, -1.500), Event Player.p_EffectsColor, Position Radius and Color);
            Players In Slot(Slot Of(Event Player), Team 1).p_Effects[11] = Last Created Entity;
            "Menu Text"
            Create In-World Text(Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuVisibleTo, Players In Slot(Slot Of(Event Player),
                Team 1).p_Language == 1 ? Custom String("난이도: {0}", Players In Slot(Slot Of(Event Player), Team 1)
                .p_DifficultyNames[Players In Slot(Slot Of(Event Player), Team 1).p_Difficulty]) : Custom String("Difficulty: {0}",
                Players In Slot(Slot Of(Event Player), Team 1).p_DifficultyNames[Players In Slot(Slot Of(Event Player), Team 1).p_Difficulty]),
                Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuVectors[0], 1.500, Clip Against Surfaces, Visible To and String,
                Color(White), Default Visibility);
            Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_SkyMenu, Append To Array, Last Text ID);
            Create In-World Text(Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuVisibleTo, Players In Slot(Slot Of(Event Player),
                Team 1).p_Language == 1 ? Custom String("필요한 킬 수: {0}", Players In Slot(Slot Of(Event Player), Team 1)
                .p_KillGoal == Global.c_PseudoInfinity ? Custom String("무한") : Players In Slot(Slot Of(Event Player), Team 1).p_KillGoal)
                : Custom String("Kill Goal: {0}", Players In Slot(Slot Of(Event Player), Team 1)
                .p_KillGoal == Global.c_PseudoInfinity ? Custom String("Infinite") : Players In Slot(Slot Of(Event Player), Team 1).p_KillGoal),
                Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuVectors[1], 1.500, Clip Against Surfaces, Visible To and String,
                Color(White), Default Visibility);
            Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_SkyMenu, Append To Array, Last Text ID);
            Create In-World Text(Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuVisibleTo, Players In Slot(Slot Of(Event Player),
                Team 1).p_Language == 1 ? Custom String("영웅 유형: {0}", Players In Slot(Slot Of(Event Player), Team 1)
                .p_HeroClassNames[Players In Slot(Slot Of(Event Player), Team 1).p_BotHeroClass]) : Custom String("Hero Class: {0}",
                Players In Slot(Slot Of(Event Player), Team 1).p_HeroClassNames[Players In Slot(Slot Of(Event Player), Team 1)
                .p_BotHeroClass]), Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuVectors[2], 1.500, Clip Against Surfaces,
                Visible To and String, Color(White), Default Visibility);
            Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_SkyMenu, Append To Array, Last Text ID);
            Create In-World Text(Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuVisibleTo, Players In Slot(Slot Of(Event Player),
                Team 1).p_Language == 1 ? Custom String("빠른 모드: {0}", Players In Slot(Slot Of(Event Player), Team 1)
                .p_QuickModeEnabled == True ? Custom String("활성화") : Custom String("비활성화")) : Custom String("Quick Mode: {0}", Players In Slot(
                Slot Of(Event Player), Team 1).p_QuickModeEnabled == True ? Custom String("On") : Custom String("Off")), Players In Slot(
                Slot Of(Event Player), Team 1).hud_SkyMenuVectors[3], 1.500, Clip Against Surfaces, Visible To and String, Color(White),
                Default Visibility);
            Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_SkyMenu, Append To Array, Last Text ID);
            Create In-World Text(Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuVisibleTo, Players In Slot(Slot Of(Event Player),
                Team 1).p_Language == 1 ? Custom String("같은 영웅 모드: {0}", Players In Slot(Slot Of(Event Player), Team 1)
                .p_MirrorModeEnabled == True ? Custom String("활성화") : Custom String("비활성화")) : Custom String("Mirror Mode: {0}",
                Players In Slot(Slot Of(Event Player), Team 1).p_MirrorModeEnabled == True ? Custom String("On") : Custom String("Off")),
                Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuVectors[4], 1.500, Clip Against Surfaces, Visible To and String,
                Color(White), Default Visibility);
            Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_SkyMenu, Append To Array, Last Text ID);
            Create In-World Text(Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuVisibleTo, Players In Slot(Slot Of(Event Player),
                Team 1).p_Language == 1 ? Custom String("1 초 쿨 다운 모드: {0}", Players In Slot(Slot Of(Event Player), Team 1)
                .p_OneSecCooldown == 3 ? Custom String("플레이어 + 인공 지능") : (Players In Slot(Slot Of(Event Player), Team 1)
                .p_OneSecCooldown == 2 ? Custom String("인공지는") : (Players In Slot(Slot Of(Event Player), Team 1)
                .p_OneSecCooldown == 1 ? Custom String("플레이어") : Custom String("비활성화")))) : Custom String("1 Sec Cooldown Mode: {0}",
                Players In Slot(Slot Of(Event Player), Team 1).p_OneSecCooldown == 3 ? Custom String("Player & Bot") : (Players In Slot(
                Slot Of(Event Player), Team 1).p_OneSecCooldown == 2 ? Custom String("Bot") : (Players In Slot(Slot Of(Event Player), Team 1)
                .p_OneSecCooldown == 1 ? Custom String("Player") : Custom String("Off")))), Players In Slot(Slot Of(Event Player), Team 1)
                .hud_SkyMenuVectors[5], 1.500, Clip Against Surfaces, Visible To and String, Color(White), Default Visibility);
            Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_SkyMenu, Append To Array, Last Text ID);
            Create In-World Text(Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuVisibleTo, Players In Slot(Slot Of(Event Player),
                Team 1).p_Language == 1 ? Custom String("킬 점수 패널티: {0}", Players In Slot(Slot Of(Event Player), Team 1)
                .p_MinusKillOnDeath == True ? Custom String("활성화") : Custom String("비활성화")) : Custom String("-1 Kill On Death: {0}",
                Players In Slot(Slot Of(Event Player), Team 1).p_MinusKillOnDeath == True ? Custom String("On") : Custom String("Off")),
                Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuVectors[6], 1.500, Clip Against Surfaces, Visible To and String,
                Color(White), Default Visibility);
            Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_SkyMenu, Append To Array, Last Text ID);
            Create In-World Text(Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuVisibleTo, Players In Slot(Slot Of(Event Player),
                Team 1).p_Language == 1 ? Custom String("플레이어 치유: {0}", Players In Slot(Slot Of(Event Player), Team 1)
                .all_HealingEnabled == True ? Custom String("활성화") : Custom String("비활성화")) : Custom String("Player Healing: {0}",
                Players In Slot(Slot Of(Event Player), Team 1).all_HealingEnabled == True ? Custom String("On") : Custom String("Off")),
                Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuVectors[7], 1.500, Clip Against Surfaces, Visible To and String,
                Color(White), Default Visibility);
            Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_SkyMenu, Append To Array, Last Text ID);
            Create In-World Text(Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuVisibleTo, Players In Slot(Slot Of(Event Player),
                Team 1).p_Language == 1 ? Custom String("인공지는 치유: {0}", Players In Slot(Slot Of(Event Player), Team 2)
                .all_HealingEnabled == True ? Custom String("활성화") : Custom String("비활성화")) : Custom String("Bot Healing: {0}",
                Players In Slot(Slot Of(Event Player), Team 2).all_HealingEnabled == True ? Custom String("On") : Custom String("Off")),
                Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuVectors[8], 1.500, Clip Against Surfaces, Visible To and String,
                Color(White), Default Visibility);
            Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_SkyMenu, Append To Array, Last Text ID);
            Create In-World Text(Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuVisibleTo, Players In Slot(Slot Of(Event Player),
                Team 1).p_Language == 1 ? Custom String("플레이어는 죽일 수 없다: {0}", Players In Slot(Slot Of(Event Player), Team 1)
                .p_Unkillable == True ? Custom String("활성화") : Custom String("비활성화")) : Custom String("Player Unkillable: {0}",
                Players In Slot(Slot Of(Event Player), Team 1).p_Unkillable == True ? Custom String("On") : Custom String("Off")),
                Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuVectors[9], 1.500, Clip Against Surfaces, Visible To and String,
                Color(White), Default Visibility);
            Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_SkyMenu, Append To Array, Last Text ID);
            Create In-World Text(Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuVisibleTo, Players In Slot(Slot Of(Event Player),
                Team 1).p_Language == 1 ? Custom String("인공지는 궁극적 인 장애인: {0}", Players In Slot(Slot Of(Event Player), Team 2)
                .ai_UltimateDisabled == True ? Custom String("활성화") : Custom String("비활성화")) : Custom String("Disable Bot Ultimate: {0}",
                Players In Slot(Slot Of(Event Player), Team 2).ai_UltimateDisabled == True ? Custom String("On") : Custom String("Off")),
                Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuVectors[10], 1.500, Clip Against Surfaces, Visible To and String,
                Color(White), Default Visibility);
            Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_SkyMenu, Append To Array, Last Text ID);
            Create In-World Text(Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuVisibleTo, Players In Slot(Slot Of(Event Player),
                Team 1).p_Language == 1 ? Custom String("인공지는 깜박거리는: {0}", Players In Slot(Slot Of(Event Player), Team 2)
                .bot_FlickerEnabled == True ? Custom String("활성화") : Custom String("비활성화")) : Custom String("Bot Flicker: {0}",
                Players In Slot(Slot Of(Event Player), Team 2).bot_FlickerEnabled == True ? Custom String("On") : Custom String("Off")),
                Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuVectors[11], 1.500, Clip Against Surfaces, Visible To and String,
                Color(White), Default Visibility);
            Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_SkyMenu, Append To Array, Last Text ID);
            Create In-World Text(Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuVisibleTo, Players In Slot(Slot Of(Event Player),
                Team 1).p_Language == 1 ? Custom String("플레이어 엘리베이터: {0}", Players In Slot(Slot Of(Event Player), Team 1)
                .p_ElevatorEnabled == True ? Custom String("활성화") : Custom String("비활성화")) : Custom String("Player Elevator: {0}",
                Players In Slot(Slot Of(Event Player), Team 1).p_ElevatorEnabled == True ? Custom String("On") : Custom String("Off")),
                Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuVectors[12], 1.500, Clip Against Surfaces, Visible To and String,
                Color(White), Default Visibility);
            Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_SkyMenu, Append To Array, Last Text ID);
            Create In-World Text(Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuVisibleTo, Players In Slot(Slot Of(Event Player),
                Team 1).p_Language == 1 ? Custom String("색깔: {0}", Players In Slot(Slot Of(Event Player), Team 1).p_EffectsColor)
                : Custom String("Bubble & Effect Color: {0}", Players In Slot(Slot Of(Event Player), Team 1).p_EffectsColor), Players In Slot(
                Slot Of(Event Player), Team 1).hud_SkyMenuVectors[13], 1.500, Clip Against Surfaces, Visible To and String, Color(White),
                Default Visibility);
            Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_SkyMenu, Append To Array, Last Text ID);
            Create In-World Text(Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuVisibleTo, Players In Slot(Slot Of(Event Player),
                Team 1).p_Language == 1 ? Custom String("언어: {0}", Players In Slot(Slot Of(Event Player), Team 1)
                .p_Language == 1 ? Custom String("한국어") : Custom String("English")) : Custom String("Language: {0}", Players In Slot(Slot Of(
                Event Player), Team 1).p_Language == 1 ? Custom String("한국어") : Custom String("English")), Players In Slot(Slot Of(
                Event Player), Team 1).hud_SkyMenuVectors[14], 1.500, Clip Against Surfaces, Visible To and String, Color(White),
                Default Visibility);
            Modify Player Variable(Players In Slot(Slot Of(Event Player), Team 1), hud_SkyMenu, Append To Array, Last Text ID);
            Call Subroutine(hudSub_SkyMenuArrowSet);
            Stop Camera(Event Player);
            Start Camera(Players In Slot(Slot Of(Event Player), Team 1), Players In Slot(Slot Of(Event Player), Team 1)
                .hud_SkyMenuSelection - Vector(0, 15, 0.001), Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuSelection, 30);
            Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuIsOpen = True;
            Big Message(Players In Slot(Slot Of(Event Player), Team 1), Players In Slot(Slot Of(Event Player), Team 1)
                .p_Language == 1 ? Custom String("메뉴를 탐색하려면 WASD 버튼을 사용하십시오") : Custom String("Use WASD to navigate the menu"));
            Big Message(Players In Slot(Slot Of(Event Player), Team 1), Players In Slot(Slot Of(Event Player), Team 1)
                .p_Language == 1 ? Custom String("[{0} 및 {1}]를 길게 누르면 메뉴가 닫힙니다", Input Binding String(Button(Reload)), Input Binding String(
                Button(Melee))) : Custom String("Press {0} and {1} to close the menu", Input Binding String(Button(Reload)),
                Input Binding String(Button(Melee))));
        End;
        Play Effect(Players In Slot(Slot Of(Event Player), Team 1), Buff Explosion Sound, Color(White), Players In Slot(Slot Of(
            Event Player), Team 1).hud_SkyMenuSelection - Vector(0, 15, 0), 75);
    }
}
rule("Global HUD")
{
    event
    {
        Ongoing - Global;
    }
    conditions
    {
        Is Game In Progress == True;
    }
    actions
    {
        "Padding"
        Create HUD Text(All Players(All Teams), Null, Custom String(" "), Custom String(" "), Left, -20, Color(White), Color(White), Color(
            White), Visible To, Default Visibility);
        Create HUD Text(All Players(All Teams), Null, Custom String(" "), Custom String(" "), Left, -20, Color(White), Color(White), Color(
            White), Visible To, Default Visibility);
        Create HUD Text(All Players(All Teams), Custom String("{0}", Global.c_WorkshopCode), Custom String("{0}+{1}, {2}", Global.c_Version,
            Global.c_BuildDate, Global.c_DeveloperName), Custom String("Practice Field: Expanse"), Left, -3, Global.c_Color_LightPink,
            Global.c_Color_LightGrey, Global.c_Color_LightTeal, Visible To, Default Visibility);
        "Create Left Side HUD Text EN"
        Create HUD Text(Global.hud_MainVisibleToEN, Custom String(""), Custom String("Press {0} and {1} to show/hide info",
            Input Binding String(Button(Crouch)), Input Binding String(Button(Interact))), Null, Left, -1.890, Color(White), Color(White),
            Color(White), Visible To and String, Default Visibility);
        Create HUD Text(Global.hud_MainVisibleToEN, Custom String(""), Custom String("Hold {0} and {1} to change heroes",
            Input Binding String(Button(Crouch)), Input Binding String(Button(Reload))), Null, Left, -1.800, Color(White), Color(White),
            Color(White), Visible To and String, Default Visibility);
        Create HUD Text(Global.hud_MainVisibleToEN, Custom String(""), Custom String("Hold {0} and press {1} or {2} to cycle enemy hero",
            Input Binding String(Button(Interact)), Input Binding String(Button(Primary Fire)), Input Binding String(Button(
            Secondary Fire))), Null, Left, -1.600, Color(White), Color(White), Color(Yellow), Visible To and String, Default Visibility);
        Create HUD Text(Global.hud_MainVisibleToEN, Custom String(""), Custom String("Hold {0} and {1} to select specific enemy hero",
            Input Binding String(Button(Interact)), Input Binding String(Button(Reload))), Custom String(
            "Press {0} and {1} to open/close the menu", Input Binding String(Button(Reload)), Input Binding String(Button(Melee))), Left,
            -1.500, Color(White), Color(White), Global.c_Color_DarkPink, Visible To and String, Default Visibility);
        "Create Left Side HUD Text KR"
        Create HUD Text(Global.hud_MainVisibleToKR, Custom String(""), Custom String("버튼을 [{0} 및 {1}] 눌러 힌트 창을 닫습니다", Input Binding String(
            Button(Crouch)), Input Binding String(Button(Interact))), Null, Left, -1.890, Color(White), Color(White), Color(White),
            Visible To and String, Default Visibility);
        Create HUD Text(Global.hud_MainVisibleToKR, Custom String(""), Custom String("버튼 [{0} 및 {1}] 를 길게 눌러 영웅 선택", Input Binding String(
            Button(Crouch)), Input Binding String(Button(Reload))), Null, Left, -1.800, Color(White), Color(White), Color(White),
            Visible To and String, Default Visibility);
        Create HUD Text(Global.hud_MainVisibleToKR, Custom String(""), Custom String("버튼 [{0} 및 {1}] 를 길게 눌러 AI 영웅을 순환합니다.",
            Input Binding String(Button(Interact)), Input Binding String(Button(Primary Fire)), Input Binding String(Button(
            Secondary Fire))), Null, Left, -1.600, Color(White), Color(White), Color(Yellow), Visible To and String, Default Visibility);
        Create HUD Text(Global.hud_MainVisibleToKR, Custom String(""), Custom String("버튼 [{0} 및 {1}] 를 길게 눌러 AI 영웅을 선택합니다",
            Input Binding String(Button(Interact)), Input Binding String(Button(Reload))), Custom String("[{0} 및 {1}] 버튼을 길게 눌러 메뉴를 전환합니다",
            Input Binding String(Button(Reload)), Input Binding String(Button(Melee))), Left, -1.500, Color(White), Color(White),
            Global.c_Color_DarkPink, Visible To and String, Default Visibility);
        "Create Info HUD EN"
        Create HUD Text(Global.hud_InfoVisibleToEN, Custom String("Welcome to Practice Field: Expanse!"), Global.c_TwitchURL, Custom String(
            "Created by {0}", Global.c_DeveloperName), Top, 3, Global.c_Color_LightTeal, Global.c_Color_LightPink, Global.c_Color_LightPink,
            Visible To and String, Default Visibility);
        Create HUD Text(Global.hud_InfoVisibleToEN, Custom String(""), Custom String(
            "This workshop mode allows you to thoroughly warm up/practice your movement and aim on and against ALL heroes."),
            Custom String(
            "You are placed in a bubble against one bot opponent. When you kill them enough times it progresses to the next hero in the list."),
            Top, 5, Color(Yellow), Color(White), Global.c_Color_DarkPink, Visible To and String, Default Visibility);
        Create HUD Text(Global.hud_InfoVisibleToEN, Custom String(""), Null, Custom String(
            "The AI modes contain AI for all heroes written from scratch by myself. The bots do not attack below the difficulty \"AI Bronze\"."),
            Top, 5.100, Color(Yellow), Color(White), Color(White), Visible To and String, Default Visibility);
        Create HUD Text(Global.hud_InfoVisibleToEN, Custom String(""), Null, Custom String(
            "There are many difficulties and they correspond to many variables that affect the bots' movement, aim, and reaction time."),
            Top, 5.120, Color(Yellow), Color(White), Color(White), Visible To and String, Default Visibility);
        Create HUD Text(Global.hud_InfoVisibleToEN, Custom String(""), Null, Custom String("Press {0} and {1} to toggle the menu!",
            Input Binding String(Button(Reload)), Input Binding String(Button(Melee))), Top, 5.200, Color(White), Color(White),
            Global.c_Color_DarkTeal, Visible To and String, Default Visibility);
        Create HUD Text(Global.hud_InfoVisibleToEN, Custom String(""), Custom String(
            "There are many settings so you can customize your warmup!"), Custom String("See the top left corner for controls."), Top,
            5.300, Color(Yellow), Color(White), Global.c_Color_DarkTeal, Visible To and String, Default Visibility);
        Create HUD Text(Global.hud_InfoVisibleToEN, Custom String(""), Custom String("{0}", Global.c_GithubURL),
            Custom String("For the most recent c_Version: Please import code: {0}", Global.c_WorkshopCode), Top, 7, Color(Yellow),
            Global.c_Color_LightTeal, Global.c_Color_LightPink, Visible To and String, Default Visibility);
        Create HUD Text(Global.hud_InfoVisibleToEN, Custom String(""), Custom String("Press {0} and {1} to hide this text",
            Input Binding String(Button(Crouch)), Input Binding String(Button(Interact))), Null, Top, 8, Color(Yellow),
            Global.c_Color_LightGrey, Color(Sky Blue), Visible To and String, Default Visibility);
        "Create Info HUD KR"
        Create HUD Text(Global.hud_InfoVisibleToKR, Custom String("Practice Field: Expanse 어서 오십시오!"), Global.c_TwitchURL, Custom String(
            "창조자: {0}", Global.c_DeveloperName), Top, 3, Global.c_Color_LightTeal, Global.c_Color_LightPink, Global.c_Color_LightPink,
            Visible To and String, Default Visibility);
        Create HUD Text(Global.hud_InfoVisibleToKR, Custom String(""), Custom String("이 모드를 사용하면 워밍업하고 철저하게 연습 할 수 있습니다."), Custom String(
            "적을 충분한 횟수로 처치하면 다음 영웅이 생성됩니다."), Top, 5, Color(Yellow), Color(White), Global.c_Color_DarkPink, Visible To and String,
            Default Visibility);
        Create HUD Text(Global.hud_InfoVisibleToKR, Custom String(""), Null, Custom String(
            "나는 모든 영웅을 위해 인공 지능을 프로그래밍했습니다. 난이도가 \"인공지능 브론즈\" 미만이면 봇은 공격하지 않습니다."), Top, 5.100, Color(Yellow), Color(White), Color(White),
            Visible To and String, Default Visibility);
        Create HUD Text(Global.hud_InfoVisibleToKR, Custom String(""), Null, Custom String("난이도은 인공 지능의 움직임, 겨냥, 반응 시간에 영향을 미칩니다."), Top,
            5.120, Color(Yellow), Color(White), Color(White), Visible To and String, Default Visibility);
        Create HUD Text(Global.hud_InfoVisibleToKR, Custom String(""), Null, Custom String("[{0} 및 {1}] 버튼을 길게 눌러 메뉴를 전환합니다!",
            Input Binding String(Button(Reload)), Input Binding String(Button(Melee))), Top, 5.200, Color(White), Color(White),
            Global.c_Color_DarkTeal, Visible To and String, Default Visibility);
        Create HUD Text(Global.hud_InfoVisibleToKR, Custom String(""), Custom String("당신이 당신의 연습 루틴을 사용자 정의 할 수 있도록 많은 설정이 있습니다!"),
            Custom String("컨트롤은 왼쪽 상단을 참조하십시오."), Top, 5.300, Color(Yellow), Color(White), Global.c_Color_DarkTeal, Visible To and String,
            Default Visibility);
        Create HUD Text(Global.hud_InfoVisibleToKR, Custom String(""), Custom String(
            "{0}", Global.c_GithubURL), Custom String(
            "최신 버전을 얻으려면 코드 {0}를 사용하십시오!", Global.c_WorkshopCode), Top, 7, Color(Yellow), Global.c_Color_LightTeal, Global.c_Color_LightPink,
            Visible To and String, Default Visibility);
        Create HUD Text(Global.hud_InfoVisibleToKR, Custom String(""), Custom String("이 정보를 숨기려면 {0} 및 {1} 버튼을 사용하십시오",
            Input Binding String(Button(Crouch)), Input Binding String(Button(Interact))), Null, Top, 8, Color(Yellow),
            Global.c_Color_LightGrey, Color(Sky Blue), Visible To and String, Default Visibility);
        "Global Debug HUD"
        If(Global.g_DebugHUD == True);
            Create HUD Text(Null, Custom String("Server Load: {0}% ({1})", Round To Integer(Server Load / 2.550, Down), Server Load),
                Custom String("Average: {0}% ({1})", Round To Integer(Server Load Average / 2.550, Down), Server Load Average), Custom String(
                "Peak: {0}% ({1})", Round To Integer(Server Load Peak / 2.550, Down), Server Load Peak), Top, 100, Global.c_Color_LightPink,
                Global.c_Color_LightTeal, Global.c_Color_DarkTeal, Visible To and String, Visible Always);
        End;
    }
}
rule("Player Sky Menu Toggle")
{
    event
    {
        Ongoing - Each Player;
        Team 1;
        All;
    }
    conditions
    {
        Is Button Held(Event Player, Button(Melee)) == True;
        Is Button Held(Event Player, Button(Reload)) == True;
        Event Player.p_PlayerInitialized == True;
    }
    actions
    {
        Call Subroutine(allSub_WaitForFrame);
        Call Subroutine(hudSub_SkyMenuToggle);
    }
}
rule("Player Sky Menu Move Selection Up")
{
    event
    {
        Ongoing - Each Player;
        Team 1;
        All;
    }
    conditions
    {
        Event Player.hud_SkyMenuIsOpen == True;
        Throttle Of(Event Player) == Forward;
    }
    actions
    {
        Event Player.hud_SkyMenuSound = 3;
        Call Subroutine(hudSub_SkyMenuPlaySound);
        If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[0]);
            Event Player.hud_SkyMenuSelection = Last Of(Event Player.hud_SkyMenuVectors);
        Else;
            Event Player.hud_SkyMenuSelection = Event Player.hud_SkyMenuVectors[Index Of Array Value(Event Player.hud_SkyMenuVectors,
                Event Player.hud_SkyMenuSelection) - 1];
        End;
        Call Subroutine(hudSub_SkyMenuArrowSet);
    }
}
rule("Player Sky Menu Move Selection Down")
{
    event
    {
        Ongoing - Each Player;
        Team 1;
        All;
    }
    conditions
    {
        Event Player.hud_SkyMenuIsOpen == True;
        Throttle Of(Event Player) == Backward;
    }
    actions
    {
        Event Player.hud_SkyMenuSound = 3;
        Call Subroutine(hudSub_SkyMenuPlaySound);
        If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[Count Of(Event Player.hud_SkyMenuVectors) - 1]);
            Event Player.hud_SkyMenuSelection = Event Player.hud_SkyMenuVectors[0];
        Else;
            Event Player.hud_SkyMenuSelection = Event Player.hud_SkyMenuVectors[Index Of Array Value(Event Player.hud_SkyMenuVectors,
                Event Player.hud_SkyMenuSelection) + 1];
        End;
        Call Subroutine(hudSub_SkyMenuArrowSet);
    }
}
rule("Player Sky Menu Move Selection Decrease")
{
    event
    {
        Ongoing - Each Player;
        Team 1;
        All;
    }
    conditions
    {
        Event Player.hud_SkyMenuIsOpen == True;
        Throttle Of(Event Player) == Left;
    }
    actions
    {
        "Difficulty"
        If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[0] && Event Player.p_Difficulty > 0);
            Event Player.hud_SkyMenuSound = 2;
            Call Subroutine(hudSub_SkyMenuPlaySound);
            Event Player.p_Difficulty -= 1;
            Call Subroutine(pSub_SetDifficulty);
        Else If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[1] && Event Player.p_QuickModeEnabled == False);
            Event Player.hud_SkyMenuSound = 2;
            Call Subroutine(hudSub_SkyMenuPlaySound);
            If(Event Player.p_KillGoal <= 4);
                Event Player.p_KillGoal = Global.c_PseudoInfinity;
            Else If(Event Player.p_KillGoal == Global.c_PseudoInfinity);
                Event Player.p_KillGoal = 64;
            Else;
                Event Player.p_KillGoal -= 4;
            End;
            If(Event Player.all_Kills >= Event Player.p_KillGoal);
                Event Player.all_Kills = Event Player.p_KillGoal - 1;
            End;
        Else If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[2]);
            Event Player.hud_SkyMenuSound = 2;
            Call Subroutine(hudSub_SkyMenuPlaySound);
            If(Event Player.p_BotHeroClass > 0);
                Event Player.p_BotHeroClass -= 1;
            Else;
                Event Player.p_BotHeroClass = 3;
            End;
        Else If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[3] && Event Player.p_QuickModeEnabled == True);
            Event Player.hud_SkyMenuSound = 1;
            Call Subroutine(hudSub_SkyMenuPlaySound);
            Call Subroutine(pSub_QuickMode);
        Else If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[4] && Event Player.p_MirrorModeEnabled == True);
            Event Player.hud_SkyMenuSound = 1;
            Call Subroutine(hudSub_SkyMenuPlaySound);
            Event Player.p_MirrorModeEnabled = False;
        Else If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[5]);
            Event Player.hud_SkyMenuSound = 2;
            Call Subroutine(hudSub_SkyMenuPlaySound);
            If(Event Player.p_OneSecCooldown == 0);
                Event Player.p_OneSecCooldown = 3;
            Else;
                Event Player.p_OneSecCooldown -= 1;
            End;
        Else If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[6] && Event Player.p_MinusKillOnDeath == True);
            Event Player.hud_SkyMenuSound = 1;
            Call Subroutine(hudSub_SkyMenuPlaySound);
            Event Player.p_MinusKillOnDeath = False;
        Else If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[7] && Event Player.all_HealingEnabled == True);
            Event Player.hud_SkyMenuSound = 1;
            Call Subroutine(hudSub_SkyMenuPlaySound);
            Event Player.all_HealingEnabled = False;
        Else If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[8] && Players In Slot(Slot Of(Event Player), Team 2)
                .all_HealingEnabled == True);
            Event Player.hud_SkyMenuSound = 1;
            Call Subroutine(hudSub_SkyMenuPlaySound);
            Players In Slot(Slot Of(Event Player), Team 2).all_HealingEnabled = False;
        Else If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[9] && Event Player.p_Unkillable == True);
            Event Player.hud_SkyMenuSound = 1;
            Call Subroutine(hudSub_SkyMenuPlaySound);
            Clear Status(Event Player, Unkillable);
            Event Player.p_Unkillable = False;
        Else If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[10] && Players In Slot(Slot Of(Event Player), Team 2)
                .ai_UltimateDisabled == True);
            Event Player.hud_SkyMenuSound = 1;
            Call Subroutine(hudSub_SkyMenuPlaySound);
            Set Ultimate Ability Enabled(Players In Slot(Slot Of(Event Player), Team 2), True);
            Players In Slot(Slot Of(Event Player), Team 2).ai_UltimateDisabled = False;
        Else If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[11] && Players In Slot(Slot Of(Event Player), Team 2)
                .bot_FlickerEnabled == True);
            Event Player.hud_SkyMenuSound = 1;
            Call Subroutine(hudSub_SkyMenuPlaySound);
            Players In Slot(Slot Of(Event Player), Team 2).bot_FlickerEnabled = False;
        Else If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[12] && Players In Slot(Slot Of(Event Player), Team 1)
                .p_ElevatorEnabled == True);
            Event Player.hud_SkyMenuSound = 1;
            Call Subroutine(hudSub_SkyMenuPlaySound);
            Players In Slot(Slot Of(Event Player), Team 1).p_ElevatorEnabled = False;
            Stop Chasing Player Variable(Event Player, p_ElevatorHeight);
            Players In Slot(Slot Of(Event Player), Team 1).p_ElevatorHeight = 0;
            Set Jump Enabled(Event Player, True);
            Set Crouch Enabled(Event Player, True);
            Set Gravity(Event Player, 100);
        Else If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[13]);
            Event Player.hud_SkyMenuSound = 2;
            Call Subroutine(hudSub_SkyMenuPlaySound);
            If(Event Player.p_EffectsColor == Global.c_Color_EffectColors[0]);
                Players In Slot(Slot Of(Event Player), Team 1).p_EffectsColor = Global.c_Color_EffectColors[Count Of(Global.c_Color_EffectColors) - 1];
            Else;
                Players In Slot(Slot Of(Event Player), Team 1).p_EffectsColor = Global.c_Color_EffectColors[Index Of Array Value(Global.c_Color_EffectColors,
                    Event Player.p_EffectsColor) - 1];
            End;
        Else If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[14] && Event Player.p_Language == 1);
            Event Player.hud_SkyMenuSound = 2;
            Call Subroutine(hudSub_SkyMenuPlaySound);
            Players In Slot(Slot Of(Event Player), Team 1).p_Language = 0;
            Call Subroutine(pSub_SetLanguage);
            Call Subroutine(pSub_SetNames);
        End;
        Call Subroutine(hudSub_SkyMenuArrowSet);
    }
}
rule("Player Sky Menu Move Selection Increase")
{
    event
    {
        Ongoing - Each Player;
        Team 1;
        All;
    }
    conditions
    {
        Event Player.hud_SkyMenuIsOpen == True;
        Throttle Of(Event Player) == Right;
    }
    actions
    {
        "Difficulty"
        If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[0] && Event Player.p_Difficulty < 10);
            Event Player.hud_SkyMenuSound = 2;
            Call Subroutine(hudSub_SkyMenuPlaySound);
            Event Player.p_Difficulty += 1;
            Call Subroutine(pSub_SetDifficulty);
        Else If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[1] && Event Player.p_QuickModeEnabled == False);
            Event Player.hud_SkyMenuSound = 2;
            Call Subroutine(hudSub_SkyMenuPlaySound);
            If(Event Player.p_KillGoal == 64);
                Event Player.p_KillGoal = Global.c_PseudoInfinity;
            Else If(Event Player.p_KillGoal == Global.c_PseudoInfinity);
                Event Player.p_KillGoal = 4;
            Else;
                Event Player.p_KillGoal += 4;
            End;
            If(Event Player.all_Kills >= Event Player.p_KillGoal);
                Event Player.all_Kills = Event Player.p_KillGoal - 1;
            End;
        Else If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[2]);
            Event Player.hud_SkyMenuSound = 2;
            Call Subroutine(hudSub_SkyMenuPlaySound);
            If(Event Player.p_BotHeroClass < 3);
                Event Player.p_BotHeroClass += 1;
            Else;
                Event Player.p_BotHeroClass = 0;
            End;
        Else If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[3] && Event Player.p_QuickModeEnabled == False);
            Event Player.hud_SkyMenuSound = 0;
            Call Subroutine(hudSub_SkyMenuPlaySound);
            Call Subroutine(pSub_QuickMode);
        Else If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[4] && Event Player.p_MirrorModeEnabled == False);
            Event Player.hud_SkyMenuSound = 0;
            Call Subroutine(hudSub_SkyMenuPlaySound);
            Event Player.p_MirrorModeEnabled = True;
            Start Forcing Dummy Bot Name(Players In Slot(Slot Of(Event Player), Team 2), Event Player);
        Else If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[5]);
            Event Player.hud_SkyMenuSound = 2;
            Call Subroutine(hudSub_SkyMenuPlaySound);
            If(Event Player.p_OneSecCooldown == 3);
                Event Player.p_OneSecCooldown = 0;
            Else;
                Event Player.p_OneSecCooldown += 1;
            End;
        Else If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[6] && Event Player.p_MinusKillOnDeath == False);
            Event Player.hud_SkyMenuSound = 0;
            Call Subroutine(hudSub_SkyMenuPlaySound);
            Event Player.p_MinusKillOnDeath = True;
        Else If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[7] && Event Player.all_HealingEnabled == False);
            Event Player.hud_SkyMenuSound = 0;
            Call Subroutine(hudSub_SkyMenuPlaySound);
            Event Player.all_HealingEnabled = True;
        Else If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[8] && Players In Slot(Slot Of(Event Player), Team 2)
                .all_HealingEnabled == False);
            Event Player.hud_SkyMenuSound = 0;
            Call Subroutine(hudSub_SkyMenuPlaySound);
            Players In Slot(Slot Of(Event Player), Team 2).all_HealingEnabled = True;
        Else If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[9] && Event Player.p_Unkillable == False);
            Event Player.hud_SkyMenuSound = 0;
            Call Subroutine(hudSub_SkyMenuPlaySound);
            Set Status(Event Player, Null, Unkillable, 9999);
            Event Player.p_Unkillable = True;
        Else If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[10] && Players In Slot(Slot Of(Event Player), Team 2)
                .ai_UltimateDisabled == False);
            Event Player.hud_SkyMenuSound = 0;
            Call Subroutine(hudSub_SkyMenuPlaySound);
            Set Ultimate Ability Enabled(Players In Slot(Slot Of(Event Player), Team 2), False);
            Players In Slot(Slot Of(Event Player), Team 2).ai_UltimateDisabled = True;
        Else If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[11] && Players In Slot(Slot Of(Event Player), Team 2)
                .bot_FlickerEnabled == False);
            Event Player.hud_SkyMenuSound = 0;
            Call Subroutine(hudSub_SkyMenuPlaySound);
            Players In Slot(Slot Of(Event Player), Team 2).bot_FlickerEnabled = True;
        Else If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[12] && Players In Slot(Slot Of(Event Player), Team 1)
                .p_ElevatorEnabled == False);
            Event Player.hud_SkyMenuSound = 0;
            Call Subroutine(hudSub_SkyMenuPlaySound);
            Players In Slot(Slot Of(Event Player), Team 1).p_ElevatorEnabled = True;
            Set Jump Enabled(Event Player, False);
            Set Crouch Enabled(Event Player, False);
            Set Gravity(Event Player, 0);
            Small Message(Event Player, Players In Slot(Slot Of(Event Player), Team 1).p_Language == 1 ? Custom String("{0} = 올리다 / {1} = 낮추다",
                Input Binding String(Button(Jump)), Input Binding String(Button(Crouch))) : Custom String("{0} to go Up / {1} to go Down",
                Input Binding String(Button(Jump)), Input Binding String(Button(Crouch))));
        Else If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[13]);
            Event Player.hud_SkyMenuSound = 2;
            Call Subroutine(hudSub_SkyMenuPlaySound);
            If(Event Player.p_EffectsColor == Global.c_Color_EffectColors[Count Of(Global.c_Color_EffectColors) - 1]);
                Players In Slot(Slot Of(Event Player), Team 1).p_EffectsColor = Global.c_Color_EffectColors[0];
            Else;
                Players In Slot(Slot Of(Event Player), Team 1).p_EffectsColor = Global.c_Color_EffectColors[Index Of Array Value(Global.c_Color_EffectColors,
                    Event Player.p_EffectsColor) + 1];
            End;
        Else If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[14] && Event Player.p_Language == 0);
            Event Player.hud_SkyMenuSound = 2;
            Call Subroutine(hudSub_SkyMenuPlaySound);
            Players In Slot(Slot Of(Event Player), Team 1).p_Language = 1;
            Call Subroutine(pSub_SetLanguage);
            Call Subroutine(pSub_SetNames);
        End;
        Call Subroutine(hudSub_SkyMenuArrowSet);
    }
}
rule("Player Sky Menu Arrow Visibility")
{
    event
    {
        Subroutine;
        hudSub_SkyMenuArrowSet;
    }
    actions
    {
        If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[0]);
            If(Event Player.p_Difficulty == 0);
                Event Player.hud_SkyMenuArrowsVisibleTo[0] = Null;
                Event Player.hud_SkyMenuArrowsVisibleTo[1] = Event Player;
            Else If(Event Player.p_Difficulty == 10);
                Event Player.hud_SkyMenuArrowsVisibleTo[0] = Event Player;
                Event Player.hud_SkyMenuArrowsVisibleTo[1] = Null;
            Else;
                Event Player.hud_SkyMenuArrowsVisibleTo[0] = Event Player;
                Event Player.hud_SkyMenuArrowsVisibleTo[1] = Event Player;
            End;
        Else If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[1]);
            Event Player.hud_SkyMenuArrowsVisibleTo[0] = Event Player;
            Event Player.hud_SkyMenuArrowsVisibleTo[1] = Event Player;
        Else If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[2]);
            Event Player.hud_SkyMenuArrowsVisibleTo[0] = Event Player;
            Event Player.hud_SkyMenuArrowsVisibleTo[1] = Event Player;
        Else If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[3]);
            If(Event Player.p_QuickModeEnabled == False);
                Event Player.hud_SkyMenuArrowsVisibleTo[0] = Null;
                Event Player.hud_SkyMenuArrowsVisibleTo[1] = Event Player;
            Else If(Event Player.p_QuickModeEnabled == True);
                Event Player.hud_SkyMenuArrowsVisibleTo[1] = Null;
                Event Player.hud_SkyMenuArrowsVisibleTo[0] = Event Player;
            End;
        Else If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[4]);
            If(Event Player.p_MirrorModeEnabled == False);
                Event Player.hud_SkyMenuArrowsVisibleTo[0] = Null;
                Event Player.hud_SkyMenuArrowsVisibleTo[1] = Event Player;
            Else If(Event Player.p_MirrorModeEnabled == True);
                Event Player.hud_SkyMenuArrowsVisibleTo[1] = Null;
                Event Player.hud_SkyMenuArrowsVisibleTo[0] = Event Player;
            End;
        Else If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[5]);
            Event Player.hud_SkyMenuArrowsVisibleTo[0] = Event Player;
            Event Player.hud_SkyMenuArrowsVisibleTo[1] = Event Player;
        Else If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[6]);
            If(Event Player.p_MinusKillOnDeath == False);
                Event Player.hud_SkyMenuArrowsVisibleTo[0] = Null;
                Event Player.hud_SkyMenuArrowsVisibleTo[1] = Event Player;
            Else If(Event Player.p_MinusKillOnDeath == True);
                Event Player.hud_SkyMenuArrowsVisibleTo[1] = Null;
                Event Player.hud_SkyMenuArrowsVisibleTo[0] = Event Player;
            End;
        Else If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[7]);
            If(Event Player.all_HealingEnabled == False);
                Event Player.hud_SkyMenuArrowsVisibleTo[0] = Null;
                Event Player.hud_SkyMenuArrowsVisibleTo[1] = Event Player;
            Else If(Event Player.all_HealingEnabled == True);
                Event Player.hud_SkyMenuArrowsVisibleTo[1] = Null;
                Event Player.hud_SkyMenuArrowsVisibleTo[0] = Event Player;
            End;
        Else If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[8]);
            If(Players In Slot(Slot Of(Event Player), Team 2).all_HealingEnabled == False);
                Event Player.hud_SkyMenuArrowsVisibleTo[0] = Null;
                Event Player.hud_SkyMenuArrowsVisibleTo[1] = Event Player;
            Else If(Players In Slot(Slot Of(Event Player), Team 2).all_HealingEnabled == True);
                Event Player.hud_SkyMenuArrowsVisibleTo[1] = Null;
                Event Player.hud_SkyMenuArrowsVisibleTo[0] = Event Player;
            End;
        Else If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[9]);
            If(Event Player.p_Unkillable == False);
                Event Player.hud_SkyMenuArrowsVisibleTo[0] = Null;
                Event Player.hud_SkyMenuArrowsVisibleTo[1] = Event Player;
            Else If(Event Player.p_Unkillable == True);
                Event Player.hud_SkyMenuArrowsVisibleTo[1] = Null;
                Event Player.hud_SkyMenuArrowsVisibleTo[0] = Event Player;
            End;
        Else If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[10]);
            If(Players In Slot(Slot Of(Event Player), Team 2).ai_UltimateDisabled == False);
                Event Player.hud_SkyMenuArrowsVisibleTo[0] = Null;
                Event Player.hud_SkyMenuArrowsVisibleTo[1] = Event Player;
            Else If(Players In Slot(Slot Of(Event Player), Team 2).ai_UltimateDisabled == True);
                Event Player.hud_SkyMenuArrowsVisibleTo[1] = Null;
                Event Player.hud_SkyMenuArrowsVisibleTo[0] = Event Player;
            End;
        Else If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[11]);
            If(Players In Slot(Slot Of(Event Player), Team 2).bot_FlickerEnabled == False);
                Event Player.hud_SkyMenuArrowsVisibleTo[0] = Null;
                Event Player.hud_SkyMenuArrowsVisibleTo[1] = Event Player;
            Else If(Players In Slot(Slot Of(Event Player), Team 2).bot_FlickerEnabled == True);
                Event Player.hud_SkyMenuArrowsVisibleTo[1] = Null;
                Event Player.hud_SkyMenuArrowsVisibleTo[0] = Event Player;
            End;
        Else If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[12]);
            If(Players In Slot(Slot Of(Event Player), Team 1).p_ElevatorEnabled == False);
                Event Player.hud_SkyMenuArrowsVisibleTo[0] = Null;
                Event Player.hud_SkyMenuArrowsVisibleTo[1] = Event Player;
            Else If(Players In Slot(Slot Of(Event Player), Team 1).p_ElevatorEnabled == True);
                Event Player.hud_SkyMenuArrowsVisibleTo[1] = Null;
                Event Player.hud_SkyMenuArrowsVisibleTo[0] = Event Player;
            End;
        Else If(Event Player.hud_SkyMenuSelection == Event Player.hud_SkyMenuVectors[14]);
            If(Players In Slot(Slot Of(Event Player), Team 1).p_Language == 0);
                Event Player.hud_SkyMenuArrowsVisibleTo[0] = Null;
                Event Player.hud_SkyMenuArrowsVisibleTo[1] = Event Player;
            Else;
                Event Player.hud_SkyMenuArrowsVisibleTo[1] = Null;
                Event Player.hud_SkyMenuArrowsVisibleTo[0] = Event Player;
            End;
        Else;
            Event Player.hud_SkyMenuArrowsVisibleTo[0] = Event Player;
            Event Player.hud_SkyMenuArrowsVisibleTo[1] = Event Player;
        End;
    }
}
rule("Debug Toggle")
{
    event
    {
        Ongoing - Each Player;
        Team 1;
        All;
    }
    conditions
    {
        Is Button Held(Event Player, Button(Ability 2)) == True;
        Is Button Held(Event Player, Button(Reload)) == True;
        Is Button Held(Event Player, Button(Jump)) == True;
    }
    actions
    {
        Wait(0.500, Abort When False);
        Call Subroutine(hudSub_DebugToggle);
    }
}
rule("Info Toggle")
{
    event
    {
        Ongoing - Each Player;
        Team 1;
        All;
    }
    conditions
    {
        Is Button Held(Event Player, Button(Interact)) == True;
        Is Button Held(Event Player, Button(Crouch)) == True;
    }
    actions
    {
        Start Rule(hudSub_InfoToggle, Restart Rule);
    }
}
rule("pSub_SetDifficulty")
{
    event
    {
        Subroutine;
        pSub_SetDifficulty;
    }
    actions
    {
        Players In Slot(Slot Of(Event Player), Team 2).ai_ChanceMod = Players In Slot(Slot Of(Event Player), Team 1).p_Difficulty / 100;
        Players In Slot(Slot Of(Event Player), Team 2).ai_FacingAngleMod = 150 + 5 * Players In Slot(Slot Of(Event Player), Team 1)
            .p_Difficulty;
        Players In Slot(Slot Of(Event Player), Team 2).ai_FacingAnglePow = 0.225 + 0.005 * Players In Slot(Slot Of(Event Player), Team 1)
            .p_Difficulty;
        Players In Slot(Slot Of(Event Player), Team 2).ai_FacingCapMax = 540 + 18 * Players In Slot(Slot Of(Event Player), Team 1)
            .p_Difficulty;
        Players In Slot(Slot Of(Event Player), Team 2).ai_FacingCapMin = 540 + 9 * Players In Slot(Slot Of(Event Player), Team 1)
            .p_Difficulty;
        Players In Slot(Slot Of(Event Player), Team 2).ai_FacingPadMax = 200 + 5 * Players In Slot(Slot Of(Event Player), Team 1)
            .p_Difficulty;
        Players In Slot(Slot Of(Event Player), Team 2).ai_FacingPadMin = 150 + 5 * Players In Slot(Slot Of(Event Player), Team 1)
            .p_Difficulty;
        Players In Slot(Slot Of(Event Player), Team 2).ai_ReactionTime = 0.250 + 0.050 * (Global.c_MaxDifficulty - Players In Slot(Slot Of(
            Event Player), Team 1).p_Difficulty);
        Players In Slot(Slot Of(Event Player), Team 2).ai_ViewAngleMod = (Global.c_MaxDifficulty - Players In Slot(Slot Of(Event Player),
            Team 1).p_Difficulty) / 2;
        Players In Slot(Slot Of(Event Player), Team 2).bot_MoveCrouchChanceMod = 0.100 + Players In Slot(Slot Of(Event Player), Team 1)
            .p_Difficulty * 0.010;
        Players In Slot(Slot Of(Event Player), Team 2).bot_MoveCrouchTimeMod = 0.080 * Players In Slot(Slot Of(Event Player), Team 1)
            .p_Difficulty;
        Players In Slot(Slot Of(Event Player), Team 2).bot_MoveJumpChanceMod = 0.160 + Players In Slot(Slot Of(Event Player), Team 1)
            .p_Difficulty * 0.030;
        Players In Slot(Slot Of(Event Player), Team 2).bot_MoveJumpTimeMod = 1 + Players In Slot(Slot Of(Event Player), Team 1)
            .p_Difficulty * 0.070;
        Players In Slot(Slot Of(Event Player), Team 2).bot_MoveWASDTimeMod = 2 - 0.100 * Players In Slot(Slot Of(Event Player), Team 1)
            .p_Difficulty;
        If(Players In Slot(Slot Of(Event Player), Team 1).p_Difficulty < 3);
            Clear Status(Players In Slot(Slot Of(Event Player), Team 2), Unkillable);
        End;
    }
}
rule("pSub_SetHeroClass")
{
    event
    {
        Subroutine;
        pSub_SetHeroClass;
    }
    actions
    {
        If(Array Contains(All Heroes, Global.g_DebugHero[1]));
            Players In Slot(Slot Of(Event Player), Team 1).p_KillGoal = Global.c_PseudoInfinity;
            Players In Slot(Slot Of(Event Player), Team 1).p_HeroList = Array(Global.g_DebugHero[1]);
            Players In Slot(Slot Of(Event Player), Team 1).p_HeroListName = Global.g_DebugHero[1];
        Else;
            If(Players In Slot(Slot Of(Event Player), Team 1).p_HeroListName != Players In Slot(Slot Of(Event Player), Team 1)
                .p_HeroClassNames[Players In Slot(Slot Of(Event Player), Team 1).p_BotHeroClass]);
                Players In Slot(Slot Of(Event Player), Team 1).p_HeroList = Randomized Array(Global.c_HeroClasses[Players In Slot(Slot Of(
                    Event Player), Team 1).p_BotHeroClass]);
                Players In Slot(Slot Of(Event Player), Team 1).p_HeroListName = Players In Slot(Slot Of(Event Player), Team 1)
                    .p_HeroClassNames[Players In Slot(Slot Of(Event Player), Team 1).p_BotHeroClass];
            End;
        End;
    }
}
rule("Player Set Language")
{
    event
    {
        Subroutine;
        pSub_SetLanguage;
    }
    actions
    {
        If(Event Player.p_Language == 1);
            Modify Global Variable(hud_MainVisibleToEN, Remove From Array By Value, Event Player);
            Modify Global Variable(hud_MainVisibleToKR, Append To Array, Event Player);
        Else;
            Modify Global Variable(hud_MainVisibleToKR, Remove From Array By Value, Event Player);
            Modify Global Variable(hud_MainVisibleToEN, Append To Array, Event Player);
        End;
    }
}
rule("Player Set Names")
{
    event
    {
        Subroutine;
        pSub_SetNames;
    }
    actions
    {
        Players In Slot(Slot Of(Event Player), Team 1).p_DifficultyNames = Empty Array;
        Players In Slot(Slot Of(Event Player), Team 1).p_DifficultyNames[0] = Players In Slot(Slot Of(Event Player), Team 1)
            .p_Language == 1 ? Custom String("안전하고 쉬움") : Custom String("No AI Easy");
        Players In Slot(Slot Of(Event Player), Team 1).p_DifficultyNames[1] = Players In Slot(Slot Of(Event Player), Team 1)
            .p_Language == 1 ? Custom String("안전하고 중간") : Custom String("No AI Medium");
        Players In Slot(Slot Of(Event Player), Team 1).p_DifficultyNames[2] = Players In Slot(Slot Of(Event Player), Team 1)
            .p_Language == 1 ? Custom String("안전하고 곤란한") : Custom String("No AI Hard");
        Players In Slot(Slot Of(Event Player), Team 1).p_DifficultyNames[3] = Players In Slot(Slot Of(Event Player), Team 1)
            .p_Language == 1 ? Custom String("인공지능 브론즈") : Custom String("AI Bronze");
        Players In Slot(Slot Of(Event Player), Team 1).p_DifficultyNames[4] = Players In Slot(Slot Of(Event Player), Team 1)
            .p_Language == 1 ? Custom String("인공지능 실버") : Custom String("AI Silver");
        Players In Slot(Slot Of(Event Player), Team 1).p_DifficultyNames[5] = Players In Slot(Slot Of(Event Player), Team 1)
            .p_Language == 1 ? Custom String("인공지능 골드") : Custom String("AI Gold");
        Players In Slot(Slot Of(Event Player), Team 1).p_DifficultyNames[6] = Players In Slot(Slot Of(Event Player), Team 1)
            .p_Language == 1 ? Custom String("인공지능 플래티넘") : Custom String("AI Platinum");
        Players In Slot(Slot Of(Event Player), Team 1).p_DifficultyNames[7] = Players In Slot(Slot Of(Event Player), Team 1)
            .p_Language == 1 ? Custom String("인공지능 다이아몬드") : Custom String("AI Diamond");
        Players In Slot(Slot Of(Event Player), Team 1).p_DifficultyNames[8] = Players In Slot(Slot Of(Event Player), Team 1)
            .p_Language == 1 ? Custom String("인공지능 마스터") : Custom String("AI Master");
        Players In Slot(Slot Of(Event Player), Team 1).p_DifficultyNames[9] = Players In Slot(Slot Of(Event Player), Team 1)
            .p_Language == 1 ? Custom String("인공지능 그랜드마스터") : Custom String("AI Grandmaster");
        Players In Slot(Slot Of(Event Player), Team 1).p_DifficultyNames[10] = Players In Slot(Slot Of(Event Player), Team 1)
            .p_Language == 1 ? Custom String("인공지능 상위500위") : Custom String("AI Top 500");
        Players In Slot(Slot Of(Event Player), Team 1).p_HeroClassNames = Empty Array;
        Players In Slot(Slot Of(Event Player), Team 1).p_HeroClassNames[0] = Players In Slot(Slot Of(Event Player), Team 1)
            .p_Language == 1 ? Custom String("모든") : Custom String("All");
        Players In Slot(Slot Of(Event Player), Team 1).p_HeroClassNames[1] = Players In Slot(Slot Of(Event Player), Team 1)
            .p_Language == 1 ? Custom String("돌격") : Custom String("Tank");
        Players In Slot(Slot Of(Event Player), Team 1).p_HeroClassNames[2] = Players In Slot(Slot Of(Event Player), Team 1)
            .p_Language == 1 ? Custom String("공격") : Custom String("Damage");
        Players In Slot(Slot Of(Event Player), Team 1).p_HeroClassNames[3] = Players In Slot(Slot Of(Event Player), Team 1)
            .p_Language == 1 ? Custom String("지원") : Custom String("Support");
    }
}
rule("Player Set Distances")
{
    event
    {
        Subroutine;
        pSub_SetDistances;
    }
    actions
    {
        Players In Slot(Slot Of(Event Player), Team 1).p_ZoneRadius = Global.c_ZoneRadiusDefault;
        If(Array Contains(Global.c_LongRangeHeroes, Hero Of(Players In Slot(Slot Of(Event Player), Team 1))) == True);
            Players In Slot(Slot Of(Event Player), Team 1).p_EnemyDistanceMax = Global.c_LongDistance;
        Else If(Array Contains(Global.c_MediumRangeHeroes, Hero Of(Players In Slot(Slot Of(Event Player), Team 1))) == True);
            Players In Slot(Slot Of(Event Player), Team 1).p_EnemyDistanceMax = Global.c_MediumDistance;
        Else If(Array Contains(Global.c_ShortRangeHeroes, Hero Of(Players In Slot(Slot Of(Event Player), Team 1))) == True);
            Players In Slot(Slot Of(Event Player), Team 1).p_EnemyDistanceMax = Global.c_ShortDistance;
        Else If(Array Contains(Global.c_LargeZoneHeroes, Hero Of(Players In Slot(Slot Of(Event Player), Team 1))) == True);
            Players In Slot(Slot Of(Event Player), Team 1).p_EnemyDistanceMax = Global.c_ShortDistance;
            Players In Slot(Slot Of(Event Player), Team 1).p_ZoneRadius = Players In Slot(Slot Of(Event Player), Team 1).p_EnemyDistanceMax;
        Else If(Array Contains(Global.c_VeryShortRangeHeroes, Hero Of(Players In Slot(Slot Of(Event Player), Team 1))) == True);
            Players In Slot(Slot Of(Event Player), Team 1).p_EnemyDistanceMax = Global.c_VeryShortDistance;
            Players In Slot(Slot Of(Event Player), Team 1).p_ZoneRadius = Players In Slot(Slot Of(Event Player), Team 1).p_EnemyDistanceMax;
        End;
    }
}
rule("pSub_QuickMode")
{
    event
    {
        Subroutine;
        pSub_QuickMode;
    }
    actions
    {
        If(Event Player.p_QuickModeEnabled);
            Event Player.p_KillGoal = Global.g_KillGoal;
            Event Player.p_QuickModeEnabled = False;
        Else;
            Event Player.all_Kills = 0;
            Event Player.p_KillGoal = 1;
            Event Player.p_QuickModeEnabled = True;
        End;
    }
}
rule("pSub_Elevator")
{
    event
    {
        Subroutine;
        pSub_Elevator;
    }
    actions
    {
        Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
        Stop Chasing Player Variable(Event Player, p_ElevatorHeight);
        Start Forcing Player Position(Event Player, Vector(X Component Of(Event Player.p_HomeVector), Event Player.p_ElevatorHeight,
            Z Component Of(Event Player.p_HomeVector)), True);
        Chase Player Variable Over Time(Event Player, p_ElevatorHeight, (Event Player.all_SubArg[0] == 1 ? 2 : -2)
            + Event Player.p_ElevatorHeight - Event Player.p_ElevatorHeight % 2, 0.250, None);
        Wait(0.250, Ignore Condition);
        Loop If Condition Is True;
        Wait(0.250, Ignore Condition);
        Stop Forcing Player Position(Event Player);
        Stop Forcing Throttle(Event Player);
        Event Player.p_ElevatorPosition = Empty Array;
        Event Player.p_ElevatorPosition[0] = Position Of(Event Player);
        Wait(0.100, Ignore Condition);
        Event Player.p_ElevatorPosition[1] = Position Of(Event Player);
        Apply Impulse(Event Player, Direction Towards(Event Player.p_ElevatorPosition[1], Event Player.p_ElevatorPosition[0]),
            Speed Of In Direction(Event Player, Direction Towards(Event Player.p_ElevatorPosition[0], Event Player.p_ElevatorPosition[1])),
            To World, Incorporate Contrary Motion);
        Small Message(Event Player, Players In Slot(Slot Of(Event Player), Team 1).p_Language == 1 ? Custom String("높이: {0} 미터",
            Event Player.p_ElevatorHeight) : Custom String("Height: {0} Meters", Event Player.p_ElevatorHeight));
    }
}
rule("Player Init")
{
    event
    {
        Ongoing - Each Player;
        Team 1;
        All;
    }
    conditions
    {
        Is Game In Progress == True;
        Has Spawned(Event Player) == True;
        Event Player.p_PlayerInitialized == False;
    }
    actions
    {
        "Disable Buttons"
        Call Subroutine(allSub_ButtonsDisallow);
        "Force facing and prevent movement"
        Start Facing(Event Player, Vector(0, 0, 0), 1000, To World, None);
        Start Forcing Throttle(Event Player, 0, 0, 0, 0, 0, 0);
        "Set Language"
        Event Player.p_Language = Global.g_Language;
        Call Subroutine(pSub_SetLanguage);
        "Show info"
        Start Rule(hudSub_InfoToggle, Restart Rule);
        "Disable HUDs"
        Disable Game Mode HUD(Event Player);
        Disable Hero HUD(Event Player);
        "Start Camera"
        Event Player.p_CameraEyePos = Vector(0, Global.c_BubbleRadius * 2, 0);
        Event Player.p_CameraLookAtPos = Vector(0, 200, 0);
        Start Camera(Event Player, Event Player.p_CameraEyePos, Event Player.p_CameraLookAtPos, 10);
        "Initialize Variables"
        Call Subroutine(pSub_SetNames);
        Event Player.all_Kills = 0;
        Event Player.p_BotHeroNumber = 0;
        Event Player.p_BotHeroClass = Global.g_HeroClass;
        Event Player.p_HeroNumberMod = 0;
        Event Player.p_KillGoal = Global.g_KillGoal;
        Call Subroutine(pSub_SetHeroClass);
        Event Player.hud_InfoEnabled = False;
        Event Player.all_HealingEnabled = Global.g_PlayerHealing;
        Event Player.p_OneSecCooldown = False;
        Event Player.p_MinusKillOnDeath = False;
        Event Player.p_MirrorModeEnabled = False;
        Event Player.p_Difficulty = Global.g_Difficulty;
        Event Player.p_EffectsColor = Global.c_Color_EffectColors[0];
        Event Player.p_ZoneRadius = Global.c_ZoneRadiusDefault;
        Event Player.p_PlayerHero = Hero Of(Event Player);
        Call Subroutine(pSub_SetDistances);
        "HUD Object Arrays"
        Event Player.hud_Info = Empty Array;
        Event Player.hud_Debug = Empty Array;
        Event Player.hud_SkyMenu = Empty Array;
        "Set Home Vector"
        If(Slot Of(Event Player) == 0);
            Event Player.p_HomeVector = Vector(-380 + Global.c_BubbleRadius, 0, 380 - Global.c_BubbleRadius);
        Else If(Slot Of(Event Player) == 1);
            Event Player.p_HomeVector = Vector(380 - Global.c_BubbleRadius, 0, -380 + Global.c_BubbleRadius);
        Else If(Slot Of(Event Player) == 2);
            Event Player.p_HomeVector = Vector(380 - Global.c_BubbleRadius, 0, 380 - Global.c_BubbleRadius);
        Else If(Slot Of(Event Player) == 3);
            Event Player.p_HomeVector = Vector(-380 + Global.c_BubbleRadius, 0, -380 + Global.c_BubbleRadius);
        Else If(Slot Of(Event Player) == 4);
            Event Player.p_HomeVector = Vector(0, 0, 380 - Global.c_BubbleRadius);
        Else If(Slot Of(Event Player) == 5);
            Event Player.p_HomeVector = Vector(0, 0, -380 + Global.c_BubbleRadius);
        End;
        Event Player.p_Effects = Empty Array;
        "Create Player Bubble"
        Create Effect(All Players(All Teams), Sphere, Event Player.p_EffectsColor, Event Player.p_HomeVector, Global.c_BubbleRadius,
            Color);
        Event Player.p_Effects[0] = Last Created Entity;
        "Create Player Movement Zone"
        Create Effect(All Players(All Teams), Ring, Event Player.p_EffectsColor, Event Player.p_HomeVector,
            Event Player.p_ZoneRadius + 1.250, Position Radius and Color);
        Event Player.p_Effects[1] = Last Created Entity;
        "Create Maximum Enemy Distance Zone"
        Create Effect(All Players(All Teams), Light Shaft, Event Player.p_EffectsColor, Event Player.p_HomeVector,
            Event Player.p_EnemyDistanceMax + 1.250, Position Radius and Color);
        Event Player.p_Effects[2] = Last Created Entity;
        Wait(1, Ignore Condition);
        Event Player.p_CameraLookAtPos = Event Player.p_HomeVector;
        "Intro tip"
        Small Message(Event Player, Players In Slot(Slot Of(Event Player), Team 1).p_Language == 1 ? Custom String("메뉴를 열어 환경 설정을 구성하십시오.")
            : Custom String("Open menu for options"));
        Wait(1, Ignore Condition);
        Event Player.p_CameraEyePos = Event Player.p_HomeVector + Vector(0, Global.c_BubbleRadius * 2, 0.001);
        Small Message(Event Player, Players In Slot(Slot Of(Event Player), Team 1).p_Language == 1 ? Custom String("활성화하려면 봇을 공격하십시오.")
            : Custom String("Attack the bot to start"));
        Wait(1, Ignore Condition);
        Event Player.p_CameraEyePos = Event Player.p_HomeVector + Vector(0, 5, 0.001);
        "Preload Heroes"
        For Player Variable(Event Player, all_Index, 0, Count Of(All Heroes), 1);
            Preload Hero(Event Player, All Heroes[Event Player.all_Index]);
            Wait(1 / 60, Ignore Condition);
        End;
        "Global 1 Second Cooldown"
        If(Global.g_OneSecCooldown == True);
            Event Player.p_OneSecCooldown = 3;
        End;
        "Teleport Player Home And Reset HUD"
        Teleport(Event Player, Event Player.p_HomeVector);
        Event Player.p_CameraEyePos = Eye Position(Event Player);
        Event Player.p_CameraLookAtPos = Ray Cast Hit Position(Eye Position(Event Player), Eye Position(Event Player)
            + Facing Direction Of(Event Player) * 1, Null, Event Player, False);
        Wait(0.500, Ignore Condition);
        Stop Camera(Event Player);
        Call Subroutine(hudSub_MainToggle);
        Enable Hero HUD(Event Player);
        Call Subroutine(allSub_ButtonsAllow);
        Stop Forcing Throttle(Event Player);
        "Player initialization is complete"
        Event Player.p_PlayerInitialized = True;
        Log To Inspector(Custom String("{0} spawned as {1} at vector {2}", Custom String("{0}: {1}", Total Time Elapsed, Event Player), Hero Of(Event Player), Event Player.p_HomeVector));
        "Add Player name to pool of names"
        If(Global.g_UseBotNames == True && Count Of(Global.g_PlayerNames) < 256);
            Modify Global Variable(g_PlayerNames, Append To Array, Custom String("{0}", Event Player));
            Modify Global Variable(g_BotNames, Append To Array, Custom String("{0}", Event Player));
        End;
    }
}
rule("Player Died")
{
    event
    {
        Player Died;
        Team 1;
        All;
    }
    conditions
    {
        Event Player.p_Difficulty >= 3;
    }
    actions
    {
        Stop Heal Over Time(Event Player.all_InspireHealID);
        Set Status(Event Player, Null, Invincible, 2.250);
        Stop Forcing Player Position(Event Player);
    }
}
rule("Increment Kills")
{
    event
    {
        Player Dealt Final Blow;
        Team 1;
        All;
    }
    conditions
    {
        Players In Slot(Slot Of(Event Player), Team 2) == Victim;
    }
    actions
    {
        Event Player.all_Kills += 1;
    }
}
rule("Next Hero")
{
    event
    {
        Ongoing - Each Player;
        Team 1;
        All;
    }
    conditions
    {
        Is Game In Progress == True;
        Event Player.all_Kills == Event Player.p_KillGoal;
    }
    actions
    {
        "Echo locks you out of switching heroes for ~5 seconds"
        If(Is Duplicating(Event Player));
            "So this was causing an issue with Create Dummy Bot"
            Damage(Event Player, Null, 9999);
            Wait(5, Ignore Condition);
        End;
        Event Player.p_HeroNumberMod = 1;
        Call Subroutine(botSub_SetHero);
    }
}
rule("Reset Player At Home")
{
    event
    {
        Ongoing - Each Player;
        Team 1;
        All;
    }
    conditions
    {
        Distance Between(Vector(X Component Of(Position Of(Event Player)), 0, Z Component Of(Position Of(Event Player))),
            Event Player.p_HomeVector) > Event Player.p_ZoneRadius;
        Is Alive(Event Player) == True;
        Has Spawned(Event Player) == True;
        Event Player.p_PlayerInitialized == True;
    }
    actions
    {
        "Prevent Widowmaker Doomfist loop bug"
        If(((Hero Of(Event Player) == Hero(Widowmaker) && Is Using Ability 1(Event Player)) || (Hero Of(Event Player) == Hero(Doomfist)
            && Is Using Ability 2(Event Player))) == True);
            Cancel Primary Action(Event Player);
        End;
        Play Effect(Event Player, Debuff Impact Sound, Color(White), Event Player, 75);
        Play Effect(Event Player, Bad Pickup Effect, Color(White), Event Player.p_HomeVector, 1);
        If(Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 2), 20) == True);
            Teleport(Event Player, Event Player.p_HomeVector);
            Wait(1 / 60, Ignore Condition);
            Start Facing(Event Player, Direction Towards(Eye Position(Event Player), Eye Position(Players In Slot(Slot Of(Event Player),
                Team 2))), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Eye Position(
                Players In Slot(Slot Of(Event Player), Team 2)))) * 5, To World, None);
            Wait(0.200, Ignore Condition);
            Stop Facing(Event Player);
        Else;
            Teleport(Event Player, Event Player.p_HomeVector);
        End;
        If(Event Player.p_ElevatorEnabled == True);
            Start Forcing Player Position(Event Player, Vector(X Component Of(Event Player.p_HomeVector), Event Player.p_ElevatorHeight,
                Z Component Of(Event Player.p_HomeVector)), False);
            Wait(0.250, Ignore Condition);
            Stop Forcing Player Position(Event Player);
        End;
        Allow Button(Event Player, Button(Jump));
    }
}
rule("Player Change Self Hero")
{
    event
    {
        Ongoing - Each Player;
        Team 1;
        All;
    }
    conditions
    {
        Is Button Held(Event Player, Button(Crouch)) == True;
        Is Button Held(Event Player, Button(Reload)) == True;
        Event Player.all_ChangingHero == False;
        Players In Slot(Slot Of(Event Player), Team 2).all_ChangingHero == False;
        Event Player.p_PlayerInitialized == True;
    }
    actions
    {
        Wait(15 / 60, Abort When False);
        If(Event Player.p_MirrorModeEnabled == True);
            Small Message(Event Player, Players In Slot(Slot Of(Event Player), Team 1).p_Language == 1 ? Custom String(
                "같은 영웅 모드가 활성화 된 동안에는 영웅을 변경할 수 없습니다.") : Custom String("Cannot change heroes while Mirror Mode is on"));
            Abort;
        End;
        Small Message(Event Player, Players In Slot(Slot Of(Event Player), Team 1).p_Language == 1 ? Custom String(
            "{0} 및 {1} 버튼을 계속 누르고 있으면 영웅이 변경됩니다.", Input Binding String(Button(Crouch)), Input Binding String(Button(Reload)))
            : Custom String("Continue holding {0} and {1} to change heroes", Input Binding String(Button(Crouch)), Input Binding String(
            Button(Reload))));
        Set Status(Event Player, Null, Phased Out, 1);
        Wait(15 / 60, Abort When False);
        Set Player Allowed Heroes(Event Player, Remove From Array(All Heroes, Hero Of(Event Player)));
        Event Player.all_ChangingHero = True;
        Wait(1, Ignore Condition);
        Reset Player Hero Availability(Event Player);
    }
}
rule("Player Self Hero Change Teleport Enemy On Spawn")
{
    event
    {
        Ongoing - Each Player;
        Team 1;
        All;
    }
    conditions
    {
        Is In Spawn Room(Event Player) == False;
        Has Spawned(Event Player) == True;
        Event Player.all_ChangingHero == True;
        Players In Slot(Slot Of(Event Player), Team 2).all_ChangingHero == False;
    }
    actions
    {
        Wait(6 / 60, Abort When False);
        Call Subroutine(pSub_SetDistances);
        Call Subroutine(botSub_TeleportBot);
        Event Player.all_ChangingHero = False;
    }
}
rule("Player Change Bot Hero")
{
    event
    {
        Ongoing - Each Player;
        Team 1;
        All;
    }
    conditions
    {
        Is Button Held(Event Player, Button(Interact)) == True;
        Is Button Held(Event Player, Button(Reload)) == True;
        Players In Slot(Slot Of(Event Player), Team 2).all_ChangingHero == False;
        Event Player.all_ChangingHero == False;
        Event Player.p_PlayerInitialized == True;
    }
    actions
    {
        Wait(15 / 60, Abort When False);
        Small Message(Event Player, Players In Slot(Slot Of(Event Player), Team 1).p_Language == 1 ? Custom String(
            "{0} 및 {1} 버튼을 계속 누르고 있으면 적 영웅을 선택합니다.", Input Binding String(Button(Interact)), Input Binding String(Button(Reload)))
            : Custom String("Continue holding {0} and {1} to change bot hero", Input Binding String(Button(Interact)),
            Input Binding String(Button(Reload))));
        Set Status(Event Player, Null, Phased Out, 1);
        Wait(15 / 60, Abort When False);
        Event Player.p_PlayerHero = Hero Of(Event Player);
        Start Camera(Event Player, Position Of(Players In Slot(Slot Of(Event Player), Team 2) + Vector(0, 10, 10)), Position Of(
            Players In Slot(Slot Of(Event Player), Team 2)), 45);
        Set Player Allowed Heroes(Event Player, Remove From Array(All Heroes, Hero Of(Event Player)));
        Players In Slot(Slot Of(Event Player), Team 2).all_ChangingHero = True;
        Wait(1, Ignore Condition);
        Reset Player Hero Availability(Event Player);
    }
}
rule("Player Change Bot Hero On Spawn")
{
    event
    {
        Ongoing - Each Player;
        Team 1;
        All;
    }
    conditions
    {
        Is In Spawn Room(Event Player) == False;
        Has Spawned(Event Player) == True;
        Event Player.all_ChangingHero == False;
        Players In Slot(Slot Of(Event Player), Team 2).all_ChangingHero == True;
    }
    actions
    {
        Wait(9 / 60, Abort When False);
        If(Event Player.p_BotHeroClass != 0);
            Event Player.p_BotHeroClass = 0;
            Call Subroutine(pSub_SetHeroClass);
        End;
        Event Player.p_BotHeroNumber = Index Of Array Value(Event Player.p_HeroList, Hero Of(Event Player));
        Start Forcing Player To Be Hero(Event Player, Event Player.p_PlayerHero);
        Wait(1 / 60, Ignore Condition);
        Stop Forcing Player To Be Hero(Event Player);
        Call Subroutine(botSub_SetHero);
        Players In Slot(Slot Of(Event Player), Team 2).all_ChangingHero = False;
        Set Facing(Event Player, Direction Towards(Eye Position(Event Player), Eye Position(Players In Slot(Slot Of(Event Player), Team 2))
            - Vector(0, 0.250, 0)), To World);
        Wait(0.350, Ignore Condition);
        Stop Camera(Event Player);
    }
}
rule("Disable Primary Secondary Skip")
{
    event
    {
        Ongoing - Each Player;
        Team 1;
        All;
    }
    conditions
    {
        Is Button Held(Event Player, Button(Interact)) == True;
        Has Spawned(Event Player) == True;
    }
    actions
    {
        Disallow Button(Event Player, Button(Primary Fire));
        Disallow Button(Event Player, Button(Secondary Fire));
        Wait Until(Is Button Held(Event Player, Button(Interact)) == False, 9999);
        Wait(0.750, Ignore Condition);
        Allow Button(Event Player, Button(Primary Fire));
        Allow Button(Event Player, Button(Secondary Fire));
    }
}
rule("Skip Hero")
{
    event
    {
        Ongoing - Each Player;
        Team 1;
        All;
    }
    conditions
    {
        Is Button Held(Event Player, Button(Interact)) == True;
        (Is Button Held(Event Player, Button(Primary Fire)) == True || Is Button Held(Event Player, Button(Secondary Fire)) == True)
            == True;
    }
    actions
    {
        If(Is Button Held(Event Player, Button(Primary Fire)) == True);
            Event Player.p_HeroNumberMod = 1;
        Else;
            Event Player.p_HeroNumberMod = -1;
        End;
        Call Subroutine(botSub_SetHero);
    }
}
rule("Target Help Indicator")
{
    event
    {
        Ongoing - Each Player;
        Team 1;
        All;
    }
    conditions
    {
        Is Game In Progress == True;
        Has Spawned(Event Player) == True;
        Is Alive(Event Player) == True;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Opposite Team Of(Team Of(Event Player))), 90) == False;
        Event Player.p_Difficulty < 3;
        Y Component Of(Facing Direction Of(Event Player)) <= 0.500;
    }
    actions
    {
        Wait(4, Abort When False);
        Play Effect(Event Player, Debuff Impact Sound, Color(White), Players In Slot(Slot Of(Event Player), Opposite Team Of(Team Of(
            Event Player))), 200);
        Big Message(Event Player, Players In Slot(Slot Of(Event Player), Team 1).p_Language == 1 ? Custom String("제발 돌아서!")
            : Custom String("Turn Around!"));
        Create In-World Text(Event Player, Custom String("TARGET!"), Players In Slot(Slot Of(Event Player), Opposite Team Of(Team Of(
            Event Player))), 4, Do Not Clip, Visible To Position and String, Color(Yellow), Default Visibility);
        Event Player.p_HelpTargetIndicator = Last Text ID;
        Wait(3, Ignore Condition);
        Destroy In-World Text(Event Player.p_HelpTargetIndicator);
        Loop If Condition Is True;
    }
}
rule("Help Skip Message")
{
    event
    {
        Player Died;
        Team 1;
        All;
    }
    conditions
    {
        Is Game In Progress == True;
        Players In Slot(Slot Of(Event Player), Team 2).all_Kills >= 2;
        Players In Slot(Slot Of(Event Player), Team 2).all_Kills > Event Player.all_Kills;
        Players In Slot(Slot Of(Event Player), Team 2).all_Kills % 2 == 0;
        Event Player.p_Difficulty >= 3;
    }
    actions
    {
        If(Players In Slot(Slot Of(Event Player), Team 2).all_Kills % 4 == 0);
            Small Message(Event Player, Players In Slot(Slot Of(Event Player), Team 1).p_Language == 1 ? Custom String(
                "조언: 메뉴에서 난이도를 낮출 수 있습니다") : Custom String("Tip: Difficulty can be lowered in the menu"));
        End;
        Small Message(Event Player, Players In Slot(Slot Of(Event Player), Team 1).p_Language == 1 ? Custom String(
            "{1} 및 {2} 을 눌러 {0} 건너 뛰기", Hero Icon String(Hero Of(Players In Slot(Slot Of(Event Player), Team 2))), Input Binding String(
            Button(Interact)), Input Binding String(Button(Primary Fire))) : Custom String("To skip {0} hold {1} and press {2}",
            Hero Icon String(Hero Of(Players In Slot(Slot Of(Event Player), Team 2))), Input Binding String(Button(Interact)),
            Input Binding String(Button(Primary Fire))));
    }
}
rule("Player Mirror Mode On")
{
    event
    {
        Ongoing - Each Player;
        Team 1;
        All;
    }
    conditions
    {
        Event Player.p_MirrorModeEnabled == True;
        Event Player.hud_SkyMenuIsOpen == False;
        Event Player.all_ChangingHero == False;
        Players In Slot(Slot Of(Event Player), Team 2).all_ChangingHero == False;
        Hero Of(Event Player) != Hero Of(Players In Slot(Slot Of(Event Player), Team 2));
        Entity Exists(Players In Slot(Slot Of(Event Player), Team 2)) == True;
    }
    actions
    {
        Start Forcing Player To Be Hero(Event Player, Hero Of(Players In Slot(Slot Of(Event Player), Team 2)));
        Wait(1 / 60, Ignore Condition);
        Stop Forcing Player To Be Hero(Event Player);
        Call Subroutine(pSub_SetDistances);
    }
}
rule("Player 1 Second Cooldown Resets")
{
    event
    {
        Ongoing - Each Player;
        Team 1;
        All;
    }
    conditions
    {
        Event Player.p_OneSecCooldown > 0;
        Event Player.hud_SkyMenuIsOpen == False;
        Is Alive(Event Player) == True;
    }
    actions
    {
        Wait(1, Abort When False);
        If(Event Player.p_OneSecCooldown != 2);
            If(Ability Cooldown(Event Player, Button(Primary Fire)) != 0);
                Set Ability Cooldown(Event Player, Button(Primary Fire), 0);
            End;
            If(Ability Cooldown(Event Player, Button(Secondary Fire)) != 0 && Is Using Ability 1(Event Player) == False);
                Set Ability Cooldown(Event Player, Button(Secondary Fire), 0);
            End;
            If(Ability Cooldown(Event Player, Button(Ability 1)) != 0 && Is Using Ability 1(Event Player) == False);
                Set Ability Cooldown(Event Player, Button(Ability 1), 0);
            End;
            If(Ability Cooldown(Event Player, Button(Ability 2)) != 0 && Is Using Ability 2(Event Player) == False);
                Set Ability Cooldown(Event Player, Button(Ability 2), 0);
            End;
            If(Ability Cooldown(Event Player, Button(Crouch)) != 0);
                Set Ability Cooldown(Event Player, Button(Crouch), 0);
            End;
            If(Ultimate Charge Percent(Event Player) < 100 && Is Using Ultimate(Event Player) == False);
                Set Ultimate Charge(Event Player, 100);
            End;
            Set Ammo(Event Player, 0, Max Ammo(Event Player, 0));
            Set Ammo(Event Player, 1, Max Ammo(Event Player, 1));
            Set Ability Charge(Event Player, Button(Ability 1), 3);
            Set Ability Charge(Event Player, Button(Ability 2), 3);
            Set Ability Resource(Event Player, Button(Secondary Fire), 100);
            Set Ability Resource(Event Player, Button(Jump), 100);
        End;
        If(Event Player.p_OneSecCooldown != 1 && Round To Integer(Total Time Elapsed, Down) % 2 == 0);
            If(Ability Cooldown(Players In Slot(Slot Of(Event Player), Team 2), Button(Primary Fire)) != 0);
                Set Ability Cooldown(Players In Slot(Slot Of(Event Player), Team 2), Button(Primary Fire), 0);
            End;
            If(Ability Cooldown(Players In Slot(Slot Of(Event Player), Team 2), Button(Secondary Fire)) != 0 && Is Using Ability 1(
                Players In Slot(Slot Of(Event Player), Team 2)) == False);
                Set Ability Cooldown(Players In Slot(Slot Of(Event Player), Team 2), Button(Secondary Fire), 0);
            End;
            If(Ability Cooldown(Players In Slot(Slot Of(Event Player), Team 2), Button(Ability 1)) != 0 && Is Using Ability 1(Players In Slot(
                Slot Of(Event Player), Team 2)) == False);
                Set Ability Cooldown(Players In Slot(Slot Of(Event Player), Team 2), Button(Ability 1), 0);
            End;
            If(Ability Cooldown(Players In Slot(Slot Of(Event Player), Team 2), Button(Ability 2)) != 0 && Is Using Ability 2(Players In Slot(
                Slot Of(Event Player), Team 2)) == False);
                Set Ability Cooldown(Players In Slot(Slot Of(Event Player), Team 2), Button(Ability 2), 0);
            End;
            If(Ability Cooldown(Players In Slot(Slot Of(Event Player), Team 2), Button(Crouch)) != 0);
                Set Ability Cooldown(Players In Slot(Slot Of(Event Player), Team 2), Button(Crouch), 0);
            End;
            If(Ultimate Charge Percent(Players In Slot(Slot Of(Event Player), Team 2)) < 100 && Is Using Ultimate(Players In Slot(Slot Of(
                Event Player), Team 2)) == False);
                Set Ultimate Charge(Players In Slot(Slot Of(Event Player), Team 2), 100);
            End;
            Set Ammo(Players In Slot(Slot Of(Event Player), Team 2), 0, Max Ammo(Players In Slot(Slot Of(Event Player), Team 2), 0));
            Set Ammo(Players In Slot(Slot Of(Event Player), Team 2), 1, Max Ammo(Players In Slot(Slot Of(Event Player), Team 2), 1));
            Set Ability Charge(Players In Slot(Slot Of(Event Player), Team 2), Button(Ability 1), 3);
            Set Ability Charge(Players In Slot(Slot Of(Event Player), Team 2), Button(Ability 2), 3);
            Set Ability Resource(Players In Slot(Slot Of(Event Player), Team 2), Button(Secondary Fire), 100);
            Set Ability Resource(Players In Slot(Slot Of(Event Player), Team 2), Button(Jump), 100);
        End;
        Loop If Condition Is True;
    }
}
rule("Player Elevator Up")
{
    event
    {
        Ongoing - Each Player;
        Team 1;
        All;
    }
    conditions
    {
        Event Player.p_ElevatorEnabled == True;
        Event Player.p_ElevatorHeight < 32;
        Event Player.p_ElevatorHeight % 2 == 0;
        Vertical Speed Of(Event Player) >= 0;
        Is Alive(Event Player) == True;
        Is Button Held(Event Player, Button(Jump)) == True;
        Is Button Held(Event Player, Button(Crouch)) == False;
    }
    actions
    {
        Event Player.all_SubArg[0] = 1;
        Call Subroutine(pSub_Elevator);
        Loop If Condition Is True;
    }
}
rule("Player Elevator Down")
{
    event
    {
        Ongoing - Each Player;
        Team 1;
        All;
    }
    conditions
    {
        Event Player.p_ElevatorEnabled == True;
        Event Player.p_ElevatorHeight > 0;
        Event Player.p_ElevatorHeight % 2 == 0;
        Vertical Speed Of(Event Player) <= 0;
        Is Alive(Event Player) == True;
        Is Button Held(Event Player, Button(Crouch)) == True;
        Is Button Held(Event Player, Button(Jump)) == False;
        Is Button Held(Event Player, Button(Reload)) == False;
    }
    actions
    {
        Event Player.all_SubArg[0] = 2;
        Call Subroutine(pSub_Elevator);
        Loop If Condition Is True;
    }
}
rule("Player Elevator Movement Start")
{
    event
    {
        Ongoing - Each Player;
        Team 1;
        All;
    }
    conditions
    {
        Players In Slot(Slot Of(Event Player), Team 1).p_ElevatorEnabled == True;
        Is Alive(Event Player) == True;
        Throttle Of(Event Player) != Vector(0, 0, 0);
    }
    actions
    {
        Stop Accelerating(Event Player);
        Start Accelerating(Event Player, Throttle Of(Event Player), 100, Speed Of(Event Player), To Player, Direction Rate and Max Speed);
    }
}
rule("Player Elevator Movement Stop")
{
    event
    {
        Ongoing - Each Player;
        Team 1;
        All;
    }
    conditions
    {
        Players In Slot(Slot Of(Event Player), Team 1).p_ElevatorEnabled == True;
        Is Alive(Event Player) == True;
        Throttle Of(Event Player) == Vector(0, 0, 0);
        Speed Of(Event Player) > 0;
    }
    actions
    {
        Stop Accelerating(Event Player);
        Event Player.p_ElevatorPosition = Empty Array;
        Event Player.p_ElevatorPosition[0] = Position Of(Event Player);
        Wait(0.100, Ignore Condition);
        Event Player.p_ElevatorPosition[1] = Position Of(Event Player);
        Apply Impulse(Event Player, Direction Towards(Event Player.p_ElevatorPosition[1], Event Player.p_ElevatorPosition[0]),
            Speed Of In Direction(Event Player, Direction Towards(Event Player.p_ElevatorPosition[0], Event Player.p_ElevatorPosition[1])),
            To World, Incorporate Contrary Motion);
    }
}
rule("botSub_ResetBot")
{
    event
    {
        Subroutine;
        botSub_ResetBot;
    }
    actions
    {
        Players In Slot(Slot Of(Event Player), Team 2).bot_BotResetComplete = False;
        "Disable AI Mode"
        If(Players In Slot(Slot Of(Event Player), Team 2).ai_AIEnabled == True && Global.g_DebugMode == False);
            Players In Slot(Slot Of(Event Player), Team 2).ai_AIEnabled = False;
            Players In Slot(Slot Of(Event Player), Team 2).bot_MoveWASDEnabled = False;
            Players In Slot(Slot Of(Event Player), Team 2).bot_MoveCrouchEnabled = False;
            Players In Slot(Slot Of(Event Player), Team 2).bot_MoveJumpEnabled = False;
            Players In Slot(Slot Of(Event Player), Team 2).ai_IsInAbilitySub = False;
            Players In Slot(Slot Of(Event Player), Team 2).ai_HeroInitialized = False;
            Players In Slot(Slot Of(Event Player), Team 2).ai_StrafeDistanceMod = 5;
        End;
        "Cancel Current Abilities and Disable Buttons"
        Cancel Primary Action(Players In Slot(Slot Of(Event Player), Team 2));
        Call Subroutine(aiSub_ButtonsReset);
        "Stop facing and throttle"
        Call Subroutine(botSub_ThrottleStop);
        Stop Facing(Players In Slot(Slot Of(Event Player), Team 2));
        "Force to be current hero or create dummy bot"
        Call Subroutine(allSub_WaitForFrame);
        If(Hero Of(Players In Slot(Slot Of(Event Player), Team 2)) != Players In Slot(Slot Of(Event Player), Team 1)
            .p_HeroList[Players In Slot(Slot Of(Event Player), Team 1).p_BotHeroNumber]);
            If(Entity Exists(Players In Slot(Slot Of(Event Player), Team 2)));
                Call Subroutine(allSub_WaitForFrame);
                Destroy Dummy Bot(Team 2, Slot Of(Event Player));
                Wait Until(Entity Exists(Players In Slot(Slot Of(Event Player), Team 2)) == False, 5);
            End;
            Call Subroutine(allSub_WaitForFrame);
            Create Dummy Bot(Players In Slot(Slot Of(Event Player), Team 1).p_HeroList[Players In Slot(Slot Of(Event Player), Team 1)
                .p_BotHeroNumber], Team 2, Slot Of(Event Player), Vector(0, 0, 0), Vector(0, 0, 0));
            Wait Until(Entity Exists(Players In Slot(Slot Of(Event Player), Team 2)), 5);
            "If Mirror Mode is on use the Player's name"
            If(Players In Slot(Slot Of(Event Player), Team 1).p_MirrorModeEnabled == True);
                Start Forcing Dummy Bot Name(Players In Slot(Slot Of(Event Player), Team 2), Custom String("{0}", Players In Slot(Slot Of(Event Player), Team 1)));
            "Give the bot a silly name. For Fun."
            Else If(Global.g_UseBotNames == True);
                If(Count Of(Global.g_BotNames) - Count Of(Mapped Array(All Players(Team 1), Custom String("{0}", Current Array Element))) <= 0);
                    Global.g_BotNames = Append To Array(Global.c_BotNamesConst, Global.g_PlayerNames);
                End;
                Players In Slot(Slot Of(Event Player), Team 2).bot_Name = Random Value In Array(
                    Remove From Array(
                        Global.g_BotNames,
                        Mapped Array(All Players(Team 1), Custom String("{0}", Current Array Element))
                    )
                );
                Modify Global Variable(g_BotNames, Remove From Array By Value, Players In Slot(Slot Of(Event Player), Team 2).bot_Name);
                Stop Forcing Dummy Bot Name(Players In Slot(Slot Of(Event Player), Team 2));
                Start Forcing Dummy Bot Name(Players In Slot(Slot Of(Event Player), Team 2), Players In Slot(Slot Of(Event Player), Team 2).bot_Name);
            End;
            Call Subroutine(pSub_SetDifficulty);
            Disable Built-In Game Mode Respawning(Players In Slot(Slot Of(Event Player), Team 2));
            Call Subroutine(allSub_WaitForFrame);
            Set Invisible(Players In Slot(Slot Of(Event Player), Team 2), All);
            "Wait a frame after changing hero or creating bot"
            Call Subroutine(allSub_WaitForFrame);
            Small Message(Players In Slot(Slot Of(Event Player), Team 1), Custom String("{0}  {1}!", Hero Icon String(Hero Of(Players In Slot(
                Slot Of(Event Player), Team 2))), Hero Of(Players In Slot(Slot Of(Event Player), Team 2))));
        End;
        "Set Unkillable"
        Call Subroutine(allSub_WaitForFrame);
        If(Players In Slot(Slot Of(Event Player), Team 1).p_Difficulty >= 3 && (
            Global.g_DebugHero[0] == False && Global.g_DebugMode == False) == True);
            Set Status(Players In Slot(Slot Of(Event Player), Team 2), Null, Unkillable, 9999);
        End;
        If(Players In Slot(Slot Of(Event Player), Team 1).p_Difficulty >= 3);
            Players In Slot(Slot Of(Event Player), Team 2).ai_StrafeDistanceMod = 5;
            If(Global.g_DebugHero[0] == True || Global.g_DebugMode == True);
                Call Subroutine(aiSub_EnableAI);
            End;
        End;
        Players In Slot(Slot Of(Event Player), Team 2).bot_BotResetComplete = True;
    }
}
rule("botSub_SetHero")
{
    event
    {
        Subroutine;
        botSub_SetHero;
    }
    actions
    {
        If(Health(Players In Slot(Slot Of(Event Player), Team 1)) != Max Health(Players In Slot(Slot Of(Event Player), Team 1)));
            Heal(Players In Slot(Slot Of(Event Player), Team 1), Null, Max Health(Players In Slot(Slot Of(Event Player), Team 1)));
        End;
        Players In Slot(Slot Of(Event Player), Team 1).all_Kills = 0;
        Players In Slot(Slot Of(Event Player), Team 2).all_Kills = 0;
        If(Players In Slot(Slot Of(Event Player), Team 1).p_HeroNumberMod == 1);
            If(Players In Slot(Slot Of(Event Player), Team 1).p_BotHeroNumber == Count Of(Event Player.p_HeroList) - 1);
                Players In Slot(Slot Of(Event Player), Team 1).p_BotHeroNumber = 0;
            Else;
                Players In Slot(Slot Of(Event Player), Team 1).p_BotHeroNumber = Players In Slot(Slot Of(Event Player), Team 1)
                    .p_BotHeroNumberNext;
            End;
        Else If(Players In Slot(Slot Of(Event Player), Team 1).p_HeroNumberMod == -1);
            If(Players In Slot(Slot Of(Event Player), Team 1).p_BotHeroNumber == 0);
                Players In Slot(Slot Of(Event Player), Team 1).p_BotHeroNumber = Count Of(Players In Slot(Slot Of(Event Player), Team 1)
                    .p_HeroList) - 1;
            Else;
                Players In Slot(Slot Of(Event Player), Team 1).p_BotHeroNumber -= 1;
            End;
        Else;
        End;
        If(Players In Slot(Slot Of(Event Player), Team 1).p_BotHeroNumber == Count Of(Players In Slot(Slot Of(Event Player), Team 1)
            .p_HeroList) - 1);
            Players In Slot(Slot Of(Event Player), Team 1).p_BotHeroNumberNext = 0;
        Else;
            Players In Slot(Slot Of(Event Player), Team 1).p_BotHeroNumberNext = Players In Slot(Slot Of(Event Player), Team 1)
                .p_BotHeroNumber + 1;
        End;
        Players In Slot(Slot Of(Event Player), Team 1).p_HeroNumberMod = 0;
        Call Subroutine(botSub_ResetBot);
        Call Subroutine(botSub_TeleportBot);
    }
}
rule("botSub_TeleportBot")
{
    event
    {
        Subroutine;
        botSub_TeleportBot;
    }
    actions
    {
        Stop Forcing Player Position(Players In Slot(Slot Of(Event Player), Team 2));
        Call Subroutine(allSub_WaitForFrame);
        Set Invisible(Players In Slot(Slot Of(Event Player), Team 2), All);
        Call Subroutine(allSub_WaitForFrame);
        Set Facing(Players In Slot(Slot Of(Event Player), Team 2), Vector(Random Real(-1, 1), Random Real(-0.500, 0.500), Random Real(-1,
            1)), To Player);
        Call Subroutine(allSub_WaitForFrame);
        Players In Slot(Slot Of(Event Player), Team 1).p_EnemyDistanceMod = Players In Slot(Slot Of(Event Player), Team 1)
            .p_EnemyDistanceMax / Players In Slot(Slot Of(Event Player), Team 1).p_KillGoal * 2;
        Call Subroutine(allSub_WaitForFrame);
        If(Players In Slot(Slot Of(Event Player), Team 1).p_KillGoal != 1 && Players In Slot(Slot Of(Event Player), Team 1)
            .p_KillGoal != Global.c_PseudoInfinity);
            Players In Slot(Slot Of(Event Player), Team 1).p_BotTPDistance = Empty Array;
            Players In Slot(Slot Of(Event Player), Team 1).p_BotTPDistance[0] = (Players In Slot(Slot Of(Event Player), Team 1)
                .p_KillGoal - 1 - Players In Slot(Slot Of(Event Player), Team 1).all_Kills) % (Players In Slot(Slot Of(Event Player), Team 1)
                .p_KillGoal / 2) * Players In Slot(Slot Of(Event Player), Team 1).p_EnemyDistanceMod;
            Players In Slot(Slot Of(Event Player), Team 1).p_BotTPDistance[1] = Players In Slot(Slot Of(Event Player), Team 1)
                .p_BotTPDistance[0] + Players In Slot(Slot Of(Event Player), Team 1).p_EnemyDistanceMod;
            If(Players In Slot(Slot Of(Event Player), Team 1).all_Kills == 0 || Players In Slot(Slot Of(Event Player), Team 1)
                .all_Kills == Players In Slot(Slot Of(Event Player), Team 1).p_KillGoal / 2);
                Players In Slot(Slot Of(Event Player), Team 1).p_BotTPDistance[1] = Players In Slot(Slot Of(Event Player), Team 1)
                    .p_BotTPDistance[1] - 2.500;
            End;
            Call Subroutine(allSub_WaitForFrame);
            Teleport(Players In Slot(Slot Of(Event Player), Team 2), Direction From Angles(Random Integer(1, 360), 0) * Random Integer(
                Players In Slot(Slot Of(Event Player), Team 1).p_BotTPDistance[0], Players In Slot(Slot Of(Event Player), Team 1)
                .p_BotTPDistance[1]) + Players In Slot(Slot Of(Event Player), Team 1).p_HomeVector);
        Else;
            Call Subroutine(allSub_WaitForFrame);
            Teleport(Players In Slot(Slot Of(Event Player), Team 2), Direction From Angles(Random Integer(1, 360), 0) * Random Real(0,
                Players In Slot(Slot Of(Event Player), Team 1).p_EnemyDistanceMax) + Players In Slot(Slot Of(Event Player), Team 1)
                .p_HomeVector);
        End;
        Call Subroutine(allSub_WaitForFrame);
        Play Effect(Players In Slot(Slot Of(Event Player), Team 1), Buff Impact Sound, Color(White), Players In Slot(Slot Of(Event Player),
            Team 2), 180);
        Call Subroutine(allSub_WaitForFrame);
        Play Effect(Players In Slot(Slot Of(Event Player), Team 1), Bad Pickup Effect, Color(White), Players In Slot(Slot Of(Event Player),
            Team 2), 1);
        Call Subroutine(allSub_WaitForFrame);
        Set Invisible(Players In Slot(Slot Of(Event Player), Team 2), None);
    }
}
rule("botSub_MoveWASD")
{
    event
    {
        Subroutine;
        botSub_MoveWASD;
    }
    actions
    {
        Start Throttle In Direction(Players In Slot(Slot Of(Event Player), Team 2), Players In Slot(Slot Of(Event Player), Team 2)
            .bot_ThrottleDir, 1, To Player, Replace existing throttle, None);
        Wait(Random Real(Players In Slot(Slot Of(Event Player), Team 2).bot_MoveWASDTimeMod / Players In Slot(Slot Of(Event Player),
            Team 1).p_Difficulty, Players In Slot(Slot Of(Event Player), Team 2).bot_MoveWASDTimeMod), Ignore Condition);
    }
}
rule("botSub_MoveCrouch")
{
    event
    {
        Subroutine;
        botSub_MoveCrouch;
    }
    actions
    {
        Call Subroutine(aiSub_ReactionDelay);
        If(Random Real(0, 1) < Players In Slot(Slot Of(Event Player), Team 2).bot_MoveCrouchChanceMod);
            Stop Holding Button(Players In Slot(Slot Of(Event Player), Team 2), Button(Crouch));
            Start Holding Button(Players In Slot(Slot Of(Event Player), Team 2), Button(Crouch));
            Wait(Random Real(Players In Slot(Slot Of(Event Player), Team 2).bot_MoveCrouchTimeMod / 5, Players In Slot(Slot Of(Event Player),
                Team 2).bot_MoveCrouchTimeMod), Ignore Condition);
        End;
        Stop Holding Button(Players In Slot(Slot Of(Event Player), Team 2), Button(Crouch));
    }
}
rule("botSub_MoveJump")
{
    event
    {
        Subroutine;
        botSub_MoveJump;
    }
    actions
    {
        If(Hero Of(Players In Slot(Slot Of(Event Player), Team 2)) == Hero(Genji));
            If(Random Real(0, 1) < Players In Slot(Slot Of(Event Player), Team 2).bot_MoveJumpChanceMod * 2.500);
                Press Button(Players In Slot(Slot Of(Event Player), Team 2), Button(Jump));
            End;
        Else;
            If(Random Real(0, 1) < Players In Slot(Slot Of(Event Player), Team 2).bot_MoveJumpChanceMod);
                Press Button(Players In Slot(Slot Of(Event Player), Team 2), Button(Jump));
            End;
        End;
        Wait(Random Real(Players In Slot(Slot Of(Event Player), Team 2).bot_MoveJumpTimeMod / 5, Players In Slot(Slot Of(Event Player),
            Team 2).bot_MoveJumpTimeMod), Ignore Condition);
    }
}
rule("botSub_ThrottleStop")
{
    event
    {
        Subroutine;
        botSub_ThrottleStop;
    }
    actions
    {
        "Wait 4 frames before"
        Wait(4 / 60, Ignore Condition);
        Stop Throttle In Direction(Players In Slot(Slot Of(Event Player), Team 2));
    }
}
rule("Bot Init")
{
    event
    {
        Ongoing - Each Player;
        Team 1;
        All;
    }
    conditions
    {
        Event Player.p_PlayerInitialized == True;
    }
    actions
    {
        Wait(0.100, Ignore Condition);
        Call Subroutine(botSub_SetHero);
        "Setup difficulty"
        Call Subroutine(pSub_SetDifficulty);
        Players In Slot(Slot Of(Event Player), Team 2).all_HealingEnabled = Global.g_BotHealing;
        "Face enemy bot after it is created"
        Stop Facing(Event Player);
        Start Facing(Event Player, Direction Towards(Eye Position(Event Player), Eye Position(Players In Slot(Slot Of(Event Player),
            Team 2))), Angle Between Vectors(Facing Direction Of(Event Player), Direction Towards(Eye Position(Event Player), Eye Position(
            Players In Slot(Slot Of(Event Player), Team 2)))) * 10, To World, None);
        Wait(12 / 60, Ignore Condition);
        Stop Facing(Event Player);
    }
}
rule("Player Leave Destroy All Objects")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        All;
    }
    conditions
    {
        Entity Exists(Players In Slot(Slot Of(Event Player), Team 1)) == False;
        Is In Spawn Room(Players In Slot(Slot Of(Event Player), Team 1)) == False;
        Has Spawned(Players In Slot(Slot Of(Event Player), Team 1)) == False;
    }
    actions
    {
        If(Count Of(Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenu) > 0);
            Call Subroutine(hudSub_SkyMenuToggle);
        End;
        If(Count Of(Players In Slot(Slot Of(Event Player), Team 1).hud_Debug) > 0);
            Call Subroutine(hudSub_DebugToggle);
        End;
        If(Count Of(Players In Slot(Slot Of(Event Player), Team 1).hud_Info) > 0);
            Call Subroutine(hudSub_InfoToggle);
        End;
        If(Count Of(Players In Slot(Slot Of(Event Player), Team 1).hud_Main) > 0);
            Call Subroutine(hudSub_MainToggle);
        End;
        If(Count Of(Players In Slot(Slot Of(Event Player), Team 1).p_Effects) > 0);
            For Player Variable(Players In Slot(Slot Of(Event Player), Team 1), all_Index, Count Of(Players In Slot(Slot Of(Event Player), Team 1)
                .p_Effects), -1, -1);
                Destroy Effect(Players In Slot(Slot Of(Event Player), Team 1).p_Effects[Players In Slot(Slot Of(Event Player), Team 1).all_Index]);
                Players In Slot(Slot Of(Event Player), Team 1).p_Effects = Remove From Array(Players In Slot(Slot Of(Event Player), Team 1)
                    .p_Effects, Players In Slot(Slot Of(Event Player), Team 1).p_Effects[Players In Slot(Slot Of(Event Player), Team 1).all_Index]);
            End;
        End;
        Destroy Dummy Bot(Team 2, Slot Of(Event Player));
    }
}
rule("Bot Respawn")
{
    event
    {
        Player Died;
        Team 2;
        All;
    }
    conditions
    {
        Players In Slot(Slot Of(Event Player), Team 1).all_Kills < Players In Slot(Slot Of(Event Player), Team 1).p_KillGoal;
    }
    actions
    {
        Wait(0.250, Abort When False);
        Call Subroutine(aiSub_ButtonsReset);
        Event Player.ai_HeroInitialized = False;
        Event Player.ai_IsInAbilitySub = False;
        Stop Heal Over Time(Event Player.all_InspireHealID);
        Stop Facing(Event Player);
        Call Subroutine(allSub_WaitForFrame);
        Respawn(Event Player);
        Call Subroutine(botSub_TeleportBot);
    }
}
rule("Bot Elimination")
{
    event
    {
        Player Dealt Final Blow;
        Team 2;
        All;
    }
    conditions
    {
        Is Game In Progress == True;
    }
    actions
    {
        Event Player.all_Kills += 1;
        If(Players In Slot(Slot Of(Event Player), Team 1).p_MinusKillOnDeath == True && Players In Slot(Slot Of(Event Player), Team 1)
            .all_Kills > 0);
            Players In Slot(Slot Of(Event Player), Team 1).all_Kills -= 1;
        End;
        "Bad Manners"
        If(Random Real(0, 1) < 0.600);
            Event Player.ai_BMVoiceLine = Random Integer(1, 4);
            Wait(Random Real(0.650, 1.150), Ignore Condition);
            If(Event Player.ai_BMVoiceLine == 1);
                Communicate(Event Player, Hello);
            Else If(Event Player.ai_BMVoiceLine == 2);
                Communicate(Event Player, Thanks);
            Else If(Event Player.ai_BMVoiceLine == 3);
                Communicate(Event Player, Sorry);
            Else If(Event Player.ai_BMVoiceLine == 4);
                Communicate(Event Player, Goodbye);
            End;
        End;
        Call Subroutine(aiSub_ReactionDelay);
        Call Subroutine(aiSub_ButtonsReset);
    }
}
rule("Bot Reset Position Non AI Difficulty")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        All;
    }
    conditions
    {
        Is Game In Progress == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1).p_HomeVector) >= Players In Slot(Slot Of(
            Event Player), Team 1).p_EnemyDistanceMax - 1;
        Players In Slot(Slot Of(Event Player), Team 1).p_Difficulty < 3;
    }
    actions
    {
        "Flip 180"
        Stop Facing(Event Player);
        Start Facing(Event Player, Direction Towards(Eye Position(Event Player), Eye Position(Event Player) + World Vector Of(Vector(0, 0,
            -5), Event Player, Rotation)), Random Integer(300, 500), To Player, None);
    }
}
rule("Bot Reset Position Out Of Bounds")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        All;
    }
    conditions
    {
        Is Game In Progress == True;
        Has Spawned(Event Player) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1).p_HomeVector) > Players In Slot(Slot Of(
            Event Player), Team 1).p_EnemyDistanceMax + 15;
    }
    actions
    {
        Wait(0.750, Abort When False);
        Call Subroutine(botSub_TeleportBot);
    }
}
rule("Bot Hello")
{
    event
    {
        Ongoing - Each Player;
        Team 1;
        All;
    }
    conditions
    {
        Is Game In Progress == True;
        Is Communicating(Event Player, Hello) == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 2)) == True;
    }
    actions
    {
        Wait(Random Real(1, 1.250), Ignore Condition);
        Communicate(Players In Slot(Slot Of(Event Player), Team 2), Hello);
    }
}
rule("Bot You Are Welcome")
{
    event
    {
        Ongoing - Each Player;
        Team 1;
        All;
    }
    conditions
    {
        Is Game In Progress == True;
        Is Communicating(Event Player, Thanks) == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 2)) == True;
    }
    actions
    {
        Wait(Random Real(1, 1.250), Ignore Condition);
        Communicate(Players In Slot(Slot Of(Event Player), Team 2), You are Welcome);
    }
}
rule("Bot Asleep Thanks")
{
    event
    {
        Ongoing - Each Player;
        Team 1;
        Ana;
    }
    conditions
    {
        Is Alive(Players In Slot(Slot Of(Event Player), Team 2)) == True;
        Has Status(Players In Slot(Slot Of(Event Player), Team 2), Asleep) == True;
    }
    actions
    {
        If(Random Real(0, 1) < 0.750);
            Wait(Random Real(0.750, 1), Ignore Condition);
            Communicate(Players In Slot(Slot Of(Event Player), Team 2), Thanks);
        End;
    }
}
rule("Hard Mode WASD")
{
    event
    {
        Ongoing - Each Player;
        Team 1;
        All;
    }
    conditions
    {
        Event Player.p_Difficulty == 2;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 2)) == True;
        Players In Slot(Slot Of(Event Player), Team 2).bot_BotResetComplete == True;
    }
    actions
    {
        Players In Slot(Slot Of(Event Player), Team 2).bot_ThrottleDir = Random Value In Array(Global.c_MoveDir_All);
        Start Rule(botSub_MoveWASD, Do Nothing);
        Start Rule(botSub_MoveCrouch, Do Nothing);
        Start Rule(botSub_MoveJump, Do Nothing);
        Wait(0.250, Ignore Condition);
        Loop If Condition Is True;
        Stop Throttle In Direction(Players In Slot(Slot Of(Event Player), Team 2));
        Stop Holding Button(Players In Slot(Slot Of(Event Player), Team 2), Button(Crouch));
        Stop Holding Button(Players In Slot(Slot Of(Event Player), Team 2), Button(Jump));
    }
}
rule("Medium Mode WASD")
{
    event
    {
        Ongoing - Each Player;
        Team 1;
        All;
    }
    conditions
    {
        Event Player.p_Difficulty == 1;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 2)) == True;
        (Event Player.all_Kills >= Event Player.p_KillGoal / 2 || (
            Event Player.p_KillGoal == Global.c_PseudoInfinity && Event Player.all_Kills % 2 == 1)) == True;
        Players In Slot(Slot Of(Event Player), Team 2).bot_BotResetComplete == True;
    }
    actions
    {
        Players In Slot(Slot Of(Event Player), Team 2).bot_ThrottleDir = Random Value In Array(Global.c_MoveDir_Forward);
        Start Rule(botSub_MoveWASD, Do Nothing);
        Start Rule(botSub_MoveCrouch, Do Nothing);
        Start Rule(botSub_MoveJump, Do Nothing);
        Wait(0.250, Ignore Condition);
        Loop If Condition Is True;
        Stop Throttle In Direction(Players In Slot(Slot Of(Event Player), Team 2));
        Stop Holding Button(Players In Slot(Slot Of(Event Player), Team 2), Button(Crouch));
        Stop Holding Button(Players In Slot(Slot Of(Event Player), Team 2), Button(Jump));
    }
}
rule("Easy Mode WASD")
{
    event
    {
        Ongoing - Each Player;
        Team 1;
        All;
    }
    conditions
    {
        Event Player.p_Difficulty == 0;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 2)) == True;
        (Event Player.all_Kills >= Event Player.p_KillGoal / 2 || (
            Event Player.p_KillGoal == Global.c_PseudoInfinity && Event Player.all_Kills % 2 == 1)) == True;
        Players In Slot(Slot Of(Event Player), Team 2).bot_BotResetComplete == True;
    }
    actions
    {
        Start Throttle In Direction(Players In Slot(Slot Of(Event Player), Team 2), Forward, 1, To Player, Replace existing throttle,
            Direction and Magnitude);
        Wait(1, Ignore Condition);
        Loop If Condition Is True;
        Stop Throttle In Direction(Players In Slot(Slot Of(Event Player), Team 2));
    }
}
rule("Non AI Scope Hero Scope In")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        All;
    }
    conditions
    {
        Is Alive(Event Player) == True;
        Players In Slot(Slot Of(Event Player), Team 1).p_Difficulty < 3;
        Array Contains(Global.c_ScopeHeroes, Hero Of(Event Player)) == True;
        Event Player.bot_BotResetComplete == True;
    }
    actions
    {
        If(Players In Slot(Slot Of(Event Player), Team 1).p_Difficulty < 2 && Players In Slot(Slot Of(Event Player), Team 1)
            .p_KillGoal == Global.c_PseudoInfinity);
            If(Players In Slot(Slot Of(Event Player), Team 1).all_Kills % 4 == 0 || (Players In Slot(Slot Of(Event Player), Team 1)
                .all_Kills - 1) % 4 == 0);
                Stop Holding Button(Event Player, Button(Secondary Fire));
                Wait(3 / 60, Ignore Condition);
                Start Holding Button(Event Player, Button(Secondary Fire));
                Event Player.bot_MoveJumpEnabled = False;
            Else;
                Skip If(Is Button Held(Event Player, Button(Secondary Fire)) == False, 1);
                Stop Holding Button(Event Player, Button(Secondary Fire));
                Event Player.bot_MoveJumpEnabled = True;
            End;
        Else;
            If(Players In Slot(Slot Of(Event Player), Team 1).all_Kills % 2 == 0);
                Stop Holding Button(Event Player, Button(Secondary Fire));
                Wait(3 / 60, Ignore Condition);
                Start Holding Button(Event Player, Button(Secondary Fire));
                Event Player.bot_MoveJumpEnabled = False;
            Else;
                Skip If(Is Button Held(Event Player, Button(Secondary Fire)) == False, 1);
                Stop Holding Button(Event Player, Button(Secondary Fire));
                Event Player.bot_MoveJumpEnabled = True;
            End;
        End;
    }
}
rule("Bot Flicker")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        All;
    }
    conditions
    {
        Is Alive(Event Player) == True;
        Event Player.bot_FlickerEnabled == True;
        Event Player.bot_BotResetComplete == True;
    }
    actions
    {
        Cancel Primary Action(Event Player);
        Set Invisible(Event Player, All);
        Event Player.ai_CanAim = False;
        Event Player.ai_CanAttack = False;
        Event Player.ai_CanUseAbilities = False;
        Set Status(Event Player, Null, Phased Out, 9999);
        Wait(Random Real(0.300, 3), Ignore Condition);
        Set Invisible(Event Player, None);
        Event Player.ai_CanAim = True;
        Event Player.ai_CanAttack = True;
        Event Player.ai_CanUseAbilities = True;
        Clear Status(Event Player, Phased Out);
        Wait(Random Real(0.250, 2.500), Ignore Condition);
        Loop If Condition Is True;
    }
}
rule("allSub_WaitForFrame")
{
    event
    {
        Subroutine;
        allSub_WaitForFrame;
    }
    actions
    {
        Wait Until(((Slot Of(Event Player) % 2 == 0 && Global.g_Tick % 2 == 0) || (Slot Of(Event Player)
            % 2 != 0 && Global.g_Tick % 2 != 0)) == True, 2 / 60);
        Wait(0.500 / 60, Ignore Condition);
    }
}
rule("allSub_ButtonsDisallow")
{
    event
    {
        Subroutine;
        allSub_ButtonsDisallow;
    }
    actions
    {
        Disallow Button(Event Player, Button(Primary Fire));
        Disallow Button(Event Player, Button(Secondary Fire));
        Disallow Button(Event Player, Button(Ability 1));
        Disallow Button(Event Player, Button(Ability 2));
        Disallow Button(Event Player, Button(Ultimate));
        Disallow Button(Event Player, Button(Jump));
        Disallow Button(Event Player, Button(Crouch));
        Disallow Button(Event Player, Button(Melee));
        Disallow Button(Event Player, Button(Reload));
    }
}
rule("allSub_ButtonsAllow")
{
    event
    {
        Subroutine;
        allSub_ButtonsAllow;
    }
    actions
    {
        Allow Button(Event Player, Button(Primary Fire));
        Allow Button(Event Player, Button(Secondary Fire));
        Allow Button(Event Player, Button(Ability 1));
        Allow Button(Event Player, Button(Ability 2));
        Allow Button(Event Player, Button(Ultimate));
        Allow Button(Event Player, Button(Jump));
        Allow Button(Event Player, Button(Crouch));
        Allow Button(Event Player, Button(Melee));
        Allow Button(Event Player, Button(Reload));
    }
}
rule("Player/Bot Elimination Heal")
{
    event
    {
        Player Dealt Final Blow;
        All;
        All;
    }
    conditions
    {
        Is Alive(Event Player) == True;
        Health(Event Player) != Max Health(Event Player);
        Event Player.all_HealingEnabled == True;
    }
    actions
    {
        Wait(6 / 60, Ignore Condition);
        Start Heal Over Time(Event Player, Null, 2, 55);
    }
}
rule("Player/Bot Inspire Heal")
{
    event
    {
        Player Dealt Damage;
        All;
        All;
    }
    conditions
    {
        Is Game In Progress == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Opposite Team Of(Team Of(Event Player)))) == True;
        Event Player.all_HealingEnabled == True;
        Total Time Elapsed >= Event Player.all_InspireHealTime + 1;
        Event Damage > 5;
    }
    actions
    {
        "Essentially Brigitte's Inspire"
        If(Event Player.all_InspireHealID != 0);
            Stop Heal Over Time(Event Player.all_InspireHealID);
        End;
        Start Heal Over Time(Event Player, Null, 6, 15);
        Event Player.all_InspireHealID = Last Heal Over Time ID;
        Event Player.all_InspireHealTime = Total Time Elapsed;
    }
}
rule("Special Rule: Doomfist Rocket Punch Start")
{
    event
    {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions
    {
        Is Firing Secondary(Event Player) == True;
        Is Alive(Event Player) == True;
    }
    actions
    {
        Event Player.ai_DoomfistPunchTime = Total Time Elapsed;
        Event Player.ai_DoomfistPunchDamage = 0;
    }
}
rule("Special Rule: Doomfist Rocket Punch")
{
    event
    {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions
    {
        Is Firing Secondary(Event Player) == False;
        Is Alive(Event Player) == True;
        Event Player.ai_DoomfistPunchTime != 0;
    }
    actions
    {
        Event Player.ai_DoomfistPunchDamage = (Total Time Elapsed - Event Player.ai_DoomfistPunchTime) / 1.400 * 100.750 + 49.250;
        If(Event Player.ai_DoomfistPunchDamage > 150);
            Event Player.ai_DoomfistPunchDamage = 150;
        End;
    }
}
rule("Special Rule: Doomfist Rocket Punch Damage")
{
    event
    {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions
    {
        Has Status(Players In Slot(Slot Of(Event Player), Opposite Team Of(Team Of(Event Player))), Stunned) == True;
        Distance Between(Players In Slot(Slot Of(Event Player), Opposite Team Of(Team Of(Event Player))), Players In Slot(Slot Of(
            Event Player), Team 1).p_HomeVector) >= Players In Slot(Slot Of(Event Player), Team 1).p_ZoneRadius - 2.500;
    }
    actions
    {
        Apply Impulse(Players In Slot(Slot Of(Event Player), Opposite Team Of(Team Of(Event Player))), Direction Towards(Players In Slot(
            Slot Of(Event Player), Opposite Team Of(Team Of(Event Player))), Event Player), 1, To World, Cancel Contrary Motion);
        Damage(Players In Slot(Slot Of(Event Player), Opposite Team Of(Team Of(Event Player))), Event Player,
            Event Player.ai_DoomfistPunchDamage);
        Event Player.ai_DoomfistPunchTime = 0;
        Event Player.ai_DoomfistPunchDamage = 0;
    }
}
rule("Special Rule: Doomfist Rocket Punch Damage")
{
    event
    {
        Ongoing - Each Player;
        All;
        Doomfist;
    }
    conditions
    {
        Has Status(Players In Slot(Slot Of(Event Player), Opposite Team Of(Team Of(Event Player))), Stunned) == True;
        Distance Between(Players In Slot(Slot Of(Event Player), Opposite Team Of(Team Of(Event Player))), Players In Slot(Slot Of(
            Event Player), Team 1).p_HomeVector) >= Players In Slot(Slot Of(Event Player), Team 1).p_ZoneRadius - 1;
    }
    actions
    {
        Apply Impulse(Players In Slot(Slot Of(Event Player), Opposite Team Of(Team Of(Event Player))), Direction Towards(Players In Slot(
            Slot Of(Event Player), Opposite Team Of(Team Of(Event Player))), Event Player), 1, To World, Cancel Contrary Motion);
        Damage(Players In Slot(Slot Of(Event Player), Opposite Team Of(Team Of(Event Player))), Event Player,
            Event Player.ai_DoomfistPunchDamage);
        Event Player.ai_DoomfistPunchTime = 0;
        Event Player.ai_DoomfistPunchDamage = 0;
    }
}
rule("Special Rule: Reinhardt Charge")
{
    event
    {
        Ongoing - Each Player;
        All;
        Reinhardt;
    }
    conditions
    {
        Is Alive(Event Player) == True;
        Is Using Ability 1(Event Player) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1).p_HomeVector) >= Players In Slot(Slot Of(
            Event Player), Team 1).p_ZoneRadius - 2.500;
        Distance Between(Position Of(Event Player) + World Vector Of(Vector(0, 0, 4), Event Player, Rotation), Players In Slot(Slot Of(
            Event Player), Team 1).p_HomeVector) >= Players In Slot(Slot Of(Event Player), Team 1).p_ZoneRadius - 1.250;
    }
    actions
    {
        Stop Facing(Players In Slot(Slot Of(Event Player), Team 2));
        Set Status(Event Player, Null, Stunned, 0.650);
        Start Forcing Player Position(Event Player, Position Of(Event Player), False);
        If(Has Status(Players In Slot(Slot Of(Event Player), Opposite Team Of(Team Of(Event Player))), Stunned) && Distance Between(
            Event Player, Players In Slot(Slot Of(Event Player), Opposite Team Of(Team Of(Event Player)))) < 2);
            Start Forcing Player Position(Players In Slot(Slot Of(Event Player), Opposite Team Of(Team Of(Event Player))), Position Of(
                Players In Slot(Slot Of(Event Player), Opposite Team Of(Team Of(Event Player)))), False);
            Damage(Players In Slot(Slot Of(Event Player), Opposite Team Of(Team Of(Event Player))), Event Player, 300);
        End;
        Wait(0.650, Ignore Condition);
        Stop Forcing Player Position(Event Player);
        Stop Forcing Player Position(Players In Slot(Slot Of(Event Player), Opposite Team Of(Team Of(Event Player))));
        Call Subroutine(aiSub_FacingReset);
        If(Event Player == Players In Slot(Slot Of(Event Player), Team 2));
            Event Player.bot_MoveJumpEnabled = True;
        End;
    }
}
rule("Special Rule: Player Ana Self Nano Boost")
{
    event
    {
        Ongoing - Each Player;
        Team 1;
        Ana;
    }
    conditions
    {
        Is Alive(Event Player) == True;
        Ultimate Charge Percent(Event Player) == 100;
        Is Button Held(Event Player, Button(Ultimate)) == True;
    }
    actions
    {
        Set Ultimate Charge(Event Player, 0);
        Wait(0.150, Abort When False);
        Set Ultimate Ability Enabled(Event Player, False);
        Disallow Button(Event Player, Button(Ultimate));
        Big Message(Event Player, Players In Slot(Slot Of(Event Player), Team 1).p_Language == 1 ? Custom String("{0} 활성화!",
            Ability Icon String(Hero(Ana), Button(Ultimate))) : Custom String("{0} ACTIVATED!", Ability Icon String(Hero(Ana), Button(
            Ultimate))));
        Play Effect(All Players(All Teams), Good Pickup Effect, Color(Blue), Event Player, 2);
        Play Effect(All Players(All Teams), Explosion Sound, Color(White), Event Player, 60);
        Heal(Event Player, Event Player, 250);
        Start Damage Modification(Players In Slot(Slot Of(Event Player), Team 2), Event Player, 150,
            Receivers Damagers and Damage Percent);
        Call Subroutine(allSub_WaitForFrame);
        Event Player.p_DamageModDealtID = Last Damage Modification ID;
        Start Damage Modification(Event Player, Players In Slot(Slot Of(Event Player), Team 2), 50, Receivers Damagers and Damage Percent);
        Call Subroutine(allSub_WaitForFrame);
        Event Player.p_DamageModReceivedID = Last Damage Modification ID;
        Wait Until(Is Dead(Event Player), 8);
        Set Ultimate Ability Enabled(Event Player, True);
        Allow Button(Event Player, Button(Ultimate));
        Stop Damage Modification(Event Player.p_DamageModDealtID);
        Stop Damage Modification(Event Player.p_DamageModReceivedID);
    }
}
rule("Special Rule: Player Sombra Disable Enemy Attack")
{
    event
    {
        Ongoing - Each Player;
        Team 1;
        Sombra;
    }
    conditions
    {
        Players In Slot(Slot Of(Event Player), Team 2).ai_AIEnabled == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 2)) == True;
        Is Using Ability 1(Event Player) == True;
    }
    actions
    {
        Wait(Random Real(0.250, 0.500), Ignore Condition);
        Players In Slot(Slot Of(Event Player), Team 2).bot_MoveCrouchEnabled = False;
        Players In Slot(Slot Of(Event Player), Team 2).ai_CanAttack = False;
        Players In Slot(Slot Of(Event Player), Team 2).ai_CanUseAbilities = False;
        While(Is Using Ability 1(Event Player) == True && Hero Of(Event Player) == Hero(Sombra));
            Players In Slot(Slot Of(Event Player), Team 2).ai_LookAtVector = Vector(Random Real(-5, 5), Random Real(1, 2), Random Real(-5, 5))
                + Position Of(Players In Slot(Slot Of(Event Player), Team 2));
            Call Subroutine(aiSub_FacingLookAt);
            Wait(Random Real(0.250, 1.250), Ignore Condition);
            Players In Slot(Slot Of(Event Player), Team 2).ai_CanAim = True;
            If(Random Real(0, 1) < 0.050);
                Communicate(Players In Slot(Slot Of(Event Player), Team 2), Hello);
            End;
        End;
        Wait(Random Real(0.250, 0.500), Ignore Condition);
        Players In Slot(Slot Of(Event Player), Team 2).ai_CanAttack = True;
        Players In Slot(Slot Of(Event Player), Team 2).ai_CanUseAbilities = True;
        Players In Slot(Slot Of(Event Player), Team 2).bot_MoveCrouchEnabled = True;
    }
}
rule("aiSub_EnableAI")
{
    event
    {
        Subroutine;
        aiSub_EnableAI;
    }
    actions
    {
        Call Subroutine(allSub_WaitForFrame);
        Clear Status(Players In Slot(Slot Of(Event Player), Team 2), Unkillable);
        Players In Slot(Slot Of(Event Player), Team 2).bot_MoveWASDEnabled = True;
        Players In Slot(Slot Of(Event Player), Team 2).bot_MoveCrouchEnabled = True;
        Players In Slot(Slot Of(Event Player), Team 2).bot_MoveJumpEnabled = True;
        Players In Slot(Slot Of(Event Player), Team 2).ai_AIEnabled = True;
        Call Subroutine(aiSub_FacingReset);
    }
}
rule("aiSub_ReactionDelay")
{
    event
    {
        Subroutine;
        aiSub_ReactionDelay;
    }
    actions
    {
        Wait(Random Real(Players In Slot(Slot Of(Event Player), Team 2).ai_ReactionTime / 4, Players In Slot(Slot Of(Event Player), Team 2)
            .ai_ReactionTime), Ignore Condition);
    }
}
rule("aiSub_ButtonsReset")
{
    event
    {
        Subroutine;
        aiSub_ButtonsReset;
    }
    actions
    {
        Stop Holding Button(Players In Slot(Slot Of(Event Player), Team 2), Button(Primary Fire));
        Stop Holding Button(Players In Slot(Slot Of(Event Player), Team 2), Button(Secondary Fire));
        Stop Holding Button(Players In Slot(Slot Of(Event Player), Team 2), Button(Ability 1));
        Stop Holding Button(Players In Slot(Slot Of(Event Player), Team 2), Button(Ability 2));
        Stop Holding Button(Players In Slot(Slot Of(Event Player), Team 2), Button(Ultimate));
        Stop Holding Button(Players In Slot(Slot Of(Event Player), Team 2), Button(Jump));
        Stop Holding Button(Players In Slot(Slot Of(Event Player), Team 2), Button(Crouch));
        Stop Holding Button(Players In Slot(Slot Of(Event Player), Team 2), Button(Melee));
        Stop Holding Button(Players In Slot(Slot Of(Event Player), Team 2), Button(Reload));
        Wait(1 / 60, Ignore Condition);
    }
}
rule("aiSub_FacingStart")
{
    event
    {
        Subroutine;
        aiSub_FacingStart;
    }
    actions
    {
        Call Subroutine(allSub_WaitForFrame);
        Abort If(Players In Slot(Slot Of(Event Player), Team 2).ai_CanAim == False);
        Stop Facing(Players In Slot(Slot Of(Event Player), Team 2));
        "0 == hitscan/beam, 1 == projectile, 2 == arcing projectile"
        If(Players In Slot(Slot Of(Event Player), Team 2).ai_AimType == 0);
            If(Players In Slot(Slot Of(Event Player), Team 2).ai_AimBase == 0);
                Start Facing(
                    Players In Slot(Slot Of(Event Player), Team 2), 
                    Direction From Angles(
                        Horizontal Angle Towards(
                            Players In Slot(Slot Of(Event Player), Team 2), 
                            Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250, 0)
                        )
                        + Players In Slot(Slot Of(Event Player), Team 2).ai_AimModX,
                        Vertical Angle From Direction(
                            Direction Towards(
                                Eye Position(Players In Slot(Slot Of(Event Player), Team 2)),
                                Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250, 0)
                            )
                        )
                        + Players In Slot(Slot Of(Event Player), Team 2).ai_AimModY
                    ),
                    Players In Slot(Slot Of(Event Player), Team 2).ai_AimTurnRate,
                    To Player,
                    Direction and Turn Rate
                );
            Else If(Players In Slot(Slot Of(Event Player), Team 2).ai_AimBase == 1);
                Start Facing(
                    Players In Slot(Slot Of(Event Player), Team 2),
                    Direction From Angles(
                        Horizontal Angle Towards(
                            Players In Slot(Slot Of(Event Player), Team 2),
                            Eye Position(Players In Slot(Slot Of(Event Player), Team 1))
                        )
                        + Players In Slot(Slot Of(Event Player), Team 2).ai_AimModX,
                        Vertical Angle From Direction(
                            Direction Towards(
                                Eye Position(Players In Slot(Slot Of(Event Player), Team 2)),
                                Eye Position(Players In Slot(Slot Of(Event Player), Team 1))
                            )
                        )
                        + Players In Slot(Slot Of(Event Player), Team 2).ai_AimModY
                    ),
                    Players In Slot(Slot Of(Event Player), Team 2).ai_AimTurnRate,
                    To Player,
                    Direction and Turn Rate
                );
            Else If(Players In Slot(Slot Of(Event Player), Team 2).ai_AimBase == 2);
                Start Facing(
                    Players In Slot(Slot Of(Event Player), Team 2),
                    Direction From Angles(
                        Horizontal Angle Towards(
                            Players In Slot(Slot Of(Event Player), Team 2),
                            Position Of(Players In Slot(Slot Of(Event Player), Team 1))
                        )
                        + Players In Slot(Slot Of(Event Player), Team 2).ai_AimModX,
                        Vertical Angle From Direction(
                            Direction Towards(
                                Eye Position(Players In Slot(Slot Of(Event Player), Team 2)),
                                Position Of(Players In Slot(Slot Of(Event Player), Team 1))
                            )
                        )
                        + Players In Slot(Slot Of(Event Player), Team 2).ai_AimModY
                    ),
                    Players In Slot(Slot Of(Event Player), Team 2).ai_AimTurnRate,
                    To Player,
                    Direction and Turn Rate
                );
            Else If(Players In Slot(Slot Of(Event Player), Team 2).ai_AimBase == 3);
                Start Facing(
                    Players In Slot(Slot Of(Event Player), Team 2),
                    Direction From Angles(
                        Horizontal Angle Towards(
                            Players In Slot(Slot Of(Event Player), Team 2),
                            Position Of(Players In Slot(Slot Of(Event Player), Team 1))
                            + Players In Slot(Slot Of(Event Player), Team 2).ai_FacingRelPosMod
                        )
                        + Players In Slot(Slot Of(Event Player), Team 2).ai_AimModX,
                        Vertical Angle From Direction(
                            Direction Towards(
                                Eye Position(Players In Slot(Slot Of(Event Player), Team 2)),
                                Position Of(Players In Slot(Slot Of(Event Player), Team 1))
                                + Players In Slot(Slot Of(Event Player), Team 2).ai_FacingRelPosMod
                            )
                        )
                        + Players In Slot(Slot Of(Event Player), Team 2).ai_AimModY
                    ),
                    Players In Slot(Slot Of(Event Player), Team 2).ai_AimTurnRate,
                    To Player,
                    Direction and Turn Rate
                );
            End;
        Else If(Players In Slot(Slot Of(Event Player), Team 2).ai_AimType == 1);
            If(Players In Slot(Slot Of(Event Player), Team 2).ai_AimBase == 0);
                Start Facing(
                    Players In Slot(Slot Of(Event Player), Team 2),
                    Direction From Angles(
                        Horizontal Angle Towards(
                            Players In Slot(Slot Of(Event Player), Team 2),
                            World Vector Of(
                                Speed Of(Players In Slot(Slot Of(Event Player), Team 1))
                                * Throttle Of(Players In Slot(Slot Of(Event Player), Team 1)),
                                Players In Slot(Slot Of(Event Player), Team 1),
                                Rotation
                            )
                            * (
                                Distance Between(
                                    Position Of(Players In Slot(Slot Of(Event Player), Team 2)),
                                    Position Of(Players In Slot(Slot Of(Event Player), Team 1))
                                )
                                / Players In Slot(Slot Of(Event Player), Team 2).ai_ProjectileSpeed
                            )
                            + Position Of(Players In Slot(Slot Of(Event Player), Team 1))
                        )
                        + Players In Slot(Slot Of(Event Player), Team 2).ai_AimModX,
                        Vertical Angle From Direction(
                            Direction Towards(
                                Eye Position(Players In Slot(Slot Of(Event Player), Team 2)),
                                Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250, 0)
                            )
                        )
                        + Players In Slot(Slot Of(Event Player), Team 2).ai_AimModY
                    ),
                    Players In Slot(Slot Of(Event Player), Team 2).ai_AimTurnRate,
                    To Player,
                    Direction and Turn Rate
                );
            Else If(Players In Slot(Slot Of(Event Player), Team 2).ai_AimBase == 1);
                Start Facing(
                    Players In Slot(Slot Of(Event Player), Team 2),
                    Direction From Angles(
                        Horizontal Angle Towards(
                            Players In Slot(Slot Of(Event Player), Team 2),
                            World Vector Of(
                                Speed Of(Players In Slot(Slot Of(Event Player), Team 1))
                                * Throttle Of(Players In Slot(Slot Of(Event Player), Team 1)),
                                Players In Slot(Slot Of(Event Player), Team 1),
                                Rotation
                            )
                            * (
                                Distance Between(
                                    Position Of(Players In Slot(Slot Of(Event Player), Team 2)),
                                    Position Of(Players In Slot(Slot Of(Event Player), Team 1))
                                )
                                / Players In Slot(Slot Of(Event Player), Team 2).ai_ProjectileSpeed
                            )
                            + Position Of(Players In Slot(Slot Of(Event Player), Team 1))
                        )
                        + Players In Slot(Slot Of(Event Player), Team 2).ai_AimModX,
                        Vertical Angle From Direction(
                            Direction Towards(
                                Eye Position(Players In Slot(Slot Of(Event Player), Team 2)),
                                Eye Position(Players In Slot(Slot Of(Event Player), Team 1))
                            )
                        )
                        + Players In Slot(Slot Of(Event Player), Team 2).ai_AimModY
                    ),
                    Players In Slot(Slot Of(Event Player), Team 2).ai_AimTurnRate,
                    To Player,
                    Direction and Turn Rate
                );
            Else If(Players In Slot(Slot Of(Event Player), Team 2).ai_AimBase == 2);
                Start Facing(
                    Players In Slot(Slot Of(Event Player), Team 2),
                    Direction From Angles(
                        Horizontal Angle Towards(
                            Players In Slot(Slot Of(Event Player), Team 2),
                            World Vector Of(
                                Speed Of(Players In Slot(Slot Of(Event Player), Team 1))
                                * Throttle Of(Players In Slot(Slot Of(Event Player), Team 1)),
                                Players In Slot(Slot Of(Event Player), Team 1),
                                Rotation
                            )
                            * (
                                Distance Between(
                                    Position Of(Players In Slot(Slot Of(Event Player), Team 2)),
                                    Position Of(Players In Slot(Slot Of(Event Player), Team 1))
                                )
                                / Players In Slot(Slot Of(Event Player), Team 2).ai_ProjectileSpeed
                            )
                            + Position Of(Players In Slot(Slot Of(Event Player), Team 1))
                        )
                        + Players In Slot(Slot Of(Event Player), Team 2).ai_AimModX,
                        Vertical Angle From Direction(
                            Direction Towards(
                                Eye Position(Players In Slot(Slot Of(Event Player), Team 2)),
                                Position Of(Players In Slot(Slot Of(Event Player), Team 1))
                            )
                        )
                        + Players In Slot(Slot Of(Event Player), Team 2).ai_AimModY
                    ),
                    Players In Slot(Slot Of(Event Player), Team 2).ai_AimTurnRate,
                    To Player,
                    Direction and Turn Rate
                );
            Else If(Players In Slot(Slot Of(Event Player), Team 2).ai_AimBase == 3);
                Start Facing(
                    Players In Slot(Slot Of(Event Player), Team 2),
                    Direction From Angles(
                        Horizontal Angle Towards(
                            Players In Slot(Slot Of(Event Player), Team 2),
                            World Vector Of(
                                Speed Of(Players In Slot(Slot Of(Event Player), Team 1))
                                * Throttle Of(Players In Slot(Slot Of(Event Player), Team 1)),
                                Players In Slot(Slot Of(Event Player), Team 1),
                                Rotation
                            )
                            * (
                                Distance Between(
                                    Position Of(Players In Slot(Slot Of(Event Player), Team 2)),
                                    Position Of(Players In Slot(Slot Of(Event Player), Team 1))
                                )
                                / Players In Slot(Slot Of(Event Player), Team 2).ai_ProjectileSpeed
                            )
                            + Position Of(Players In Slot(Slot Of(Event Player), Team 1))
                            + Players In Slot(Slot Of(Event Player), Team 2).ai_FacingRelPosMod
                        )
                        + Players In Slot(Slot Of(Event Player), Team 2).ai_AimModX,
                        Vertical Angle From Direction(
                            Direction Towards(
                                Eye Position(Players In Slot(Slot Of(Event Player), Team 2)),
                                Position Of(Players In Slot(Slot Of(Event Player), Team 1))
                                + Players In Slot(Slot Of(Event Player), Team 2).ai_FacingRelPosMod
                            )
                        )
                        + Players In Slot(Slot Of(Event Player), Team 2).ai_AimModY
                    ),
                    Players In Slot(Slot Of(Event Player), Team 2).ai_AimTurnRate,
                    To Player,
                    Direction and Turn Rate
                );
            End;
        Else If(Players In Slot(Slot Of(Event Player), Team 2).ai_AimType == 2);
            If(Players In Slot(Slot Of(Event Player), Team 2).ai_AimBase == 0);
                Start Facing(Players In Slot(Slot Of(Event Player), Team 2), Direction From Angles(Horizontal Angle Towards(Players In Slot(Slot Of(Event Player), Team 2),
                    World Vector Of(Speed Of(Players In Slot(Slot Of(Event Player), Team 1)) * Throttle Of(Players In Slot(Slot Of(Event Player),
                    Team 1)), Players In Slot(Slot Of(Event Player), Team 1), Rotation) * (Distance Between(Players In Slot(Slot Of(Event Player), Team 2), Eye Position(
                    Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250, 0)) / Players In Slot(Slot Of(Event Player), Team 2).ai_ProjectileSpeed) + Eye Position(
                    Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250, 0)) + Players In Slot(Slot Of(Event Player), Team 2).ai_AimModX,
                    Vertical Angle From Direction(Direction Towards(Eye Position(Players In Slot(Slot Of(Event Player), Team 2)), World Vector Of(Speed Of(Players In Slot(Slot Of(
                    Event Player), Team 1)) * Throttle Of(Players In Slot(Slot Of(Event Player), Team 1)), Players In Slot(Slot Of(Event Player),
                    Team 1), Rotation) * (Distance Between(Players In Slot(Slot Of(Event Player), Team 2), Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0,
                    0.250, 0)) / Players In Slot(Slot Of(Event Player), Team 2).ai_ProjectileSpeed) + Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250,
                    0))) + Players In Slot(Slot Of(Event Player), Team 2).ai_AimModY + Arcsine In Degrees(-9.800 * (Distance Between(Eye Position(Players In Slot(Slot Of(Event Player), Team 2)), Eye Position(
                    Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250, 0)) - Players In Slot(Slot Of(Event Player), Team 2).ai_AimDistanceMod)
                    / Players In Slot(Slot Of(Event Player), Team 2).ai_ProjectileSpeed ^ 2) / 2), Players In Slot(Slot Of(Event Player), Team 2).ai_AimTurnRate, To Player, Direction and Turn Rate);
            Else If(Players In Slot(Slot Of(Event Player), Team 2).ai_AimBase == 1);
                Start Facing(Players In Slot(Slot Of(Event Player), Team 2), Direction From Angles(Horizontal Angle Towards(Players In Slot(Slot Of(Event Player), Team 2),
                    World Vector Of(Speed Of(Players In Slot(Slot Of(Event Player), Team 1)) * Throttle Of(Players In Slot(Slot Of(Event Player),
                    Team 1)), Players In Slot(Slot Of(Event Player), Team 1), Rotation) * (Distance Between(Players In Slot(Slot Of(Event Player), Team 2), Eye Position(
                    Players In Slot(Slot Of(Event Player), Team 1))) / Players In Slot(Slot Of(Event Player), Team 2).ai_ProjectileSpeed) + Eye Position(Players In Slot(Slot Of(
                    Event Player), Team 1))) + Players In Slot(Slot Of(Event Player), Team 2).ai_AimModX, Vertical Angle From Direction(Direction Towards(Eye Position(Players In Slot(Slot Of(Event Player), Team 2)),
                    World Vector Of(Speed Of(Players In Slot(Slot Of(Event Player), Team 1)) * Throttle Of(Players In Slot(Slot Of(Event Player),
                    Team 1)), Players In Slot(Slot Of(Event Player), Team 1), Rotation) * (Distance Between(Players In Slot(Slot Of(Event Player), Team 2), Eye Position(
                    Players In Slot(Slot Of(Event Player), Team 1))) / Players In Slot(Slot Of(Event Player), Team 2).ai_ProjectileSpeed) + Eye Position(Players In Slot(Slot Of(
                    Event Player), Team 1)))) + Players In Slot(Slot Of(Event Player), Team 2).ai_AimModY + Arcsine In Degrees(-9.800 * (Distance Between(Eye Position(Players In Slot(Slot Of(Event Player), Team 2)),
                    Eye Position(Players In Slot(Slot Of(Event Player), Team 1))) - Players In Slot(Slot Of(Event Player), Team 2).ai_AimDistanceMod)
                    / Players In Slot(Slot Of(Event Player), Team 2).ai_ProjectileSpeed ^ 2) / 2), Players In Slot(Slot Of(Event Player), Team 2).ai_AimTurnRate, To Player, Direction and Turn Rate);
            Else If(Players In Slot(Slot Of(Event Player), Team 2).ai_AimBase == 2);
                Start Facing(Players In Slot(Slot Of(Event Player), Team 2), Direction From Angles(Horizontal Angle Towards(Players In Slot(Slot Of(Event Player), Team 2),
                    World Vector Of(Speed Of(Players In Slot(Slot Of(Event Player), Team 1)) * Throttle Of(Players In Slot(Slot Of(Event Player),
                    Team 1)), Players In Slot(Slot Of(Event Player), Team 1), Rotation) * (Distance Between(Players In Slot(Slot Of(Event Player), Team 2), Position Of(
                    Players In Slot(Slot Of(Event Player), Team 1))) / Players In Slot(Slot Of(Event Player), Team 2).ai_ProjectileSpeed) + Position Of(Players In Slot(Slot Of(
                    Event Player), Team 1))) + Players In Slot(Slot Of(Event Player), Team 2).ai_AimModX, Vertical Angle From Direction(Direction Towards(Eye Position(Players In Slot(Slot Of(Event Player), Team 2)),
                    World Vector Of(Speed Of(Players In Slot(Slot Of(Event Player), Team 1)) * Throttle Of(Players In Slot(Slot Of(Event Player),
                    Team 1)), Players In Slot(Slot Of(Event Player), Team 1), Rotation) * (Distance Between(Players In Slot(Slot Of(Event Player), Team 2), Position Of(
                    Players In Slot(Slot Of(Event Player), Team 1))) / Players In Slot(Slot Of(Event Player), Team 2).ai_ProjectileSpeed) + Position Of(Players In Slot(Slot Of(
                    Event Player), Team 1)))) + Players In Slot(Slot Of(Event Player), Team 2).ai_AimModY + Arcsine In Degrees(-9.800 * (Distance Between(Eye Position(Players In Slot(Slot Of(Event Player), Team 2)),
                    Position Of(Players In Slot(Slot Of(Event Player), Team 1))) - Players In Slot(Slot Of(Event Player), Team 2).ai_AimDistanceMod)
                    / Players In Slot(Slot Of(Event Player), Team 2).ai_ProjectileSpeed ^ 2) / 2), Players In Slot(Slot Of(Event Player), Team 2).ai_AimTurnRate, To Player, Direction and Turn Rate);
            Else If(Players In Slot(Slot Of(Event Player), Team 2).ai_AimBase == 3);
                Start Facing(Players In Slot(Slot Of(Event Player), Team 2), Direction From Angles(Horizontal Angle Towards(Players In Slot(Slot Of(Event Player), Team 2),
                    World Vector Of(Speed Of(Players In Slot(Slot Of(Event Player), Team 1)) * Throttle Of(Players In Slot(Slot Of(Event Player),
                    Team 1)), Players In Slot(Slot Of(Event Player), Team 1), Rotation) * (Distance Between(Players In Slot(Slot Of(Event Player), Team 2), Position Of(
                    Players In Slot(Slot Of(Event Player), Team 1)) + Players In Slot(Slot Of(Event Player), Team 2).ai_FacingRelPosMod) / Players In Slot(Slot Of(Event Player), Team 2).ai_ProjectileSpeed)
                    + Position Of(Players In Slot(Slot Of(Event Player), Team 1)) + Players In Slot(Slot Of(Event Player), Team 2).ai_FacingRelPosMod) + Players In Slot(Slot Of(Event Player), Team 2).ai_AimModX,
                    Vertical Angle From Direction(Direction Towards(Eye Position(Players In Slot(Slot Of(Event Player), Team 2)), World Vector Of(Speed Of(Players In Slot(Slot Of(
                    Event Player), Team 1)) * Throttle Of(Players In Slot(Slot Of(Event Player), Team 1)), Players In Slot(Slot Of(Event Player),
                    Team 1), Rotation) * (Distance Between(Players In Slot(Slot Of(Event Player), Team 2), Position Of(Players In Slot(Slot Of(Event Player), Team 1))
                    + Players In Slot(Slot Of(Event Player), Team 2).ai_FacingRelPosMod) / Players In Slot(Slot Of(Event Player), Team 2).ai_ProjectileSpeed) + Position Of(Players In Slot(Slot Of(Event Player),
                    Team 1)) + Players In Slot(Slot Of(Event Player), Team 2).ai_FacingRelPosMod)) + Players In Slot(Slot Of(Event Player), Team 2).ai_AimModY + Arcsine In Degrees(-9.800 * (Distance Between(
                    Eye Position(Players In Slot(Slot Of(Event Player), Team 2)), Position Of(Players In Slot(Slot Of(Event Player), Team 1)) + Players In Slot(Slot Of(Event Player), Team 2).ai_FacingRelPosMod)
                    - Players In Slot(Slot Of(Event Player), Team 2).ai_AimDistanceMod) / Players In Slot(Slot Of(Event Player), Team 2).ai_ProjectileSpeed ^ 2) / 2), Players In Slot(Slot Of(Event Player), Team 2).ai_AimTurnRate, To Player,
                    Direction and Turn Rate);
            End;
        End;
    }
}
rule("aiSub_FacingLookAt")
{
    event
    {
        Subroutine;
        aiSub_FacingLookAt;
    }
    actions
    {
        Players In Slot(Slot Of(Event Player), Team 2).ai_CanAim = False;
        Wait(2 / 60, Ignore Condition);
        Players In Slot(Slot Of(Event Player), Team 2).ai_AimTurnRate = Random Real(Players In Slot(Slot Of(Event Player), Team 2)
            .ai_FacingCapMin, Players In Slot(Slot Of(Event Player), Team 2).ai_FacingCapMin * 1.500);
        Stop Facing(Players In Slot(Slot Of(Event Player), Team 2));
        Start Facing(Players In Slot(Slot Of(Event Player), Team 2), Direction Towards(Eye Position(Players In Slot(Slot Of(Event Player),
            Team 2)), Players In Slot(Slot Of(Event Player), Team 2).ai_LookAtVector), Evaluate Once(Random Real(Players In Slot(Slot Of(
            Event Player), Team 2).ai_FacingCapMin, Players In Slot(Slot Of(Event Player), Team 2).ai_FacingCapMax)), To World,
            Direction and Turn Rate);
        Wait Until(Is In View Angle(Players In Slot(Slot Of(Event Player), Team 2), Players In Slot(Slot Of(Event Player), Team 2)
            .ai_LookAtVector - Vector(0, Y Component Of(Eye Position(Players In Slot(Slot Of(Event Player), Team 2))), 0), 12.500), 2);
        Stop Facing(Players In Slot(Slot Of(Event Player), Team 2));
    }
}
rule("aiSub_FacingReset")
{
    event
    {
        Subroutine;
        aiSub_FacingReset;
    }
    actions
    {
        Players In Slot(Slot Of(Event Player), Team 2).ai_AimType = Players In Slot(Slot Of(Event Player), Team 2).ai_AimTypeDefault;
        Players In Slot(Slot Of(Event Player), Team 2).ai_AimBase = Players In Slot(Slot Of(Event Player), Team 2).ai_AimBaseDefault;
        Call Subroutine(aiSub_FacingStart);
    }
}
rule("AI Aim Mod Calculation")
{
    event
    {
        Subroutine;
        aiSub_AimModSet;
    }
    actions
    {
        Stop Chasing Player Variable(Event Player, ai_AimModX);
        Stop Chasing Player Variable(Event Player, ai_AimModY);
        If(Array Contains(Global.c_ScopeHeroes, Hero Of(Event Player)) && Is Firing Secondary(Event Player));
            If(Horizontal Angle Towards(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) > 0);
                Chase Player Variable Over Time(Event Player, ai_AimModX, Random Real(0, (Global.c_MaxDifficulty - Players In Slot(Slot Of(
                    Event Player), Team 1).p_Difficulty) * 0.450), Random Real(0.100, 0.500), None);
            Else;
                Chase Player Variable Over Time(Event Player, ai_AimModX, Random Real(-0.450 * (Global.c_MaxDifficulty - Players In Slot(Slot Of(
                    Event Player), Team 1).p_Difficulty), 0), Random Real(0.100, 0.500), None);
            End;
            Chase Player Variable Over Time(Event Player, ai_AimModY, Random Real(-0.300 * (Global.c_MaxDifficulty - Players In Slot(Slot Of(
                Event Player), Team 1).p_Difficulty), (Global.c_MaxDifficulty - Players In Slot(Slot Of(Event Player), Team 1).p_Difficulty)
                * 0.300), Random Real(0.100, 0.500), None);
        Else;
            If(Horizontal Angle Towards(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) > 0);
                Chase Player Variable Over Time(Event Player, ai_AimModX, Random Real(0, (Global.c_MaxDifficulty - Players In Slot(Slot Of(
                    Event Player), Team 1).p_Difficulty) * 0.750), Random Real(0.100, 0.500), None);
            Else;
                Chase Player Variable Over Time(Event Player, ai_AimModX, Random Real(-0.750 * (Global.c_MaxDifficulty - Players In Slot(Slot Of(
                    Event Player), Team 1).p_Difficulty), 0), Random Real(0.100, 0.500), None);
            End;
            Chase Player Variable Over Time(Event Player, ai_AimModY, Random Real(-0.550 * (Global.c_MaxDifficulty - Players In Slot(Slot Of(
                Event Player), Team 1).p_Difficulty), (Global.c_MaxDifficulty - Players In Slot(Slot Of(Event Player), Team 1).p_Difficulty)
                * 0.550), Random Real(0.100, 0.500), None);
        End;
    }
}
rule("AI Aim Calculation")
{
    event
    {
        Subroutine;
        aiSub_AimCalculation;
    }
    actions
    {
        If(Event Player.ai_AimTurnRate == 0);
            Call Subroutine(allSub_WaitForFrame);
            Chase Player Variable Over Time(Event Player, ai_AimTurnRate, Random Real(Event Player.ai_FacingPadMin,
                Event Player.ai_FacingPadMax), Random Real(0.050, 0.150), None);
            Wait(0.150, Ignore Condition);
            Stop Chasing Player Variable(Event Player, ai_AimTurnRate);
        Else If(Random Real(0, 1) < 0.350 - Event Player.ai_ChanceMod);
            Call Subroutine(allSub_WaitForFrame);
            Event Player.ai_AimStopTime = Total Time Elapsed + Random Real(0.150, 0.250) - Event Player.ai_ChanceMod;
            Chase Player Variable At Rate(Event Player, ai_AimTurnRate, 0, Random Integer(250, 500), Destination and Rate);
            Wait Until(Event Player.ai_AimTurnRate == 0, Random Real(0.150, 0.250) - Event Player.ai_ChanceMod);
            Stop Chasing Player Variable(Event Player, ai_AimTurnRate);
            Chase Player Variable Over Time(Event Player, ai_AimTurnRate, 0, Random Real(0.150, 0.250) - Event Player.ai_ChanceMod, None);
            Call Subroutine(aiSub_AimModSet);
        Else;
            Call Subroutine(allSub_WaitForFrame);
            Event Player.ai_AimTurnRate = (Event Player.ai_FacingAngleMod * Angle Between Vectors(Facing Direction Of(Event Player),
                Direction Towards(Eye Position(Event Player), Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.300,
                0)))) ^ Event Player.ai_FacingAnglePow + Random Real(Event Player.ai_FacingPadMin, Event Player.ai_FacingPadMax);
        End;
        If(Array Contains(Global.c_ScopeHeroes, Hero Of(Event Player)) && Is Firing Secondary(Event Player));
            Event Player.ai_AimTurnRate = Event Player.ai_AimTurnRate / 1.500;
        End;
    }
}
rule("aiSub_FlickIn")
{
    event
    {
        Subroutine;
        aiSub_FlickIn;
    }
    actions
    {
        Stop Facing(Players In Slot(Slot Of(Event Player), Team 2));
        If(Players In Slot(Slot Of(Event Player), Team 2).ai_AimBase == 0);
            Start Facing(Players In Slot(Slot Of(Event Player), Team 2), Direction Towards(Eye Position(Event Player), Eye Position(
                Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250, 0)), Evaluate Once(Random Integer(Players In Slot(Slot Of(
                Event Player), Team 2).ai_FacingCapMax - 180, Players In Slot(Slot Of(Event Player), Team 2).ai_FacingCapMax)), To World,
                Direction and Turn Rate);
            Wait Until(Is In View Angle(Players In Slot(Slot Of(Event Player), Team 2), Vector(X Component Of(Eye Position(Players In Slot(
                Slot Of(Event Player), Team 1)) - Vector(0, 0.250, 0)), Y Component Of(Eye Position(Players In Slot(Slot Of(Event Player),
                Team 1)) - Vector(0, 0.250, 0)) - Y Component Of(Eye Position(Players In Slot(Slot Of(Event Player), Team 2)) - Vector(0,
                0.250, 0)), Z Component Of(Eye Position(Players In Slot(Slot Of(Event Player), Team 1)))), 0.500), 1);
        Else If(Players In Slot(Slot Of(Event Player), Team 2).ai_AimBase == 1);
            Start Facing(Players In Slot(Slot Of(Event Player), Team 2), Direction Towards(Eye Position(Event Player), Eye Position(
                Players In Slot(Slot Of(Event Player), Team 1))), Evaluate Once(Random Integer(Players In Slot(Slot Of(Event Player), Team 2)
                .ai_FacingCapMax - 180, Players In Slot(Slot Of(Event Player), Team 2).ai_FacingCapMax)), To World, Direction and Turn Rate);
            Wait Until(Is In View Angle(Players In Slot(Slot Of(Event Player), Team 2), Vector(X Component Of(Eye Position(Players In Slot(
                Slot Of(Event Player), Team 1))), Y Component Of(Eye Position(Players In Slot(Slot Of(Event Player), Team 1)))
                - Y Component Of(Eye Position(Players In Slot(Slot Of(Event Player), Team 2))), Z Component Of(Eye Position(Players In Slot(
                Slot Of(Event Player), Team 1)))), 0.500), 1);
        End;
    }
}
rule("aiSub_FlickOut")
{
    event
    {
        Subroutine;
        aiSub_FlickOut;
    }
    actions
    {
        Stop Facing(Players In Slot(Slot Of(Event Player), Team 2));
        Start Facing(Players In Slot(Slot Of(Event Player), Team 2), Direction From Angles(Horizontal Facing Angle Of(Players In Slot(
            Slot Of(Event Player), Team 2)) - Random Real(0.600, 1), Vertical Facing Angle Of(Players In Slot(Slot Of(Event Player),
            Team 2)) - Random Real(0.300, 0.700)), Evaluate Once(Random Integer(Players In Slot(Slot Of(Event Player), Team 2)
            .ai_FacingCapMax - 180, Players In Slot(Slot Of(Event Player), Team 2).ai_FacingCapMax)), To World, None);
        Wait(Random Real(0.100, 0.200), Ignore Condition);
        Call Subroutine(aiSub_FacingReset);
    }
}
rule("AI Enable")
{
    event
    {
        Player Took Damage;
        Team 2;
        All;
    }
    conditions
    {
        Event Player.ai_AIEnabled == False;
        Players In Slot(Slot Of(Event Player), Team 1).p_Difficulty >= 3;
        Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuIsOpen == False;
        Event Player.bot_BotResetComplete == True;
    }
    actions
    {
        Wait(0.250, Ignore Condition);
        Heal(Event Player, Null, Max Health(Event Player));
        Call Subroutine(aiSub_EnableAI);
    }
}
rule("AI Aim Calculation Loop")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        All;
    }
    conditions
    {
        Is Alive(Event Player) == True;
        Event Player.bot_BotResetComplete == True;
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAim == True;
        Players In Slot(Slot Of(Event Player), Team 1).p_Difficulty >= 3;
        Total Time Elapsed >= Event Player.ai_AimStopTime;
        ((Slot Of(Event Player) % 2 == 0 && Global.g_Tick % 2 == 0) || (Slot Of(Event Player) % 2 != 0 && Global.g_Tick % 2 != 0))
            == True;
        Global.g_Tick % 5 == 0;
    }
    actions
    {
        Start Rule(aiSub_AimCalculation, Do Nothing);
    }
}
rule("AI Aim Stop")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        All;
    }
    conditions
    {
        Is Alive(Event Player) == True;
        Event Player.bot_BotResetComplete == True;
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAim == True;
        Players In Slot(Slot Of(Event Player), Team 1).p_Difficulty >= 3;
        Is In View Angle(Event Player, Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250 + Y Component Of(
            Eye Position(Event Player)), 0), 5) == True;
    }
    actions
    {
        If(Random Real(0, 1) < 0.750 - Event Player.ai_ChanceMod);
            If(Global.g_DebugHUD == True);
                Small Message(Event Player, Custom String("aim stop"));
            End;
            Event Player.ai_AimStopTime = Total Time Elapsed + Random Real(0.200, 0.600) - Players In Slot(Slot Of(Event Player), Team 1)
                .p_Difficulty * 0.020;
            Chase Player Variable At Rate(Event Player, ai_AimTurnRate, 0, Random Integer(360, 720), Destination and Rate);
            Wait Until(Event Player.ai_AimTurnRate == 0, Random Real(0.075, 0.150) - Event Player.ai_ChanceMod);
            Stop Chasing Player Variable(Event Player, ai_AimTurnRate);
            Chase Player Variable Over Time(Event Player, ai_AimTurnRate, 0, Random Real(0.025, 0.075) - Event Player.ai_ChanceMod, None);
            Start Rule(aiSub_AimModSet, Restart Rule);
        End;
    }
}
rule("AI Aim Flick")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        All;
    }
    conditions
    {
        Is Alive(Event Player) == True;
        Event Player.bot_BotResetComplete == True;
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAim == True;
        Players In Slot(Slot Of(Event Player), Team 1).p_Difficulty >= 3;
        Is In View Angle(Event Player, Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250 + Y Component Of(
            Eye Position(Event Player)), 0), 1) == False;
    }
    actions
    {
        If(Global.g_DebugHUD == True);
            Small Message(Event Player, Custom String("aim flick"));
        End;
        Start Rule(aiSub_AimModSet, Restart Rule);
    }
}
rule("AI Attack Melee")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        All;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Is Alive(Event Player) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) < 2.500;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 45 + Event Player.ai_ViewAngleMod) == True;
        Health(Players In Slot(Slot Of(Event Player), Team 1)) <= 30;
        Health(Players In Slot(Slot Of(Event Player), Team 1)) > 0;
    }
    actions
    {
        Call Subroutine(aiSub_ReactionDelay);
        Press Button(Event Player, Button(Melee));
    }
}
rule("AI Aim Start")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        All;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Event Player.ai_CanAim == True;
    }
    actions
    {
        Call Subroutine(aiSub_FacingStart);
    }
}
rule("AI Rule Can Aim")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        All;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Has Status(Event Player, Knocked Down) == False;
        Has Status(Event Player, Asleep) == False;
        Has Status(Event Player, Frozen) == False;
        Has Status(Event Player, Stunned) == False;
    }
    actions
    {
        Event Player.ai_CanAim = True;
    }
}
rule("AI Rule Can Attack")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        All;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Is Alive(Event Player) == True;
        Has Status(Event Player, Knocked Down) == False;
        Has Status(Event Player, Asleep) == False;
        Has Status(Event Player, Frozen) == False;
        Has Status(Event Player, Phased Out) == False;
        Has Status(Event Player, Stunned) == False;
    }
    actions
    {
        Event Player.ai_CanAttack = True;
    }
}
rule("AI Rule Can Use Abilities")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        All;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Is Alive(Event Player) == True;
        Has Status(Event Player, Hacked) == False;
        Has Status(Event Player, Knocked Down) == False;
        Has Status(Event Player, Asleep) == False;
        Has Status(Event Player, Frozen) == False;
        Has Status(Event Player, Phased Out) == False;
        Has Status(Event Player, Stunned) == False;
    }
    actions
    {
        Event Player.ai_CanUseAbilities = True;
    }
}
rule("AI Rule Status Hacked")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        All;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Is Alive(Event Player) == True;
        Has Status(Event Player, Hacked) == True;
    }
    actions
    {
        Event Player.ai_CanUseAbilities = False;
    }
}
rule("AI Rule Status Knocked Down")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        All;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Is Alive(Event Player) == True;
        Has Status(Event Player, Knocked Down) == True;
    }
    actions
    {
        Event Player.ai_CanAim = False;
        Event Player.ai_CanAttack = False;
        Event Player.ai_CanUseAbilities = False;
        Stop Facing(Players In Slot(Slot Of(Event Player), Team 2));
    }
}
rule("AI Rule Status Asleep")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        All;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Is Alive(Event Player) == True;
        Has Status(Event Player, Asleep) == True;
    }
    actions
    {
        Event Player.ai_CanAim = False;
        Event Player.ai_CanAttack = False;
        Event Player.ai_CanUseAbilities = False;
        Stop Facing(Players In Slot(Slot Of(Event Player), Team 2));
    }
}
rule("AI Rule Status Frozen")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        All;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Is Alive(Event Player) == True;
        Has Status(Event Player, Frozen) == True;
    }
    actions
    {
        Event Player.ai_CanAim = False;
        Event Player.ai_CanAttack = False;
        Event Player.ai_CanUseAbilities = False;
        Stop Facing(Players In Slot(Slot Of(Event Player), Team 2));
    }
}
rule("AI Rule Status Phased Out")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        All;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Is Alive(Event Player) == True;
        Has Status(Event Player, Phased Out) == True;
    }
    actions
    {
        Event Player.ai_CanUseAbilities = False;
        Event Player.ai_CanAttack = False;
    }
}
rule("AI Rule Status Stunned")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        All;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Is Alive(Event Player) == True;
        Has Status(Event Player, Stunned) == True;
    }
    actions
    {
        Event Player.ai_CanAim = False;
        Event Player.ai_CanAttack = False;
        Event Player.ai_CanUseAbilities = False;
        Stop Facing(Players In Slot(Slot Of(Event Player), Team 2));
    }
}
rule("AI Movement WASD Strafe On Dmg")
{
    event
    {
        Player Took Damage;
        Team 2;
        All;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.bot_MoveWASDEnabled == True;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1))
            > Event Player.ai_OptimalDistance + Event Player.ai_StrafeDistanceMod;
        Event Damage > 25;
    }
    actions
    {
        If(Random Real(0, 1) < 0.700 + Event Player.ai_ChanceMod);
            Call Subroutine(aiSub_ReactionDelay);
            Event Player.bot_ThrottleDir = Random Value In Array(Global.c_MoveDir_Strafe);
            Start Rule(botSub_MoveWASD, Restart Rule);
        End;
    }
}
rule("AI Movement WASD Move Closer")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        All;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.bot_MoveWASDEnabled == True;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Distance Between(Event Player, Vector(X Component Of(Position Of(Players In Slot(Slot Of(Event Player), Team 1))), 0,
            Z Component Of(Position Of(Players In Slot(Slot Of(Event Player), Team 1))))) >= Event Player.ai_OptimalDistance;
    }
    actions
    {
        If(Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1))
            > Event Player.ai_OptimalDistance + Event Player.ai_StrafeDistanceMod);
            Event Player.bot_ThrottleDir = Random Value In Array(Remove From Array(Global.c_MoveDir_Forward, Array(Left, Right,
                Event Player.bot_ThrottleDir)));
        Else;
            Event Player.bot_ThrottleDir = Random Value In Array(Remove From Array(Global.c_MoveDir_Forward, Event Player.bot_ThrottleDir));
        End;
        Call Subroutine(botSub_MoveWASD);
        Loop If Condition Is True;
    }
}
rule("AI Movement WASD Move Farther")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        All;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.bot_MoveWASDEnabled == True;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Distance Between(Event Player, Vector(X Component Of(Position Of(Players In Slot(Slot Of(Event Player), Team 1))), 0,
            Z Component Of(Position Of(Players In Slot(Slot Of(Event Player), Team 1))))) < Event Player.ai_OptimalDistance;
    }
    actions
    {
        Event Player.bot_ThrottleDir = Random Value In Array(Remove From Array(Global.c_MoveDir_Backward, Event Player.bot_ThrottleDir));
        Call Subroutine(botSub_MoveWASD);
        Loop If Condition Is True;
    }
}
rule("AI Optimal Distance Default Resize")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        All;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Is Alive(Event Player) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1).p_HomeVector) >= Players In Slot(Slot Of(
            Event Player), Team 1).p_EnemyDistanceMax - 2.500;
    }
    actions
    {
        Event Player.ai_OptimalDistance = Random Real(2.500, 5);
        Wait(Random Real(1.500, 3), Ignore Condition);
        Loop If Condition Is True;
        Event Player.ai_OptimalDistance = Event Player.ai_OptimalDistanceDefault;
    }
}
rule("AI Movement Crouch")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        All;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.bot_MoveCrouchEnabled == True;
        Is Alive(Event Player) == True;
        Is On Ground(Event Player) == True;
        Is In View Angle(Players In Slot(Slot Of(Event Player), Team 1), Eye Position(Event Player) - Vector(0, 0.250 + Y Component Of(
            Eye Position(Players In Slot(Slot Of(Event Player), Team 1))), 0), 10) == True;
    }
    actions
    {
        Call Subroutine(botSub_MoveCrouch);
        Loop If Condition Is True;
        Stop Holding Button(Event Player, Button(Crouch));
    }
}
rule("AI Movement Jump")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        All;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.bot_MoveJumpEnabled == True;
        Is Alive(Event Player) == True;
        Is On Ground(Event Player) == True;
    }
    actions
    {
        Call Subroutine(botSub_MoveJump);
        Loop If Condition Is True;
        Stop Holding Button(Event Player, Button(Jump));
    }
}
rule("Quick Mode AI Enable")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        All;
    }
    conditions
    {
        Players In Slot(Slot Of(Event Player), Team 1).p_QuickModeEnabled == True;
        Players In Slot(Slot Of(Event Player), Team 1).p_Difficulty >= 3;
        Players In Slot(Slot Of(Event Player), Team 1).hud_SkyMenuIsOpen == False;
        Is Alive(Event Player) == True;
        Event Player.bot_BotResetComplete == True;
    }
    actions
    {
        Call Subroutine(aiSub_EnableAI);
    }
}
rule("AI Ana")
{
    event
    {
        Subroutine;
        aiSub_Abilities_Ana;
    }
    actions
    {
        Event Player.ai_IsInAbilitySub = True;
        Call Subroutine(aiSub_ReactionDelay);
        If(Event Player.ai_AbilityButton == Button(Primary Fire));
            Skip If(Is Button Held(Event Player, Button(Primary Fire)), 1);
            Start Holding Button(Event Player, Button(Primary Fire));
        Else If(Event Player.ai_AbilityButton == Button(Secondary Fire));
            If(Is Button Held(Event Player, Button(Secondary Fire)));
                Stop Holding Button(Event Player, Button(Secondary Fire));
                Call Subroutine(aiSub_FacingReset);
            Else;
                Event Player.bot_MoveJumpEnabled = False;
                Start Holding Button(Event Player, Button(Secondary Fire));
                Event Player.ai_AimType = 0;
                Event Player.ai_AimBase = 0;
                Call Subroutine(aiSub_FacingStart);
            End;
        Else If(Event Player.ai_AbilityButton == Button(Ability 1));
            Call Subroutine(aiSub_ButtonsReset);
            Event Player.ai_AimType = 1;
            Event Player.ai_AimBase = 0;
            Event Player.ai_ProjectileSpeed = Event Player.ai_ProjectileSpeeds[2];
            Call Subroutine(aiSub_FacingStart);
            Press Button(Event Player, Button(Ability 1));
            Wait(0.300, Ignore Condition);
            Call Subroutine(aiSub_FacingReset);
        Else If(Event Player.ai_AbilityButton == Button(Ability 2));
            Call Subroutine(aiSub_ButtonsReset);
            If(Event Player.ai_AbilityOpt == 0);
                Event Player.ai_AimType = 2;
                Event Player.ai_AimBase = 2;
                Event Player.ai_ProjectileSpeed = Event Player.ai_ProjectileSpeeds[3];
                Call Subroutine(aiSub_FacingStart);
                Wait(Random Real(0.300, 0.400), Ignore Condition);
                Press Button(Event Player, Button(Ability 2));
                Wait(0.250, Ignore Condition);
                Call Subroutine(aiSub_FacingReset);
            Else If(Event Player.ai_AbilityOpt == 1);
                Event Player.ai_LookAtVector = Position Of(Event Player) + World Vector Of(Vector(0, 0, 0.250), Event Player, Rotation);
                Call Subroutine(aiSub_FacingLookAt);
                Press Button(Event Player, Button(Ability 2));
                Wait(0.100, Ignore Condition);
                Event Player.ai_CanAim = True;
            End;
            Event Player.ai_AimType = 1;
        Else If(Event Player.ai_AbilityButton == Button(Ultimate));
            Press Button(Event Player, Button(Ultimate));
        End;
        Event Player.ai_IsInAbilitySub = False;
    }
}
rule("AI Ana General")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Ana;
    }
    conditions
    {
        Is Game In Progress == True;
        Is Alive(Event Player) == True;
        Event Player.ai_AIEnabled == True;
    }
    actions
    {
        Event Player.ai_OptimalDistanceDefault = Random Real(15, 20);
        Event Player.ai_OptimalDistance = Event Player.ai_OptimalDistanceDefault;
        Event Player.ai_AimBaseDefault = 0;
        Event Player.ai_AimTypeDefault = 1;
        Event Player.ai_AimDistanceMod = -5;
        Event Player.ai_ProjectileSpeeds[0] = 125;
        Event Player.ai_ProjectileSpeeds[2] = 60;
        Event Player.ai_ProjectileSpeeds[3] = 30;
        Call Subroutine(aiSub_FacingReset);
        Event Player.ai_HeroInitialized = True;
    }
}
rule("AI Ana Scope In")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Ana;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 50;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) >= 15;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 12.500 + Event Player.ai_ViewAngleMod) == True;
        Is Button Held(Event Player, Button(Secondary Fire)) == False;
        Has Status(Players In Slot(Slot Of(Event Player), Team 1), Asleep) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Secondary Fire);
        Call Subroutine(aiSub_Abilities_Ana);
    }
}
rule("AI Ana Scope Out")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Ana;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) < 15;
        Is Button Held(Event Player, Button(Secondary Fire)) == True;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Secondary Fire);
        Call Subroutine(aiSub_Abilities_Ana);
    }
}
rule("AI Ana Attack")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Ana;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 50;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 10 + Event Player.ai_ViewAngleMod) == True;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Primary Fire);
        Call Subroutine(aiSub_Abilities_Ana);
        Wait(0.800, Ignore Condition);
        Loop If Condition Is True;
        Stop Holding Button(Event Player, Button(Primary Fire));
    }
}
rule("AI Ana Sleep Dart")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Ana;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) < 15;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 5 + Event Player.ai_ViewAngleMod) == True;
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
        Is Using Ability 1(Event Player) == False;
        Is Using Ability 2(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 1);
        Call Subroutine(aiSub_Abilities_Ana);
    }
}
rule("AI Ana Sleep Dart Face Enemy Asleep")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Ana;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAim == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Has Status(Players In Slot(Slot Of(Event Player), Team 1), Asleep) == True;
    }
    actions
    {
        Call Subroutine(aiSub_ReactionDelay);
        Event Player.ai_AimType = 1;
        Event Player.ai_AimBase = 3;
        Event Player.ai_FacingRelPosMod = Vector(0, 0.250, 0);
        Call Subroutine(aiSub_FacingStart);
        If(Ability Cooldown(Event Player, Button(Ability 2)) <= 4 && Ability Cooldown(Event Player, Button(Ability 2)) > 0);
            Event Player.ai_CanAttack = False;
            Wait Until(Ability Cooldown(Event Player, Button(Ability 2)) == 0, 4);
            Event Player.ai_CanAttack = True;
        End;
        Wait Until(Has Status(Players In Slot(Slot Of(Event Player), Team 1), Asleep) == False, 6);
        Call Subroutine(aiSub_FacingReset);
    }
}
rule("AI Ana Biotic Grenade")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Ana;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 35;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 10 + Event Player.ai_ViewAngleMod) == True;
        Ability Cooldown(Event Player, Button(Ability 2)) == 0;
        Is Using Ability 1(Event Player) == False;
        Is Using Ability 2(Event Player) == False;
        Health(Event Player) > 100;
        Is On Ground(Event Player) == True;
        Altitude Of(Players In Slot(Slot Of(Event Player), Team 1)) <= 2;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 2);
        Event Player.ai_AbilityOpt = 0;
        Call Subroutine(aiSub_Abilities_Ana);
    }
}
rule("AI Ana Biotic Grenade Self")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Ana;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Health(Event Player) <= 100;
        Ability Cooldown(Event Player, Button(Ability 2)) == 0;
        Is Using Ability 1(Event Player) == False;
        Is Using Ability 2(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 2);
        Event Player.ai_AbilityOpt = 1;
        Call Subroutine(aiSub_Abilities_Ana);
    }
}
rule("AI Ana Nano Boost")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Ana;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= Event Player.ai_OptimalDistance;
        Ultimate Charge Percent(Event Player) == 100;
        Is Using Ultimate(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ultimate);
        Call Subroutine(aiSub_Abilities_Ana);
    }
}
rule("AI Ashe")
{
    event
    {
        Subroutine;
        aiSub_Abilities_Ashe;
    }
    actions
    {
        Event Player.ai_IsInAbilitySub = True;
        Call Subroutine(aiSub_ReactionDelay);
        If(Event Player.ai_AbilityButton == Button(Primary Fire));
            If(Event Player.ai_AimType != 0 || Event Player.ai_AimBase != 0);
                Event Player.ai_AimType = 0;
                Event Player.ai_AimBase = 0;
                Call Subroutine(aiSub_FacingStart);
            End;
            Press Button(Event Player, Button(Primary Fire));
        Else If(Event Player.ai_AbilityButton == Button(Secondary Fire));
            If(Is Button Held(Event Player, Button(Secondary Fire)));
                Stop Holding Button(Event Player, Button(Secondary Fire));
            Else;
                Start Holding Button(Event Player, Button(Secondary Fire));
                Wait(0.250, Ignore Condition);
            End;
        Else If(Event Player.ai_AbilityButton == Button(Reload));
            Call Subroutine(aiSub_ButtonsReset);
            Press Button(Event Player, Button(Reload));
            Wait Until(Ammo(Event Player, 0) == Random Integer(8, Max Ammo(Event Player, 0)), 3.500);
        Else If(Event Player.ai_AbilityButton == Button(Ability 1));
            Press Button(Event Player, Button(Ability 1));
            Wait(0.100, Ignore Condition);
            Wait Until(Is Using Ability 1(Event Player) == False, 1);
        Else If(Event Player.ai_AbilityButton == Button(Ability 2));
            Event Player.ai_AimType = 2;
            Event Player.ai_AimBase = 2;
            Event Player.ai_ProjectileSpeed = Event Player.ai_ProjectileSpeeds[3];
            Event Player.ai_AimDistanceMod = 0;
            Call Subroutine(aiSub_FacingStart);
            Wait(Random Real(0.300, 0.400), Ignore Condition);
            Press Button(Event Player, Button(Ability 2));
            Wait(0.250, Ignore Condition);
            Call Subroutine(aiSub_FacingReset);
        Else If(Event Player.ai_AbilityButton == Button(Ultimate));
            Press Button(Event Player, Button(Ultimate));
            Wait(0.250, Ignore Condition);
        End;
        Event Player.ai_IsInAbilitySub = False;
    }
}
rule("AI Ashe General")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Ashe;
    }
    conditions
    {
        Is Game In Progress == True;
        Is Alive(Event Player) == True;
        Event Player.ai_AIEnabled == True;
    }
    actions
    {
        Event Player.ai_OptimalDistanceDefault = Random Real(15, 25);
        Event Player.ai_OptimalDistance = Event Player.ai_OptimalDistanceDefault;
        Event Player.ai_AimBaseDefault = 0;
        Event Player.ai_AimTypeDefault = 0;
        Event Player.ai_ProjectileSpeeds[3] = 25;
        Call Subroutine(aiSub_FacingReset);
        Event Player.ai_HeroInitialized = True;
    }
}
rule("AI Ashe Attack Scope In")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Ashe;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAim == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) >= 7.500;
        Is Reloading(Event Player) == False;
        Is Firing Secondary(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Secondary Fire);
        Call Subroutine(aiSub_Abilities_Ashe);
    }
}
rule("AI Ashe Attack Scope Out")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Ashe;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAim == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) < 7.500;
        Is Firing Secondary(Event Player) == True;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Secondary Fire);
        Call Subroutine(aiSub_Abilities_Ashe);
    }
}
rule("AI Ashe Attack Scoped")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Ashe;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAim == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 10 + Event Player.ai_ViewAngleMod) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 50;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) >= 7.500;
        Is Reloading(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Primary Fire);
        Call Subroutine(aiSub_Abilities_Ashe);
        Wait(0.700, Ignore Condition);
        Loop If Condition Is True;
        Stop Holding Button(Event Player, Button(Secondary Fire));
    }
}
rule("AI Ashe Attack Unscoped")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Ashe;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAim == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.ai_ViewAngleMod) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) < 7.500;
        Is Button Held(Event Player, Button(Secondary Fire)) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Primary Fire);
        Call Subroutine(aiSub_Abilities_Ashe);
        Wait(0.250, Ignore Condition);
        Loop If Condition Is True;
    }
}
rule("AI Ashe Reload")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Ashe;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Ammo(Event Player, 0) == 0;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Reload);
        Call Subroutine(aiSub_Abilities_Ashe);
    }
}
rule("AI Ashe Reload After Kill")
{
    event
    {
        Player Dealt Final Blow;
        Team 2;
        Ashe;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Reload);
        Call Subroutine(aiSub_Abilities_Ashe);
    }
}
rule("AI Ashe Coach Gun Defensive")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Ashe;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 9.400;
        Health(Event Player) <= 125;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 1);
        Call Subroutine(aiSub_Abilities_Ashe);
    }
}
rule("AI Ashe Coach Gun Finishing")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Ashe;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 5;
        Health(Players In Slot(Slot Of(Event Player), Team 1)) < 90;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 1);
        Call Subroutine(aiSub_Abilities_Ashe);
    }
}
rule("AI Ashe Dynamite")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Ashe;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAim == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 30;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.ai_ViewAngleMod) == True;
        Ability Cooldown(Event Player, Button(Ability 2)) == 0;
        Altitude Of(Players In Slot(Slot Of(Event Player), Team 1)) <= 2;
        Is Reloading(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 2);
        Call Subroutine(aiSub_Abilities_Ashe);
    }
}
rule("AI Ashe B.O.B.")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Ashe;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 10;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 10 + Event Player.ai_ViewAngleMod) == True;
        Ultimate Charge Percent(Event Player) == 100;
        Is Using Ultimate(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ultimate);
        Call Subroutine(aiSub_Abilities_Ashe);
    }
}
rule("AI Baptiste")
{
    event
    {
        Subroutine;
        aiSub_Abilities_Baptiste;
    }
    actions
    {
        Event Player.ai_IsInAbilitySub = True;
        Call Subroutine(aiSub_ReactionDelay);
        If(Event Player.ai_AbilityButton == Button(Primary Fire));
            Skip If(Is Button Held(Event Player, Button(Primary Fire)), 2);
            Call Subroutine(aiSub_ButtonsReset);
            Start Holding Button(Event Player, Button(Primary Fire));
        Else If(Event Player.ai_AbilityButton == Button(Reload));
            Press Button(Event Player, Button(Reload));
            Wait Until(Ammo(Event Player, 0) == Max Ammo(Event Player, 0), 1.500);
        Else If(Event Player.ai_AbilityButton == Button(Ability 1));
            Call Subroutine(aiSub_ButtonsReset);
            Press Button(Event Player, Button(Ability 1));
        Else If(Event Player.ai_AbilityButton == Button(Ability 2));
            Call Subroutine(aiSub_ButtonsReset);
            Event Player.ai_LookAtVector = Position Of(Event Player);
            Call Subroutine(aiSub_FacingLookAt);
            Press Button(Event Player, Button(Ability 2));
            Call Subroutine(aiSub_ReactionDelay);
            Event Player.ai_CanAim = True;
        Else If(Event Player.ai_AbilityButton == Button(Ultimate));
            Call Subroutine(aiSub_ButtonsReset);
            Press Button(Event Player, Button(Ultimate));
            Event Player.ai_LookAtVector = Position Of(Event Player) + World Vector Of(Vector(0, 0, 3), Event Player, Rotation);
            Call Subroutine(aiSub_FacingLookAt);
            Press Button(Event Player, Button(Primary Fire));
            Call Subroutine(aiSub_ReactionDelay);
            Event Player.ai_CanAim = True;
        End;
        Event Player.ai_IsInAbilitySub = False;
    }
}
rule("AI Baptiste General")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Baptiste;
    }
    conditions
    {
        Is Game In Progress == True;
        Is Alive(Event Player) == True;
        Event Player.ai_AIEnabled == True;
    }
    actions
    {
        Event Player.ai_OptimalDistanceDefault = Random Real(14, 18);
        Event Player.ai_OptimalDistance = Event Player.ai_OptimalDistanceDefault;
        Event Player.ai_AimBaseDefault = 0;
        Event Player.ai_AimBase = Event Player.ai_AimBaseDefault;
        Event Player.ai_AimType = 0;
        Event Player.ai_HeroInitialized = True;
    }
}
rule("AI Baptiste Attack")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Baptiste;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 40;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.ai_ViewAngleMod) == True;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Primary Fire);
        Call Subroutine(aiSub_Abilities_Baptiste);
        Wait(0.580, Ignore Condition);
        Loop If Condition Is True;
        Stop Holding Button(Event Player, Button(Primary Fire));
    }
}
rule("AI Baptiste Reload")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Baptiste;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Ammo(Event Player, 0) <= 0;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Reload);
        Call Subroutine(aiSub_Abilities_Baptiste);
    }
}
rule("AI Baptiste Regenerative Burst")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Baptiste;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
        Is Using Ability 1(Event Player) == False;
        Health(Event Player) <= 100;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 1);
        Call Subroutine(aiSub_Abilities_Baptiste);
    }
}
rule("AI Baptiste Immortality Field")
{
    event
    {
        Player Took Damage;
        Team 2;
        Baptiste;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Ability Cooldown(Event Player, Button(Ability 2)) == 0;
        Is Using Ability 2(Event Player) == False;
        Health(Event Player) <= 75;
        Altitude Of(Event Player) < 3;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 2);
        Call Subroutine(aiSub_Abilities_Baptiste);
    }
}
rule("AI Baptiste Amplification Matrix")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Baptiste;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Ultimate Charge Percent(Event Player) == 100;
        Is Using Ultimate(Event Player) == False;
        Altitude Of(Event Player) == 0;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ultimate);
        Call Subroutine(aiSub_Abilities_Baptiste);
    }
}
rule("AI Bastion")
{
    event
    {
        Subroutine;
        aiSub_Abilities_Bastion;
    }
    actions
    {
        Event Player.ai_IsInAbilitySub = True;
        Call Subroutine(aiSub_ReactionDelay);
        If(Event Player.ai_AbilityButton == Button(Primary Fire));
            Skip If(Is Button Held(Event Player, Button(Primary Fire)), 2);
            Call Subroutine(aiSub_ButtonsReset);
            Start Holding Button(Event Player, Button(Primary Fire));
        Else If(Event Player.ai_AbilityButton == Button(Secondary Fire));
            Start Holding Button(Event Player, Button(Secondary Fire));
            Wait((Max Health(Event Player) - Health(Event Player)) / 75, Ignore Condition);
            Stop Holding Button(Event Player, Button(Secondary Fire));
        Else If(Event Player.ai_AbilityButton == Button(Ability 1));
            Press Button(Event Player, Button(Ability 1));
        Else If(Event Player.ai_AbilityButton == Button(Ability 2));
        Else If(Event Player.ai_AbilityButton == Button(Ultimate));
            Event Player.ai_AimType = 1;
            Event Player.ai_ProjectileSpeed = Event Player.ai_ProjectileSpeeds[4];
            Press Button(Event Player, Button(Ultimate));
            Event Player.ai_AimBase = 2;
            Wait(0.250, Ignore Condition);
        End;
        Event Player.ai_IsInAbilitySub = False;
    }
}
rule("AI Bastion General")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Bastion;
    }
    conditions
    {
        Is Game In Progress == True;
        Is Alive(Event Player) == True;
        Event Player.ai_AIEnabled == True;
    }
    actions
    {
        Event Player.ai_OptimalDistanceDefault = Random Real(18, 22);
        Event Player.ai_OptimalDistance = Event Player.ai_OptimalDistanceDefault;
        Event Player.ai_AimBaseDefault = 0;
        Event Player.ai_AimBase = Event Player.ai_AimBaseDefault;
        Event Player.ai_AimType = 0;
        Event Player.ai_ProjectileSpeeds[4] = 60;
        Event Player.ai_HeroInitialized = True;
    }
}
rule("AI Bastion Attack")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Bastion;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 40;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.ai_ViewAngleMod) == True;
        Is Using Ability 1(Event Player) == False;
        Is Firing Secondary(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Primary Fire);
        Call Subroutine(aiSub_Abilities_Bastion);
        Wait(0.500, Ignore Condition);
        Loop If Condition Is True;
        Stop Holding Button(Event Player, Button(Primary Fire));
    }
}
rule("AI Bastion Reconfigure")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Bastion;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= Event Player.ai_OptimalDistance;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.ai_ViewAngleMod) == True;
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
        Is Using Ability 1(Event Player) == False;
        Is Moving(Event Player) == True;
    }
    actions
    {
        If(Random Real(0, 1) < 0.350 + Event Player.ai_ChanceMod);
            Event Player.ai_AbilityButton = Button(Ability 1);
            Call Subroutine(aiSub_Abilities_Bastion);
        End;
    }
}
rule("AI Bastion Self-Repair")
{
    event
    {
        Player Took Damage;
        Team 2;
        Bastion;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Health(Event Player) <= Max Health(Event Player) / 2;
        Is Firing Secondary(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Secondary Fire);
        Call Subroutine(aiSub_Abilities_Bastion);
    }
}
rule("AI Bastion Configuration: Tank")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Bastion;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Ultimate Charge Percent(Event Player) == 100;
        Is Using Ultimate(Event Player) == False;
        Health(Event Player) >= 100;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ultimate);
        Call Subroutine(aiSub_Abilities_Bastion);
        Wait Until(Is Using Ultimate(Event Player) == False, 8);
        Event Player.ai_AimType = 0;
        Event Player.ai_AimBase = 0;
    }
}
rule("AI Brigitte")
{
    event
    {
        Subroutine;
        aiSub_Abilities_Brigitte;
    }
    actions
    {
        Event Player.ai_IsInAbilitySub = True;
        Call Subroutine(aiSub_ReactionDelay);
        If(Event Player.ai_AbilityButton == Button(Primary Fire));
            If(Event Player.ai_AbilityOpt == 0);
                Skip If(Is Button Held(Event Player, Button(Primary Fire)), 2);
                Start Holding Button(Event Player, Button(Primary Fire));
                Wait(0.200, Ignore Condition);
            Else If(Event Player.ai_AbilityOpt == 1);
                Stop Holding Button(Event Player, Button(Primary Fire));
                Start Holding Button(Event Player, Button(Secondary Fire));
                Wait(Random Real(0.100, 0.150), Ignore Condition);
                Press Button(Event Player, Button(Primary Fire));
                Wait(0.100, Ignore Condition);
                Stop Holding Button(Event Player, Button(Secondary Fire));
            Else If(Event Player.ai_AbilityOpt == 2);
                Event Player.bot_MoveJumpEnabled = False;
                Event Player.bot_MoveCrouchEnabled = False;
                Event Player.bot_MoveWASDEnabled = False;
                Start Throttle In Direction(Event Player, Forward, 1, To Player, Replace existing throttle, Direction and Magnitude);
                Start Holding Button(Event Player, Button(Secondary Fire));
                Wait(Random Real(0.150, 0.250), Ignore Condition);
                Press Button(Event Player, Button(Primary Fire));
                Wait(0.150, Ignore Condition);
                Start Holding Button(Event Player, Button(Jump));
                Wait(0.500, Ignore Condition);
                Stop Holding Button(Event Player, Button(Secondary Fire));
                Stop Holding Button(Event Player, Button(Jump));
                Stop Throttle In Direction(Event Player);
                Event Player.bot_MoveWASDEnabled = True;
                Event Player.bot_MoveJumpEnabled = True;
                Event Player.bot_MoveCrouchEnabled = True;
            End;
        Else If(Event Player.ai_AbilityButton == Button(Secondary Fire));
            Stop Holding Button(Event Player, Button(Primary Fire));
            Skip If(Is Button Held(Event Player, Button(Secondary Fire)), 1);
            Start Holding Button(Event Player, Button(Secondary Fire));
            Wait(Random Real(0.500, 2), Ignore Condition);
            Stop Holding Button(Event Player, Button(Secondary Fire));
        Else If(Event Player.ai_AbilityButton == Button(Ability 1));
            Call Subroutine(aiSub_ButtonsReset);
            Event Player.ai_AimType = 1;
            Wait(Random Real(0.100, 0.200), Ignore Condition);
            Press Button(Event Player, Button(Ability 1));
            Wait(Random Real(0.100, 0.200), Ignore Condition);
            Event Player.ai_AimType = 0;
        Else If(Event Player.ai_AbilityButton == Button(Ability 2));
        Else If(Event Player.ai_AbilityButton == Button(Ultimate));
            Press Button(Event Player, Button(Ultimate));
        End;
        Event Player.ai_IsInAbilitySub = False;
    }
}
rule("AI Brigitte General")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Brigitte;
    }
    conditions
    {
        Is Game In Progress == True;
        Is Alive(Event Player) == True;
        Event Player.ai_AIEnabled == True;
    }
    actions
    {
        Event Player.ai_OptimalDistanceDefault = Random Real(3, 6);
        Event Player.ai_OptimalDistance = Event Player.ai_OptimalDistanceDefault;
        Event Player.ai_StrafeDistanceMod = 0;
        Event Player.ai_AimBaseDefault = 0;
        Event Player.ai_AimBase = Event Player.ai_AimBaseDefault;
        Event Player.ai_AimType = 0;
        Event Player.ai_ProjectileSpeeds[2] = 80;
        Event Player.ai_HeroInitialized = True;
    }
}
rule("AI Brigitte Attack")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Brigitte;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 8;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 90 + Event Player.ai_ViewAngleMod) == True;
        Is Firing Secondary(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Primary Fire);
        Event Player.ai_AbilityOpt = 0;
        Call Subroutine(aiSub_Abilities_Brigitte);
        Wait(0.600, Ignore Condition);
        Loop If Condition Is True;
        Stop Holding Button(Event Player, Button(Primary Fire));
    }
}
rule("AI Brigitte Use Shield")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Brigitte;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Is In View Angle(Players In Slot(Slot Of(Event Player), Team 1), Event Player, 10 + Event Player.ai_ViewAngleMod) == True;
        (Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) > 6 || Health(Event Player) < 125) == True;
        Distance Between(Players In Slot(Slot Of(Event Player), Team 1), Players In Slot(Slot Of(Event Player), Team 1).p_HomeVector)
            < Global.c_BubbleRadius;
    }
    actions
    {
        If(Random Real(0, 1) < 0.500 + Event Player.ai_ChanceMod);
            Event Player.ai_AbilityButton = Button(Secondary Fire);
            Call Subroutine(aiSub_Abilities_Brigitte);
        End;
        Wait(0.500, Ignore Condition);
        Loop If Condition Is True;
        Stop Holding Button(Event Player, Button(Secondary Fire));
    }
}
rule("AI Brigitte Shield Bash")
{
    event
    {
        Player Dealt Damage;
        Team 2;
        Brigitte;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 40 + Event Player.ai_ViewAngleMod) == True;
        Altitude Of(Players In Slot(Slot Of(Event Player), Team 1)) <= 2;
        Altitude Of(Event Player) <= 2;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 6.850;
        Ability Cooldown(Event Player, Button(Primary Fire)) == 0;
    }
    actions
    {
        If(Random Real(0, 1) < 0.850 + Event Player.ai_ChanceMod);
            Event Player.ai_AbilityButton = Button(Primary Fire);
            Event Player.ai_AbilityOpt = 1;
            Call Subroutine(aiSub_Abilities_Brigitte);
        End;
    }
}
rule("AI Brigitte Shield Bash Gap Closer")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Brigitte;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) >= 12.500;
        Distance Between(Players In Slot(Slot Of(Event Player), Team 1), Players In Slot(Slot Of(Event Player), Team 1).p_HomeVector)
            < Global.c_BubbleRadius;
        Ability Cooldown(Event Player, Button(Primary Fire)) == 0;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Primary Fire);
        Event Player.ai_AbilityOpt = 2;
        Call Subroutine(aiSub_Abilities_Brigitte);
    }
}
rule("AI Brigitte Whip Shot Final")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Brigitte;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 7.500 + Event Player.ai_ViewAngleMod) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 20;
        Health(Players In Slot(Slot Of(Event Player), Team 1)) <= 70;
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 1);
        Call Subroutine(aiSub_Abilities_Brigitte);
    }
}
rule("AI Brigitte Whip Shot Boop")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Brigitte;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 7.500 + Event Player.ai_ViewAngleMod) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 10;
        Health(Players In Slot(Slot Of(Event Player), Team 1)) > 100;
        Health(Event Player) < 100;
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 1);
        Call Subroutine(aiSub_Abilities_Brigitte);
    }
}
rule("AI Brigitte Rally")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Brigitte;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 45 + Event Player.ai_ViewAngleMod) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 15;
        Health(Event Player) >= 75;
        Ultimate Charge Percent(Event Player) == 100;
        Is Using Ultimate(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ultimate);
        Call Subroutine(aiSub_Abilities_Brigitte);
    }
}
rule("AI Doomfist")
{
    event
    {
        Subroutine;
        aiSub_Abilities_Doomfist;
    }
    actions
    {
        Event Player.ai_IsInAbilitySub = True;
        Call Subroutine(aiSub_ReactionDelay);
        If(Event Player.ai_AbilityButton == Button(Secondary Fire));
            If(Event Player.ai_AbilityOpt == 0);
                Start Holding Button(Event Player, Button(Secondary Fire));
                Event Player.bot_MoveJumpEnabled = False;
                Wait(Random Real(0.900, 1.800), Ignore Condition);
                Stop Holding Button(Event Player, Button(Secondary Fire));
            Else If(Event Player.ai_AbilityOpt == 1);
                Start Holding Button(Event Player, Button(Secondary Fire));
                Wait(Random Real(0.750, 1.500), Ignore Condition);
                Stop Holding Button(Event Player, Button(Secondary Fire));
                Wait(Random Real(0.100, 0.250), Ignore Condition);
                Press Button(Event Player, Button(Jump));
            End;
        Else If(Event Player.ai_AbilityButton == Button(Ability 1));
            Press Button(Event Player, Button(Ability 1));
        Else If(Event Player.ai_AbilityButton == Button(Ability 2));
            Press Button(Event Player, Button(Jump));
            Event Player.ai_AimBase = 2;
            Call Subroutine(aiSub_FacingStart);
            Call Subroutine(aiSub_ReactionDelay);
            Press Button(Event Player, Button(Ability 2));
            Wait(0.250, Ignore Condition);
            Call Subroutine(aiSub_FacingReset);
        Else If(Event Player.ai_AbilityButton == Button(Ultimate));
            Press Button(Event Player, Button(Ultimate));
            Event Player.ai_AimBase = 2;
            Call Subroutine(aiSub_FacingStart);
            Event Player.ai_OptimalDistance = 0;
            While(Is Using Ultimate(Event Player));
                Wait(10 / 60, Ignore Condition);
                If(Distance Between(Vector(X Component Of(Position Of(Event Player)), 0, Z Component Of(Position Of(Event Player))), Vector(
                    X Component Of(Position Of(Players In Slot(Slot Of(Event Player), Team 1))), 0, Z Component Of(Position Of(Players In Slot(
                    Slot Of(Event Player), Team 1))))) <= 2);
                    Press Button(Event Player, Button(Primary Fire));
                End;
            End;
            Event Player.ai_OptimalDistance = Event Player.ai_OptimalDistanceDefault;
            Call Subroutine(aiSub_FacingReset);
        End;
        Event Player.ai_IsInAbilitySub = False;
    }
}
rule("AI Doomfist General")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Doomfist;
    }
    conditions
    {
        Is Game In Progress == True;
        Is Alive(Event Player) == True;
        Event Player.ai_AIEnabled == True;
    }
    actions
    {
        Event Player.ai_OptimalDistanceDefault = Random Real(3, 6);
        Event Player.ai_OptimalDistance = Event Player.ai_OptimalDistanceDefault;
        Event Player.ai_StrafeDistanceMod = 3;
        Event Player.ai_AimTypeDefault = 1;
        Event Player.ai_AimBaseDefault = 0;
        Event Player.ai_ProjectileSpeed = 80;
        Event Player.ai_HeroInitialized = True;
    }
}
rule("AI Doomfist Attack")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Doomfist;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 15;
        Is In View Angle(Event Player, Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250 + Y Component Of(
            Eye Position(Event Player)), 0), 17.5) == True;
        Is Firing Secondary(Event Player) == False;
        Ammo(Event Player, 0) > 0;
        Is Using Ultimate(Event Player) == False;
    }
    actions
    {
        Skip If(Is Button Held(Event Player, Button(Primary Fire)), 1);
        Start Holding Button(Event Player, Button(Primary Fire));
        Wait(0.333, Ignore Condition);
        Loop If Condition Is True;
        Stop Holding Button(Event Player, Button(Primary Fire));
    }
}
rule("AI Doomfist Rocket Punch")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Doomfist;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Health(Players In Slot(Slot Of(Event Player), Team 1)) >= 50;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 12.500;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.ai_ViewAngleMod) == True;
        Ability Cooldown(Event Player, Button(Secondary Fire)) == 0;
        (Ability Cooldown(Event Player, Button(Ability 1)) == 0 ? Distance Between(Event Player, Players In Slot(Slot Of(Event Player),
            Team 1)) > 5 : True) == True;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Secondary Fire);
        Event Player.ai_AbilityOpt = 0;
        Call Subroutine(aiSub_Abilities_Doomfist);
        Wait Until(Speed Of(Event Player) < 45, 2);
        Event Player.bot_MoveJumpEnabled = True;
    }
}
rule("AI Doomfist Rocket Punch Gap Closer")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Doomfist;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) >= Event Player.ai_OptimalDistance * 3.500;
        Distance Between(Players In Slot(Slot Of(Event Player), Team 1), Players In Slot(Slot Of(Event Player), Team 1).p_HomeVector)
            < Global.c_BubbleRadius;
        Ability Cooldown(Event Player, Button(Secondary Fire)) == 0;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Secondary Fire);
        Event Player.ai_AbilityOpt = 1;
        Call Subroutine(aiSub_Abilities_Doomfist);
    }
}
rule("AI Doomfist Uppercut")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Doomfist;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 5;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.ai_ViewAngleMod) == True;
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
        Is Button Held(Event Player, Button(Secondary Fire)) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 1);
        Call Subroutine(aiSub_Abilities_Doomfist);
    }
}
rule("AI Doomfist Seismic Slam")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Doomfist;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        (Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) >= 2 || Is In Air(Event Player)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 14;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.ai_ViewAngleMod) == True;
        Is Button Held(Event Player, Button(Secondary Fire)) == False;
        Ability Cooldown(Event Player, Button(Ability 2)) == 0;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 2);
        Call Subroutine(aiSub_Abilities_Doomfist);
    }
}
rule("AI Doomfist Meteor Strike")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Doomfist;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Ultimate Charge Percent(Event Player) == 100;
        Is Using Ultimate(Event Player) == False;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 20;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 20 + Event Player.ai_ViewAngleMod) == True;
        Health(Players In Slot(Slot Of(Event Player), Team 1)) > 100;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) > 1.500;
        Is Button Held(Event Player, Button(Secondary Fire)) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ultimate);
        Call Subroutine(aiSub_Abilities_Doomfist);
    }
}
rule("AI D.Va")
{
    event
    {
        Subroutine;
        aiSub_Abilities_DVa;
    }
    actions
    {
        Event Player.ai_IsInAbilitySub = True;
        Call Subroutine(aiSub_ReactionDelay);
        If(Event Player.ai_AbilityButton == Button(Secondary Fire));
            Call Subroutine(aiSub_ButtonsReset);
            Start Holding Button(Event Player, Button(Secondary Fire));
            Wait Until(Is Firing Secondary(Event Player), 0.100);
            Wait Until(Is Firing Secondary(Event Player) == False, Random Real(0.500, 1.250));
            Stop Holding Button(Event Player, Button(Secondary Fire));
        Else If(Event Player.ai_AbilityButton == Button(Ability 2));
            Event Player.ai_AimType = 1;
            Event Player.ai_ProjectileSpeed = Event Player.ai_ProjectileSpeeds[3];
            Press Button(Event Player, Button(Ability 2));
            Wait Until(Is Using Ability 2(Event Player), 0.100);
            Wait Until(Is Using Ability 2(Event Player) == False, 2);
            Event Player.ai_AimType = 0;
            Call Subroutine(aiSub_FacingReset);
        Else If(Event Player.ai_AbilityButton == Button(Ultimate));
            Call Subroutine(aiSub_ButtonsReset);
            If(Event Player.ai_AbilityOpt == 0);
                If(Ability Cooldown(Event Player, Button(Ability 1)) == 0);
                    Event Player.ai_AimType = 2;
                    Event Player.ai_AimBase = 2;
                    Event Player.ai_ProjectileSpeed = Event Player.ai_ProjectileSpeeds[4];
                    Event Player.ai_AimDistanceMod = -10;
                    Call Subroutine(aiSub_FacingStart);
                    Call Subroutine(aiSub_ReactionDelay);
                    Press Button(Event Player, Button(Ability 1));
                    Call Subroutine(aiSub_ReactionDelay);
                    Press Button(Event Player, Button(Ultimate));
                    Call Subroutine(aiSub_ReactionDelay);
                    Call Subroutine(aiSub_FacingReset);
                Else;
                    Press Button(Event Player, Button(Ultimate));
                End;
                Wait Until(Is In Alternate Form(Event Player), 1.500);
            Else If(Event Player.ai_AbilityOpt == 1);
                Wait(3.500, Ignore Condition);
                Press Button(Event Player, Button(Ultimate));
            End;
        End;
        Event Player.ai_IsInAbilitySub = False;
    }
}
rule("AI D.Va General")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        D.Va;
    }
    conditions
    {
        Is Game In Progress == True;
        Is Alive(Event Player) == True;
        Event Player.ai_AIEnabled == True;
    }
    actions
    {
        Event Player.ai_OptimalDistanceDefault = Random Real(4, 8);
        Event Player.ai_OptimalDistance = Event Player.ai_OptimalDistanceDefault;
        Event Player.ai_AimBaseDefault = 0;
        Event Player.ai_AimBase = Event Player.ai_AimBaseDefault;
        Event Player.ai_AimType = 0;
        Event Player.ai_ProjectileSpeeds[0] = 50;
        Event Player.ai_ProjectileSpeeds[3] = 40;
        Event Player.ai_ProjectileSpeeds[4] = 12;
        Event Player.ai_HeroInitialized = True;
    }
}
rule("AI D.Va Attack")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        D.Va;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 30;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 25 + Event Player.ai_ViewAngleMod) == True;
        Is Firing Secondary(Event Player) == False;
    }
    actions
    {
        Skip If(Is Button Held(Event Player, Button(Primary Fire)), 2);
        Call Subroutine(aiSub_ButtonsReset);
        Start Holding Button(Event Player, Button(Primary Fire));
        Wait(0.250, Abort When False);
        Loop If Condition Is True;
        Stop Holding Button(Event Player, Button(Primary Fire));
    }
}
rule("AI D.Va Defense Matrix")
{
    event
    {
        Player Took Damage;
        Team 2;
        D.Va;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Is In Alternate Form(Event Player) == False;
        Array Contains(Global.c_ProjectileHeroes, Hero Of(Attacker)) == True;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 60 + Event Player.ai_ViewAngleMod) == True;
        Is In View Angle(Players In Slot(Slot Of(Event Player), Team 1), Event Player, 10 + Event Player.ai_ViewAngleMod) == True;
        Ability Cooldown(Event Player, Button(Secondary Fire)) == 0;
        Is Firing Secondary(Event Player) == False;
        Ability Resource(Event Player, Button(Secondary Fire)) > 0;
    }
    actions
    {
        If(Random Real(0, 1) < 0.750 + Event Player.ai_ChanceMod);
            Event Player.ai_AbilityButton = Button(Secondary Fire);
            Call Subroutine(aiSub_Abilities_DVa);
        End;
    }
}
rule("AI D.Va Boosters")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        D.Va;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Is In Alternate Form(Event Player) == False;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) > 10;
        Distance Between(Players In Slot(Slot Of(Event Player), Team 1), Players In Slot(Slot Of(Event Player), Team 1).p_HomeVector)
            < Global.c_BubbleRadius;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 90 + Event Player.ai_ViewAngleMod) == True;
        Ultimate Charge Percent(Event Player) <= 95;
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
        Is Using Ability 1(Event Player) == False;
    }
    actions
    {
        Press Button(Event Player, Button(Ability 1));
        Wait Until(Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 5, 2);
        Call Subroutine(aiSub_ReactionDelay);
        Press Button(Event Player, Button(Ability 1));
    }
}
rule("AI D.Va Micro Missiles")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        D.Va;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Is In Alternate Form(Event Player) == False;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 10;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.ai_ViewAngleMod) == True;
        Ability Cooldown(Event Player, Button(Ability 2)) == 0;
        Is Using Ability 2(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 2);
        Call Subroutine(aiSub_Abilities_DVa);
    }
}
rule("AI D.Va Self-Destruct")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        D.Va;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Is In Alternate Form(Event Player) == False;
        Ultimate Charge Percent(Event Player) == 100;
        Is Using Ultimate(Event Player) == False;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 20;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ultimate);
        Event Player.ai_AbilityOpt = 0;
        Call Subroutine(aiSub_Abilities_DVa);
    }
}
rule("AI D.Va Call Mech")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        D.Va;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Ultimate Charge Percent(Event Player) == 100;
        Is Using Ultimate(Event Player) == False;
        Is In Alternate Form(Event Player) == True;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ultimate);
        Event Player.ai_AbilityOpt = 1;
        Call Subroutine(aiSub_Abilities_DVa);
    }
}
rule("AI Echo")
{
    event
    {
        Subroutine;
        aiSub_Abilities_Echo;
    }
    actions
    {
        Event Player.ai_IsInAbilitySub = True;
        Call Subroutine(aiSub_ReactionDelay);
        If(Event Player.ai_AbilityButton == Button(Primary Fire));
            If(Event Player.ai_AimType != 1 || Event Player.ai_AimBase != 0);
                Event Player.ai_AimType = 1;
                Event Player.ai_AimBase = 0;
                Call Subroutine(aiSub_FacingStart);
            End;
            Event Player.ai_ProjectileSpeed = Event Player.ai_ProjectileSpeeds[0];
            Skip If(Is Button Held(Event Player, Button(Primary Fire)), 2);
            Call Subroutine(aiSub_ButtonsReset);
            Start Holding Button(Event Player, Button(Primary Fire));
        Else If(Event Player.ai_AbilityButton == Button(Secondary Fire));
            Call Subroutine(aiSub_ButtonsReset);
            If(Event Player.ai_AimType != 1 || Event Player.ai_AimBase != 3);
                Event Player.ai_AimType = 1;
                Event Player.ai_AimBase = 3;
                Event Player.ai_FacingRelPosMod = Vector(0, 0.350, 0);
                Call Subroutine(aiSub_FacingStart);
            End;
            Event Player.ai_ProjectileSpeed = Event Player.ai_ProjectileSpeeds[1];
            Press Button(Event Player, Button(Secondary Fire));
            Wait(1, Ignore Condition);
        Else If(Event Player.ai_AbilityButton == Button(Ability 1));
            Press Button(Event Player, Button(Ability 1));
        Else If(Event Player.ai_AbilityButton == Button(Ability 2));
            If(Event Player.ai_AimType != 0 || Event Player.ai_AimBase != 0);
                Event Player.ai_AimType = 0;
                Event Player.ai_AimBase = 0;
                Call Subroutine(aiSub_FacingStart);
            End;
            Press Button(Event Player, Button(Ability 2));
            Wait Until(Is Using Ability 2(Event Player), 0.250);
            Wait Until(Is Using Ability 2(Event Player) == False, 2.500);
        Else If(Event Player.ai_AbilityButton == Button(Ultimate));
            Press Button(Event Player, Button(Ultimate));
            Wait Until(Is Using Ultimate(Event Player), 0.250);
        End;
        Event Player.ai_IsInAbilitySub = False;
    }
}
rule("AI Echo General")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Echo;
    }
    conditions
    {
        Is Game In Progress == True;
        Is Alive(Event Player) == True;
        Event Player.ai_AIEnabled == True;
    }
    actions
    {
        Event Player.ai_OptimalDistanceDefault = Random Real(9, 13);
        Event Player.ai_OptimalDistance = Event Player.ai_OptimalDistanceDefault;
        Event Player.ai_AimBaseDefault = 0;
        Event Player.ai_AimTypeDefault = 1;
        Event Player.ai_ProjectileSpeeds[0] = 75;
        Event Player.ai_ProjectileSpeeds[1] = 50;
        Call Subroutine(aiSub_FacingReset);
        Event Player.ai_HeroInitialized = True;
    }
}
rule("AI Echo Glide")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Echo;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Is Alive(Event Player) == True;
        Is In Air(Event Player) == True;
    }
    actions
    {
        Start Holding Button(Event Player, Button(Jump));
        Wait Until(Is In Air(Event Player) == False, 30);
        Stop Holding Button(Event Player, Button(Jump));
    }
}
rule("AI Echo Attack")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Echo;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 35;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.ai_ViewAngleMod) == True;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Primary Fire);
        Call Subroutine(aiSub_Abilities_Echo);
        Wait(0.330, Ignore Condition);
        Loop If Condition Is True;
        Stop Holding Button(Event Player, Button(Primary Fire));
    }
}
rule("AI Echo Flight")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Echo;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
        Is Using Ability 1(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 1);
        Call Subroutine(aiSub_Abilities_Echo);
    }
}
rule("AI Echo Focusing Beam")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Echo;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Health(Players In Slot(Slot Of(Event Player), Team 1)) <= Max Health(Players In Slot(Slot Of(Event Player), Team 1)) / 2;
        Health(Players In Slot(Slot Of(Event Player), Team 1)) >= Max Health(Players In Slot(Slot Of(Event Player), Team 1)) / 4;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 16;
        Ability Cooldown(Event Player, Button(Ability 2)) == 0;
        Is Using Ability 2(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 2);
        Call Subroutine(aiSub_Abilities_Echo);
    }
}
rule("AI Echo Sticky Bombs")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Echo;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Health(Players In Slot(Slot Of(Event Player), Team 1)) >= Max Health(Players In Slot(Slot Of(Event Player), Team 1)) / 2;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 20;
        Ability Cooldown(Event Player, Button(Secondary Fire)) == 0;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Secondary Fire);
        Call Subroutine(aiSub_Abilities_Echo);
    }
}
rule("AI Echo Duplicate")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Echo;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Ultimate Charge Percent(Event Player) == 100;
        Is Using Ultimate(Event Player) == False;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 20;
        Is In View Angle(Event Player, Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250 + Y Component Of(
            Eye Position(Event Player)), 0), 10) == True;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ultimate);
        Call Subroutine(aiSub_Abilities_Echo);
    }
}
rule("AI Genji")
{
    event
    {
        Subroutine;
        aiSub_Abilities_Genji;
    }
    actions
    {
        Event Player.ai_IsInAbilitySub = True;
        Call Subroutine(aiSub_ReactionDelay);
        If(Event Player.ai_AbilityButton == Button(Primary Fire));
            If(Is Using Ultimate(Event Player));
                Skip If(Event Player.ai_AimType == 0 && Event Player.ai_AimBase == 0, 3);
                Event Player.ai_AimType = 0;
                Event Player.ai_AimBase = 0;
                Call Subroutine(aiSub_FacingStart);
            Else;
                Skip If(Event Player.ai_AimType == 1 && Event Player.ai_AimBase == 0, 3);
                Event Player.ai_AimType = 1;
                Event Player.ai_AimBase = 0;
                Call Subroutine(aiSub_FacingStart);
            End;
            Skip If(Is Button Held(Event Player, Button(Primary Fire)), 2);
            Call Subroutine(aiSub_ButtonsReset);
            Start Holding Button(Event Player, Button(Primary Fire));
        Else If(Event Player.ai_AbilityButton == Button(Secondary Fire));
            If(Event Player.ai_AimType != 1 || Event Player.ai_AimBase != 0);
                Event Player.ai_AimType = 1;
                Event Player.ai_AimBase = 0;
                Call Subroutine(aiSub_FacingStart);
            End;
            Skip If(Is Button Held(Event Player, Button(Secondary Fire)), 2);
            Call Subroutine(aiSub_ButtonsReset);
            Start Holding Button(Event Player, Button(Secondary Fire));
        Else If(Event Player.ai_AbilityButton == Button(Ability 1));
            If(Event Player.ai_AbilityOpt == 0);
                Press Button(Event Player, Button(Ability 1));
            Else If(Event Player.ai_AbilityOpt == 1);
                Event Player.ai_AimBase = 3;
                Event Player.ai_FacingRelPosMod = Vector(0, 0.500, 0);
                Call Subroutine(aiSub_FacingStart);
                Wait(Random Real(0.100, 0.200), Ignore Condition);
                Press Button(Event Player, Button(Ability 1));
                Wait(0.100, Ignore Condition);
                Call Subroutine(aiSub_FacingReset);
            End;
        Else If(Event Player.ai_AbilityButton == Button(Ability 2));
            Press Button(Event Player, Button(Ability 2));
        Else If(Event Player.ai_AbilityButton == Button(Ultimate));
            If(Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 15 && Ability Cooldown(Event Player, Button(
                Ability 1)) != 0);
                Press Button(Event Player, Button(Ultimate));
            Else;
                Event Player.ai_LookAtVector = Vector(X Component Of(Position Of(Players In Slot(Slot Of(Event Player), Team 1))), Random Real(5,
                    15), Z Component Of(Position Of(Players In Slot(Slot Of(Event Player), Team 1))));
                Call Subroutine(aiSub_FacingLookAt);
                Press Button(Event Player, Button(Ability 1));
                Wait Until(Is Using Ability 1(Event Player) == False, 0.300);
                Event Player.ai_CanAim = True;
                Press Button(Event Player, Button(Ultimate));
            End;
            Wait Until(Is Using Ultimate(Event Player) == True, 1);
            Event Player.ai_StrafeDistanceMod = 0;
            Event Player.ai_OptimalDistance = Random Real(2, 3.500);
            Event Player.ai_AimType = 0;
            Event Player.ai_AimBase = 0;
            Call Subroutine(aiSub_FacingStart);
        End;
        Event Player.ai_IsInAbilitySub = False;
    }
}
rule("AI Genji General")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Genji;
    }
    conditions
    {
        Is Game In Progress == True;
        Is Alive(Event Player) == True;
        Event Player.ai_AIEnabled == True;
    }
    actions
    {
        Event Player.ai_OptimalDistanceDefault = Random Real(5, 10);
        Event Player.ai_OptimalDistance = Event Player.ai_OptimalDistanceDefault;
        Event Player.ai_AimBaseDefault = 0;
        Event Player.ai_AimTypeDefault = 1;
        Event Player.ai_ProjectileSpeed = 60;
        Call Subroutine(aiSub_FacingReset);
        Event Player.ai_HeroInitialized = True;
    }
}
rule("AI Genji Attack Primary")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Genji;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 35;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) >= 10;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.ai_ViewAngleMod) == True;
        Is Using Ability 1(Event Player) == False;
        Is Using Ability 2(Event Player) == False;
        Is Using Ultimate(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Primary Fire);
        Call Subroutine(aiSub_Abilities_Genji);
        Wait(0.950, Ignore Condition);
        Loop If Condition Is True;
        Stop Holding Button(Event Player, Button(Primary Fire));
    }
}
rule("AI Genji Attack Secondary")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Genji;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) < 10;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.ai_ViewAngleMod) == True;
        Is Using Ability 1(Event Player) == False;
        Is Using Ability 2(Event Player) == False;
        Is Using Ultimate(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Secondary Fire);
        Call Subroutine(aiSub_Abilities_Genji);
        Wait(0.750, Ignore Condition);
        Loop If Condition Is True;
        Stop Holding Button(Event Player, Button(Secondary Fire));
    }
}
rule("AI Genji Swift Strike Movement")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Genji;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) < 15;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.ai_ViewAngleMod) == True;
        Is Using Ability 2(Event Player) == False;
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
        Is Using Ultimate(Event Player) == False;
    }
    actions
    {
        If(Random Real(0, 1) < 0.350 - Event Player.ai_ChanceMod);
            Event Player.ai_AbilityButton = Button(Ability 1);
            Event Player.ai_AbilityOpt = 0;
            Call Subroutine(aiSub_Abilities_Genji);
        End;
    }
}
rule("AI Genji Swift Strike Final")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Genji;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 12.500;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.ai_ViewAngleMod) == True;
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
        Health(Players In Slot(Slot Of(Event Player), Team 1)) <= 50;
        Health(Players In Slot(Slot Of(Event Player), Team 1)) > 0;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 1);
        Event Player.ai_AbilityOpt = 0;
        Call Subroutine(aiSub_Abilities_Genji);
    }
}
rule("AI Genji Deflect")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Genji;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Is In View Angle(Players In Slot(Slot Of(Event Player), Team 1), Event Player, 5 + Event Player.ai_ViewAngleMod) == True;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.ai_ViewAngleMod) == True;
        Ability Cooldown(Event Player, Button(Ability 2)) == 0;
        Is Using Ability 2(Event Player) == False;
        Array Contains(Global.c_ProjectileHeroes, Hero Of(Players In Slot(Slot Of(Event Player), Team 1))) == True;
        Is Button Held(Players In Slot(Slot Of(Event Player), Team 1), Button(Primary Fire)) == True;
    }
    actions
    {
        If(Random Real(0, 1) < 0.550 + Event Player.ai_ChanceMod);
            Event Player.ai_AbilityButton = Button(Ability 2);
            Call Subroutine(aiSub_Abilities_Genji);
        End;
    }
}
rule("AI Genji Deflect Deadeye")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Genji;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.ai_ViewAngleMod) == True;
        Ability Cooldown(Event Player, Button(Ability 2)) == 0;
        Hero Of(Players In Slot(Slot Of(Event Player), Team 1)) == Hero(McCree);
        Is Using Ultimate(Players In Slot(Slot Of(Event Player), Team 1)) == True;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 2);
        Call Subroutine(aiSub_Abilities_Genji);
    }
}
rule("AI Genji Dragonblade")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Genji;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Ultimate Charge Percent(Event Player) == 100;
        Is Using Ultimate(Event Player) == False;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 30;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 20 + Event Player.ai_ViewAngleMod) == True;
        Is Using Ability 2(Event Player) == False;
        Health(Players In Slot(Slot Of(Event Player), Team 1)) >= 50;
        Health(Event Player) >= 75;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ultimate);
        Call Subroutine(aiSub_Abilities_Genji);
        Wait Until(Is Using Ultimate(Event Player) == False, 8);
        Event Player.ai_OptimalDistance = Event Player.ai_OptimalDistanceDefault;
        Event Player.ai_StrafeDistanceMod = Event Player.ai_OptimalDistance + 5;
    }
}
rule("AI Genji Dragonblade Swift Strike Gap Closer")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Genji;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Is Using Ultimate(Event Player) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) > 4.500;
        Distance Between(Players In Slot(Slot Of(Event Player), Team 1), Players In Slot(Slot Of(Event Player), Team 1).p_HomeVector)
            < Global.c_BubbleRadius;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 45 + Event Player.ai_ViewAngleMod) == True;
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 1);
        Event Player.ai_AbilityOpt = 1;
        Call Subroutine(aiSub_Abilities_Genji);
    }
}
rule("AI Genji Dragonblade Swing")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Genji;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 8;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 30 + Event Player.ai_ViewAngleMod) == True;
        Is Using Ability 2(Event Player) == False;
        Is Using Ultimate(Event Player) == True;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Primary Fire);
        Call Subroutine(aiSub_Abilities_Genji);
        Wait(0.900, Ignore Condition);
        Loop If Condition Is True;
        Stop Holding Button(Event Player, Button(Primary Fire));
    }
}
rule("AI Genji Double Jump")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Genji;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Is Alive(Event Player) == True;
        Is In Air(Event Player) == True;
    }
    actions
    {
        If(Random Real(0, 1) < 0.850 + Event Player.ai_ChanceMod);
            Wait(Random Real(0.150, 0.250), Ignore Condition);
            Press Button(Event Player, Button(Jump));
        End;
    }
}
rule("AI Hanzo")
{
    event
    {
        Subroutine;
        aiSub_Abilities_Hanzo;
    }
    actions
    {
        Event Player.ai_IsInAbilitySub = True;
        Call Subroutine(aiSub_ReactionDelay);
        If(Event Player.ai_AbilityButton == Button(Primary Fire));
            If(Is Using Ability 2(Event Player));
                Press Button(Event Player, Button(Primary Fire));
            Else If(Is Button Held(Event Player, Button(Primary Fire)));
                Stop Holding Button(Event Player, Button(Primary Fire));
            Else;
                Start Holding Button(Event Player, Button(Primary Fire));
                Event Player.ai_WeaponChargeTime = Total Time Elapsed;
            End;
        Else If(Event Player.ai_AbilityButton == Button(Secondary Fire));
        Else If(Event Player.ai_AbilityButton == Button(Ability 1));
            Press Button(Event Player, Button(Ability 1));
        Else If(Event Player.ai_AbilityButton == Button(Ability 2));
            Press Button(Event Player, Button(Ability 2));
        Else If(Event Player.ai_AbilityButton == Button(Ultimate));
            Press Button(Event Player, Button(Ultimate));
            Wait(0.900, Ignore Condition);
        End;
        Event Player.ai_IsInAbilitySub = False;
    }
}
rule("AI Hanzo General")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Hanzo;
    }
    conditions
    {
        Is Game In Progress == True;
        Is Alive(Event Player) == True;
        Event Player.ai_AIEnabled == True;
    }
    actions
    {
        Event Player.ai_OptimalDistanceDefault = Random Real(15, 20);
        Event Player.ai_OptimalDistance = Event Player.ai_OptimalDistanceDefault;
        Event Player.ai_AimBaseDefault = 1;
        Event Player.ai_AimTypeDefault = 2;
        Event Player.ai_AimDistanceMod = -25;
        Event Player.ai_ProjectileSpeed = 110;
        Call Subroutine(aiSub_FacingReset);
        Event Player.ai_HeroInitialized = True;
    }
}
rule("AI Hanzo Lunge")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Hanzo;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 30;
        Is In Air(Event Player) == True;
    }
    actions
    {
        If(Random Real(0, 1) < 0.600 + Event Player.ai_ChanceMod);
            Wait(Random Real(0.150, 0.250), Ignore Condition);
            Press Button(Event Player, Button(Jump));
        End;
    }
}
rule("AI Hanzo Attack Charge")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Hanzo;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Event Player.ai_HeroInitialized == True;
        Is Using Ability 2(Event Player) == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 50;
        Is Button Held(Event Player, Button(Primary Fire)) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Primary Fire);
        Call Subroutine(aiSub_Abilities_Hanzo);
    }
}
rule("AI Hanzo Attack")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Hanzo;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Event Player.ai_HeroInitialized == True;
        Is Using Ability 2(Event Player) == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Is In View Angle(Event Player, Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250 + Y Component Of(
            Eye Position(Event Player)), 0), 20) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 50;
        Is Button Held(Event Player, Button(Primary Fire)) == True;
        Total Time Elapsed >= Event Player.ai_WeaponChargeTime + 1.250;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Primary Fire);
        Call Subroutine(aiSub_Abilities_Hanzo);
    }
}
rule("AI Hanzo Sonic Arrow")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Hanzo;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 25;
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
        Is Using Ability 1(Event Player) == False;
        Is Using Ability 2(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 1);
        Call Subroutine(aiSub_Abilities_Hanzo);
    }
}
rule("AI Hanzo Storm Arrows Start")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Hanzo;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 15;
        Health(Players In Slot(Slot Of(Event Player), Team 1)) >= 100;
        Is In View Angle(Event Player, Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250 + Y Component Of(
            Eye Position(Event Player)), 0), 15) == True;
        Ability Cooldown(Event Player, Button(Ability 2)) == 0;
        Is Using Ability 2(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 2);
        Call Subroutine(aiSub_Abilities_Hanzo);
    }
}
rule("AI Hanzo Storm Arrows Fire")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Hanzo;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Is In View Angle(Event Player, Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250 + Y Component Of(
            Eye Position(Event Player)), 0), 12.500) == True;
        Is Using Ability 2(Event Player) == True;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Primary Fire);
        Call Subroutine(aiSub_Abilities_Hanzo);
        Wait(0.333, Ignore Condition);
        Loop If Condition Is True;
    }
}
rule("AI Hanzo Dragonstrike")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Hanzo;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Event Player.ai_HeroInitialized == True;
        Is Using Ability 2(Event Player) == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Is In View Angle(Event Player, Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250 + Y Component Of(
            Eye Position(Event Player)), 0), 12.500) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 30;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) >= 10;
        Ultimate Charge Percent(Event Player) == 100;
        Is Using Ultimate(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ultimate);
        Call Subroutine(aiSub_Abilities_Hanzo);
    }
}
rule("AI Junkrat")
{
    event
    {
        Subroutine;
        aiSub_Abilities_Junkrat;
    }
    actions
    {
        Event Player.ai_IsInAbilitySub = True;
        Call Subroutine(aiSub_ReactionDelay);
        If(Event Player.ai_AbilityButton == Button(Primary Fire));
            Skip If(Is Button Held(Event Player, Button(Primary Fire)), 1);
            Start Holding Button(Event Player, Button(Primary Fire));
        Else If(Event Player.ai_AbilityButton == Button(Ability 1));
            Press Button(Event Player, Button(Ability 1));
            Wait(Random Real(0.450, 0.650), Ignore Condition);
            Press Button(Event Player, Button(Secondary Fire));
        Else If(Event Player.ai_AbilityButton == Button(Ability 2));
            Event Player.ai_LookAtVector = Position Of(Event Player) + World Vector Of(Vector(Random Real(-5, 5), 0, Random Real(0, 2)),
                Event Player, Rotation);
            Call Subroutine(aiSub_FacingLookAt);
            Press Button(Event Player, Button(Ability 2));
            Call Subroutine(aiSub_ReactionDelay);
            Event Player.ai_CanAim = True;
        Else If(Event Player.ai_AbilityButton == Button(Ultimate));
            Call Subroutine(aiSub_ButtonsReset);
            Press Button(Event Player, Button(Ultimate));
            Wait(1, Ignore Condition);
            If(Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 10);
                Press Button(Event Player, Button(Primary Fire));
            Else;
                Wait(Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) / 12, Ignore Condition);
                Press Button(Event Player, Button(Primary Fire));
            End;
        End;
        Event Player.ai_IsInAbilitySub = False;
    }
}
rule("AI Junkrat General")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Junkrat;
    }
    conditions
    {
        Is Game In Progress == True;
        Is Alive(Event Player) == True;
        Event Player.ai_AIEnabled == True;
    }
    actions
    {
        Event Player.ai_OptimalDistanceDefault = Random Real(9, 12);
        Event Player.ai_OptimalDistance = Event Player.ai_OptimalDistanceDefault;
        Event Player.ai_AimBaseDefault = 0;
        Event Player.ai_AimTypeDefault = 2;
        Event Player.ai_AimDistanceMod = 10;
        Event Player.ai_ProjectileSpeed = 25;
        Call Subroutine(aiSub_FacingReset);
        Event Player.ai_HeroInitialized = True;
    }
}
rule("AI Junkrat Attack")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Junkrat;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 50;
        Is In View Angle(Event Player, Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250 + Y Component Of(
            Eye Position(Event Player)), 0), 20) == True;
        Is Using Ultimate(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Primary Fire);
        Call Subroutine(aiSub_Abilities_Junkrat);
        Wait(0.670, Ignore Condition);
        Loop If Condition Is True;
        Stop Holding Button(Event Player, Button(Primary Fire));
    }
}
rule("AI Junkrat Concussion Mine")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Junkrat;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 10;
        Is In View Angle(Event Player, Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250 + Y Component Of(
            Eye Position(Event Player)), 0), 15) == True;
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
        Ability Charge(Event Player, Button(Ability 1)) > 0;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 1);
        Call Subroutine(aiSub_Abilities_Junkrat);
    }
}
rule("AI Junkrat Steel Trap")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Junkrat;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 8;
        Is In View Angle(Event Player, Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250 + Y Component Of(
            Eye Position(Event Player)), 0), 17.500) == True;
        Ability Cooldown(Event Player, Button(Ability 2)) == 0;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 2);
        Call Subroutine(aiSub_Abilities_Junkrat);
    }
}
rule("AI Junkrat Riptire")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Junkrat;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Ultimate Charge Percent(Event Player) == 100;
        Is Using Ultimate(Event Player) == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) >= 10;
        Distance Between(Players In Slot(Slot Of(Event Player), Team 1), Players In Slot(Slot Of(Event Player), Team 1).p_HomeVector)
            < Global.c_BubbleRadius;
        Health(Players In Slot(Slot Of(Event Player), Team 1)) >= 100;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ultimate);
        Call Subroutine(aiSub_Abilities_Junkrat);
    }
}
rule("AI Lucio")
{
    event
    {
        Subroutine;
        aiSub_Abilities_Lucio;
    }
    actions
    {
        Event Player.ai_IsInAbilitySub = True;
        Call Subroutine(aiSub_ReactionDelay);
        If(Event Player.ai_AbilityButton == Button(Primary Fire));
            Skip If(Is Button Held(Event Player, Button(Primary Fire)), 2);
            Call Subroutine(aiSub_ButtonsReset);
            Start Holding Button(Event Player, Button(Primary Fire));
        Else If(Event Player.ai_AbilityButton == Button(Secondary Fire));
            Press Button(Event Player, Button(Secondary Fire));
        Else If(Event Player.ai_AbilityButton == Button(Ability 1));
            Press Button(Event Player, Button(Ability 1));
        Else If(Event Player.ai_AbilityButton == Button(Ability 2));
            Press Button(Event Player, Button(Ability 2));
        Else If(Event Player.ai_AbilityButton == Button(Ultimate));
            Press Button(Event Player, Button(Ultimate));
            Wait(0.750, Ignore Condition);
        End;
        Event Player.ai_IsInAbilitySub = False;
    }
}
rule("AI Lucio General")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Lúcio;
    }
    conditions
    {
        Is Game In Progress == True;
        Is Alive(Event Player) == True;
        Event Player.ai_AIEnabled == True;
    }
    actions
    {
        Event Player.ai_OptimalDistanceDefault = Random Real(5, 7.500);
        Event Player.ai_OptimalDistance = Event Player.ai_OptimalDistanceDefault;
        Event Player.ai_AimBaseDefault = 0;
        Event Player.ai_AimBase = Event Player.ai_AimBaseDefault;
        Event Player.ai_AimType = 1;
        Event Player.ai_ProjectileSpeed = 50;
        Event Player.ai_HeroInitialized = True;
    }
}
rule("AI Lucio Attack")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Lúcio;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 30;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 10 + Event Player.ai_ViewAngleMod) == True;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Primary Fire);
        Call Subroutine(aiSub_Abilities_Lucio);
        Wait(0.935, Ignore Condition);
        Loop If Condition Is True;
        Stop Holding Button(Event Player, Button(Primary Fire));
    }
}
rule("AI Lucio Crossfade Heal Self")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Lúcio;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
        Health(Event Player) <= 100;
        Is In Alternate Form(Event Player) == True;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 1);
        Call Subroutine(aiSub_Abilities_Lucio);
    }
}
rule("AI Lucio Crossfade Speed Self")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Lúcio;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
        Health(Event Player) > 100;
        Is In Alternate Form(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 1);
        Call Subroutine(aiSub_Abilities_Lucio);
    }
}
rule("AI Lucio Amp It Up")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Lúcio;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        (Health(Event Player) <= 75 || Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) > 15) == True;
        Distance Between(Players In Slot(Slot Of(Event Player), Team 1), Players In Slot(Slot Of(Event Player), Team 1).p_HomeVector)
            < Global.c_BubbleRadius;
        Ability Cooldown(Event Player, Button(Ability 2)) == 0;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 2);
        Call Subroutine(aiSub_Abilities_Lucio);
    }
}
rule("AI Lucio Soundwave Boop")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Lúcio;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Health(Event Player) <= 100;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 30 + Event Player.ai_ViewAngleMod) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 8;
        Ability Cooldown(Event Player, Button(Secondary Fire)) == 0;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Secondary Fire);
        Call Subroutine(aiSub_Abilities_Lucio);
    }
}
rule("AI Lucio Soundwave Final")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Lúcio;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Health(Players In Slot(Slot Of(Event Player), Team 1)) <= 25;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 30 + Event Player.ai_ViewAngleMod) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 8;
        Ability Cooldown(Event Player, Button(Secondary Fire)) == 0;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Secondary Fire);
        Call Subroutine(aiSub_Abilities_Lucio);
    }
}
rule("AI Lucio Sound Barrier")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Lúcio;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Ultimate Charge Percent(Event Player) == 100;
        Is Using Ultimate(Event Player) == False;
        (Is Using Ultimate(Players In Slot(Slot Of(Event Player), Team 1)) || Health(Event Player) <= 75) == True;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ultimate);
        Call Subroutine(aiSub_Abilities_Lucio);
    }
}
rule("AI McCree")
{
    event
    {
        Subroutine;
        aiSub_Abilities_McCree;
    }
    actions
    {
        Event Player.ai_IsInAbilitySub = True;
        Call Subroutine(aiSub_ReactionDelay);
        If(Event Player.ai_AbilityButton == Button(Primary Fire));
            Skip If(Is Button Held(Event Player, Button(Primary Fire)), 1);
            Start Holding Button(Event Player, Button(Primary Fire));
        Else If(Event Player.ai_AbilityButton == Button(Secondary Fire));
            Event Player.ai_AimBase = 2;
            Call Subroutine(aiSub_ReactionDelay);
            Press Button(Event Player, Button(Secondary Fire));
            Call Subroutine(aiSub_ReactionDelay);
            Call Subroutine(aiSub_FacingReset);
        Else If(Event Player.ai_AbilityButton == Button(Ability 1));
            Press Button(Event Player, Button(Ability 1));
        Else If(Event Player.ai_AbilityButton == Button(Ability 2));
            Press Button(Event Player, Button(Ability 2));
        Else If(Event Player.ai_AbilityButton == Button(Ultimate));
            Call Subroutine(aiSub_ButtonsReset);
            Press Button(Event Player, Button(Ultimate));
            Wait Until(Event Player.ai_McCreeDeadeyeCharge >= Health(Players In Slot(Slot Of(Event Player), Team 1)), 5);
            Call Subroutine(aiSub_ReactionDelay);
            Stop Chasing Player Variable(Event Player, ai_McCreeDeadeyeCharge);
            Start Holding Button(Event Player, Button(Primary Fire));
        End;
        Event Player.ai_IsInAbilitySub = False;
    }
}
rule("AI McCree General")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        McCree;
    }
    conditions
    {
        Is Game In Progress == True;
        Is Alive(Event Player) == True;
        Event Player.ai_AIEnabled == True;
    }
    actions
    {
        Event Player.ai_OptimalDistanceDefault = Random Real(13, 16);
        Event Player.ai_OptimalDistance = Event Player.ai_OptimalDistanceDefault;
        Event Player.ai_AimTypeDefault = 0;
        Event Player.ai_AimBaseDefault = 0;
        Call Subroutine(aiSub_FacingReset);
        Event Player.ai_HeroInitialized = True;
    }
}
rule("AI McCree Attack Primary")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        McCree;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Is In View Angle(Event Player, Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250 + Y Component Of(
            Eye Position(Event Player)), 0), 12.500) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 45;
        Is Using Ultimate(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Primary Fire);
        Call Subroutine(aiSub_Abilities_McCree);
        Wait(0.500, Ignore Condition);
        Loop If Condition Is True;
        Stop Holding Button(Event Player, Button(Primary Fire));
    }
}
rule("AI McCree Attack Secondary")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        McCree;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Is In View Angle(Event Player, Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250 + Y Component Of(
            Eye Position(Event Player)), 0), 17.500) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 7.500;
        (Has Status(Players In Slot(Slot Of(Event Player), Team 1), Stunned) == True || Health(Players In Slot(Slot Of(Event Player),
            Team 1)) <= 75) == True;
        Is Using Ultimate(Event Player) == False;
        Ammo(Event Player, 0) >= 3;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Secondary Fire);
        Call Subroutine(aiSub_Abilities_McCree);
    }
}
rule("AI McCree Combat Roll")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        McCree;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Is In View Angle(Players In Slot(Slot Of(Event Player), Team 1), Eye Position(Event Player) - Vector(0, 0.250 + Y Component Of(
            Eye Position(Players In Slot(Slot Of(Event Player), Team 1))), 0), 15) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 8;
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
    }
    actions
    {
        If(Random Real(0, 1) < 0.750 + Event Player.ai_ChanceMod);
            Event Player.ai_AbilityButton = Button(Ability 1);
            Call Subroutine(aiSub_Abilities_McCree);
        End;
    }
}
rule("AI McCree Flashbang")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        McCree;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Is In View Angle(Event Player, Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250 + Y Component Of(
            Eye Position(Event Player)), 0), 15) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 10;
        Ability Cooldown(Event Player, Button(Ability 2)) == 0;
    }
    actions
    {
        If(Random Real(0, 1) < 0.750 + Event Player.ai_ChanceMod);
            Event Player.ai_AbilityButton = Button(Ability 2);
            Call Subroutine(aiSub_Abilities_McCree);
        End;
    }
}
rule("AI McCree Deadeye Start")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        McCree;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Ultimate Charge Percent(Event Player) == 100;
        Is Using Ultimate(Event Player) == False;
        Is In View Angle(Event Player, Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250 + Y Component Of(
            Eye Position(Event Player)), 0), 20) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 200;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) >= 10;
        Health(Players In Slot(Slot Of(Event Player), Team 1)) >= 125;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ultimate);
        Call Subroutine(aiSub_Abilities_McCree);
    }
}
rule("AI McCree Deadeye Charge")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        McCree;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Is Using Ultimate(Event Player) == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
    }
    actions
    {
        Event Player.ai_McCreeDeadeyeCharge = 0;
        Event Player.ai_McCreeDeadeyeRate = 100;
        Wait(0.200, Ignore Condition);
        Chase Player Variable At Rate(Event Player, ai_McCreeDeadeyeCharge, 2802.500, Event Player.ai_McCreeDeadeyeRate,
            Destination and Rate);
        Wait(0.800, Ignore Condition);
        Event Player.ai_McCreeDeadeyeRate = 275;
        Wait(0.500, Ignore Condition);
        Event Player.ai_McCreeDeadeyeRate = 550;
        Wait Until(Is Using Ultimate(Event Player) == False, 4.600);
        Event Player.ai_McCreeDeadeyeCharge = 0;
    }
}
rule("AI Mei")
{
    event
    {
        Subroutine;
        aiSub_Abilities_Mei;
    }
    actions
    {
        Event Player.ai_IsInAbilitySub = True;
        Call Subroutine(aiSub_ReactionDelay);
        If(Event Player.ai_AbilityButton == Button(Primary Fire));
            Event Player.ai_ProjectileSpeed = Event Player.ai_ProjectileSpeeds[0];
            Skip If(Is Button Held(Event Player, Button(Primary Fire)), 2);
            Call Subroutine(aiSub_ButtonsReset);
            Start Holding Button(Event Player, Button(Primary Fire));
        Else If(Event Player.ai_AbilityButton == Button(Secondary Fire));
            Event Player.ai_ProjectileSpeed = Event Player.ai_ProjectileSpeeds[1];
            Skip If(Is Button Held(Event Player, Button(Secondary Fire)), 2);
            Call Subroutine(aiSub_ButtonsReset);
            Start Holding Button(Event Player, Button(Secondary Fire));
        Else If(Event Player.ai_AbilityButton == Button(Ability 1));
            Press Button(Event Player, Button(Ability 1));
            Wait Until(Health(Event Player) >= 200, 4.250);
            Press Button(Event Player, Button(Ability 1));
        Else If(Event Player.ai_AbilityButton == Button(Ability 2));
            Event Player.bot_MoveCrouchEnabled = False;
            Event Player.bot_MoveJumpEnabled = False;
            Press Button(Event Player, Button(Ability 2));
            Event Player.ai_LookAtVector = Position Of(Players In Slot(Slot Of(Event Player), Team 1)) + World Vector Of(Vector(0, 0, 2.500),
                Event Player, Rotation);
            Call Subroutine(aiSub_FacingLookAt);
            Press Button(Event Player, Button(Primary Fire));
            Wait(0.100, Ignore Condition);
            Event Player.ai_CanAim = True;
            Event Player.bot_MoveCrouchEnabled = True;
            Event Player.bot_MoveJumpEnabled = True;
        Else If(Event Player.ai_AbilityButton == Button(Ultimate));
            Event Player.ai_ProjectileSpeed = Event Player.ai_ProjectileSpeeds[4];
            Event Player.ai_AimBase = 2;
            Wait(0.250, Ignore Condition);
            Press Button(Event Player, Button(Ultimate));
            Wait(0.250, Ignore Condition);
            Call Subroutine(aiSub_FacingReset);
        End;
        Event Player.ai_IsInAbilitySub = False;
    }
}
rule("AI Mei General")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Mei;
    }
    conditions
    {
        Is Game In Progress == True;
        Is Alive(Event Player) == True;
        Event Player.ai_AIEnabled == True;
    }
    actions
    {
        Event Player.ai_OptimalDistanceDefault = Random Real(6, 10);
        Event Player.ai_OptimalDistance = Event Player.ai_OptimalDistanceDefault;
        Event Player.ai_AimBaseDefault = 0;
        Event Player.ai_AimBase = Event Player.ai_AimBaseDefault;
        Event Player.ai_AimType = 1;
        Event Player.ai_ProjectileSpeeds[0] = 20;
        Event Player.ai_ProjectileSpeeds[1] = 115;
        Event Player.ai_ProjectileSpeeds[4] = 20;
        Event Player.ai_HeroInitialized = True;
    }
}
rule("AI Mei Attack Primary")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Mei;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 10;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 20 + Event Player.ai_ViewAngleMod) == True;
        Is Using Ability 1(Event Player) == False;
        Has Status(Players In Slot(Slot Of(Event Player), Team 1), Frozen) == False;
        Health(Players In Slot(Slot Of(Event Player), Team 1)) > 75;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Primary Fire);
        Call Subroutine(aiSub_Abilities_Mei);
        Wait(0.150, Ignore Condition);
        Loop If Condition Is True;
        Stop Holding Button(Event Player, Button(Primary Fire));
    }
}
rule("AI Mei Attack Secondary")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Mei;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 50;
        (Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) > 10 || Health(Players In Slot(Slot Of(
            Event Player), Team 1)) <= 75) == True;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.ai_ViewAngleMod) == True;
        Is Using Ability 1(Event Player) == False;
        Has Status(Players In Slot(Slot Of(Event Player), Team 1), Frozen) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Secondary Fire);
        Call Subroutine(aiSub_Abilities_Mei);
        Wait(0.800, Ignore Condition);
        Loop If Condition Is True;
        Stop Holding Button(Event Player, Button(Secondary Fire));
    }
}
rule("AI Mei Attack Secondary Frozen")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Mei;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 20;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.ai_ViewAngleMod) == True;
        Is Using Ability 1(Event Player) == False;
        Has Status(Players In Slot(Slot Of(Event Player), Team 1), Frozen) == True;
    }
    actions
    {
        Event Player.bot_MoveCrouchEnabled = False;
        Event Player.bot_MoveJumpEnabled = False;
        Event Player.ai_AimBase = 1;
        Event Player.ai_AbilityButton = Button(Secondary Fire);
        Call Subroutine(aiSub_Abilities_Mei);
        Wait(0.800, Ignore Condition);
        Loop If Condition Is True;
        Stop Holding Button(Event Player, Button(Secondary Fire));
        Call Subroutine(aiSub_FacingReset);
        Event Player.bot_MoveCrouchEnabled = True;
        Event Player.bot_MoveJumpEnabled = True;
    }
}
rule("AI Mei Cryo-Freeze")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Mei;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Health(Event Player) <= 70;
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
        Is Using Ability 1(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 1);
        Call Subroutine(aiSub_Abilities_Mei);
    }
}
rule("AI Mei Ice Wall")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Mei;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 10;
        Is On Ground(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Ability Cooldown(Event Player, Button(Ability 2)) == 0;
        Is Using Ability 2(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 2);
        Call Subroutine(aiSub_Abilities_Mei);
    }
}
rule("AI Mei Blizzrd")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Mei;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Ultimate Charge Percent(Event Player) == 100;
        Is Using Ultimate(Event Player) == False;
        Health(Players In Slot(Slot Of(Event Player), Team 1)) >= 100;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 15;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ultimate);
        Call Subroutine(aiSub_Abilities_Mei);
    }
}
rule("AI Mercy")
{
    event
    {
        Subroutine;
        aiSub_Abilities_Mercy;
    }
    actions
    {
        Event Player.ai_IsInAbilitySub = True;
        Call Subroutine(aiSub_ReactionDelay);
        If(Event Player.ai_AbilityButton == Button(Ultimate));
            Press Button(Event Player, Button(Ultimate));
            Wait Until(Is Using Ultimate(Event Player), 1);
            If(Is Using Ultimate(Event Player));
                Event Player.ai_OptimalDistance = Random Real(12, 16);
                Event Player.bot_MoveCrouchEnabled = False;
                Event Player.bot_MoveWASDEnabled = False;
                Event Player.ai_LookAtVector = Vector(X Component Of(Position Of(Event Player)), 10, Z Component Of(Position Of(Event Player)));
                Call Subroutine(aiSub_FacingLookAt);
                Start Throttle In Direction(Event Player, Forward, 1, To Player, Replace existing throttle, Direction and Magnitude);
                Wait(Random Real(0.500, 1), Ignore Condition);
                Event Player.ai_CanAim = True;
                Start Throttle In Direction(Event Player, Backward, 1, To Player, Replace existing throttle, Direction and Magnitude);
                Wait(Random Real(0.500, 1), Ignore Condition);
                Event Player.bot_MoveWASDEnabled = True;
                Wait Until(Is Using Ultimate(Event Player) == False, 15);
                Event Player.bot_MoveCrouchEnabled = True;
                Event Player.ai_OptimalDistance = Event Player.ai_OptimalDistanceDefault;
            End;
        End;
        Event Player.ai_IsInAbilitySub = False;
    }
}
rule("AI Mercy General")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Mercy;
    }
    conditions
    {
        Is Game In Progress == True;
        Is Alive(Event Player) == True;
        Event Player.ai_AIEnabled == True;
    }
    actions
    {
        Event Player.ai_OptimalDistanceDefault = Random Real(8, 12);
        Event Player.ai_OptimalDistance = Event Player.ai_OptimalDistanceDefault;
        Event Player.ai_AimBaseDefault = 0;
        Event Player.ai_AimTypeDefault = 1;
        Event Player.ai_ProjectileSpeed = 50;
        Set Weapon(Event Player, 2);
        Call Subroutine(aiSub_FacingReset);
        Event Player.ai_HeroInitialized = True;
    }
}
rule("Non AI Mercy Wield Staff")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Mercy;
    }
    conditions
    {
        Is Game In Progress == True;
        Is Alive(Event Player) == True;
        Event Player.ai_AIEnabled == False;
    }
    actions
    {
        Set Weapon(Event Player, 1);
    }
}
rule("AI Mercy Attack")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Mercy;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Is In View Angle(Event Player, Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250 + Y Component Of(
            Eye Position(Event Player)), 0), 20) == True;
    }
    actions
    {
        Skip If(Is Button Held(Event Player, Button(Primary Fire)), 1);
        Start Holding Button(Event Player, Button(Primary Fire));
        Wait(0.250, Ignore Condition);
        Loop If Condition Is True;
        Stop Holding Button(Event Player, Button(Primary Fire));
    }
}
rule("AI Mercy Valkyrie")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Mercy;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Ultimate Charge Percent(Event Player) == 100;
        Is Using Ultimate(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ultimate);
        Call Subroutine(aiSub_Abilities_Mercy);
    }
}
rule("AI Moira")
{
    event
    {
        Subroutine;
        aiSub_Abilities_Moira;
    }
    actions
    {
        Event Player.ai_IsInAbilitySub = True;
        Call Subroutine(aiSub_ReactionDelay);
        If(Event Player.ai_AbilityButton == Button(Primary Fire));
        Else If(Event Player.ai_AbilityButton == Button(Secondary Fire));
            Skip If(Is Button Held(Event Player, Button(Secondary Fire)), 1);
            Start Holding Button(Event Player, Button(Secondary Fire));
        Else If(Event Player.ai_AbilityButton == Button(Ability 1));
            If(Event Player.ai_AbilityOpt == 0);
                Press Button(Event Player, Button(Jump));
                Wait(Random Real(0.150, 0.250), Ignore Condition);
                Press Button(Event Player, Button(Ability 1));
                Wait(Random Real(0.500, 0.600), Ignore Condition);
                Press Button(Event Player, Button(Jump));
            Else If(Event Player.ai_AbilityOpt == 1);
                Press Button(Event Player, Button(Ability 1));
            End;
        Else If(Event Player.ai_AbilityButton == Button(Ability 2));
            Stop Holding Button(Event Player, Button(Secondary Fire));
            Call Subroutine(aiSub_ReactionDelay);
            Press Button(Event Player, Button(Ability 2));
            Call Subroutine(aiSub_ReactionDelay);
            If(Event Player.ai_AbilityOpt == 0);
                Press Button(Event Player, Button(Primary Fire));
            Else If(Event Player.ai_AbilityOpt == 1);
                Press Button(Event Player, Button(Secondary Fire));
            End;
        Else If(Event Player.ai_AbilityButton == Button(Ultimate));
            If(Ability Cooldown(Event Player, Button(Ability 2)) == 0);
                Event Player.ai_AbilityButton = Button(Ability 2);
                Event Player.ai_AbilityOpt = 1;
                Call Subroutine(aiSub_Abilities_Moira);
            End;
            Press Button(Event Player, Button(Ultimate));
            Wait Until(Is Using Ultimate(Event Player), 1 / 60);
            Wait Until(Is Using Ultimate(Event Player) == False, 8);
        End;
        Event Player.ai_IsInAbilitySub = False;
    }
}
rule("AI Moira General")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Moira;
    }
    conditions
    {
        Is Game In Progress == True;
        Is Alive(Event Player) == True;
        Event Player.ai_AIEnabled == True;
    }
    actions
    {
        Event Player.ai_OptimalDistanceDefault = Random Real(10, 15);
        Event Player.ai_OptimalDistance = Event Player.ai_OptimalDistanceDefault;
        Event Player.ai_AimBaseDefault = 0;
        Event Player.ai_AimTypeDefault = 0;
        Call Subroutine(aiSub_FacingReset);
        Event Player.ai_HeroInitialized = True;
    }
}
rule("AI Moira Attack")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Moira;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Is In View Angle(Event Player, Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250 + Y Component Of(
            Eye Position(Event Player)), 0), 15) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 20;
        Is Using Ability 2(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Secondary Fire);
        Call Subroutine(aiSub_Abilities_Moira);
        Wait(0.250, Ignore Condition);
        Loop If Condition Is True;
        Stop Holding Button(Event Player, Button(Secondary Fire));
    }
}
rule("AI Moira Fade")
{
    event
    {
        Player Took Damage;
        Team 2;
        Moira;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Health(Event Player) <= 75;
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 1);
        Event Player.ai_AbilityOpt = 0;
        Call Subroutine(aiSub_Abilities_Moira);
    }
}
rule("AI Moira Fade Gap Closer")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Moira;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) >= 25;
        Distance Between(Players In Slot(Slot Of(Event Player), Team 1), Players In Slot(Slot Of(Event Player), Team 1).p_HomeVector)
            < Global.c_BubbleRadius;
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 1);
        Event Player.ai_AbilityOpt = 0;
        Call Subroutine(aiSub_Abilities_Moira);
    }
}
rule("AI Moira Fade Ultimate")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Moira;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Is Using Ultimate(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
    }
    actions
    {
        If(Random Real(0, 1) < 0.500 + Event Player.ai_ChanceMod);
            Event Player.ai_AbilityButton = Button(Ability 1);
            Event Player.ai_AbilityOpt = 1;
            Call Subroutine(aiSub_Abilities_Moira);
        End;
    }
}
rule("AI Moira Biotic Orb Damage")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Moira;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Is In View Angle(Event Player, Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250 + Y Component Of(
            Eye Position(Event Player)), 0), 12.500) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 15;
        Ultimate Charge Percent(Event Player) < 80;
        Health(Event Player) >= 100;
        Health(Players In Slot(Slot Of(Event Player), Team 1)) > 75;
        Is Using Ability 1(Event Player) == False;
        Ability Cooldown(Event Player, Button(Ability 2)) == 0;
        Is Using Ability 2(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 2);
        Event Player.ai_AbilityOpt = 1;
        Call Subroutine(aiSub_Abilities_Moira);
    }
}
rule("AI Moira Biotic Orb Healing")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Moira;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Health(Event Player) <= 100;
        Ability Cooldown(Event Player, Button(Ability 2)) == 0;
        Is Using Ability 2(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 2);
        Event Player.ai_AbilityOpt = 0;
        Call Subroutine(aiSub_Abilities_Moira);
    }
}
rule("AI Moira Coalescence")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Moira;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Ultimate Charge Percent(Event Player) == 100;
        Is Using Ultimate(Event Player) == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Is In View Angle(Event Player, Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250 + Y Component Of(
            Eye Position(Event Player)), 0), 15) == True;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ultimate);
        Call Subroutine(aiSub_Abilities_Moira);
    }
}
rule("AI Orisa")
{
    event
    {
        Subroutine;
        aiSub_Abilities_Orisa;
    }
    actions
    {
        Event Player.ai_IsInAbilitySub = True;
        Call Subroutine(aiSub_ReactionDelay);
        If(Event Player.ai_AbilityButton == Button(Secondary Fire));
            Event Player.ai_ProjectileSpeed = Event Player.ai_ProjectileSpeeds[1];
            Event Player.ai_AimBase = 3;
            Event Player.ai_FacingRelPosMod = Vector(Random Real(-2, 2), Random Real(3, 6), Random Real(-2, 2));
            Call Subroutine(aiSub_ReactionDelay);
            Press Button(Event Player, Button(Secondary Fire));
            Wait(0.100, Ignore Condition);
            Event Player.ai_ProjectileSpeed = Event Player.ai_ProjectileSpeeds[0];
            Event Player.ai_AimBase = 0;
            If(Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) > 0.450 * Event Player.ai_ProjectileSpeeds[1]);
                Wait(Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) / Event Player.ai_ProjectileSpeeds[1],
                    Ignore Condition);
            Else;
                Wait(0.450, Ignore Condition);
            End;
            Press Button(Event Player, Button(Secondary Fire));
            Wait(0.500, Ignore Condition);
        Else If(Event Player.ai_AbilityButton == Button(Ability 1));
            Press Button(Event Player, Button(Ability 1));
        Else If(Event Player.ai_AbilityButton == Button(Ability 2));
            Event Player.ai_LookAtVector = Position Of(Event Player) + World Vector Of(Vector(0, 0, 4), Event Player, Rotation);
            Call Subroutine(aiSub_FacingLookAt);
            Press Button(Event Player, Button(Ability 2));
            Call Subroutine(aiSub_ReactionDelay);
            Event Player.ai_CanAim = True;
        Else If(Event Player.ai_AbilityButton == Button(Ultimate));
            Press Button(Event Player, Button(Ultimate));
        End;
        Event Player.ai_IsInAbilitySub = False;
    }
}
rule("AI Orisa General")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Orisa;
    }
    conditions
    {
        Is Game In Progress == True;
        Is Alive(Event Player) == True;
        Event Player.ai_AIEnabled == True;
    }
    actions
    {
        Event Player.ai_OptimalDistanceDefault = Random Real(12, 16);
        Event Player.ai_OptimalDistance = Event Player.ai_OptimalDistanceDefault;
        Event Player.ai_AimBaseDefault = 0;
        Event Player.ai_AimBase = Event Player.ai_AimBaseDefault;
        Event Player.ai_AimType = 1;
        Event Player.ai_ProjectileSpeeds[0] = 120;
        Event Player.ai_ProjectileSpeeds[1] = 25;
        Event Player.ai_HeroInitialized = True;
    }
}
rule("AI Orisa Attack")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Orisa;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 50;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 10 + Event Player.ai_ViewAngleMod) == True;
    }
    actions
    {
        Skip If(Is Button Held(Event Player, Button(Primary Fire)), 2);
        Call Subroutine(aiSub_ButtonsReset);
        Start Holding Button(Event Player, Button(Primary Fire));
        Wait(0.250, Ignore Condition);
        Loop If Condition Is True;
        Stop Holding Button(Event Player, Button(Primary Fire));
    }
}
rule("AI Orisa Halt!")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Orisa;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 30;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.ai_ViewAngleMod) == True;
        Ability Cooldown(Event Player, Button(Secondary Fire)) == 0;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Secondary Fire);
        Call Subroutine(aiSub_Abilities_Orisa);
    }
}
rule("AI Orisa Fortify")
{
    event
    {
        Player Took Damage;
        Team 2;
        Orisa;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 30;
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
    }
    actions
    {
        If(Random Real(0, 1) < 0.333 + Event Player.ai_ChanceMod);
            Event Player.ai_AbilityButton = Button(Ability 1);
            Call Subroutine(aiSub_Abilities_Orisa);
        End;
    }
}
rule("AI Orisa Protective Barrier")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Orisa;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= Event Player.ai_OptimalDistance;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.ai_ViewAngleMod) == True;
        Ability Cooldown(Event Player, Button(Ability 2)) == 0;
        Is Using Ability 2(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 2);
        Call Subroutine(aiSub_Abilities_Orisa);
    }
}
rule("AI Orisa Supercharger")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Orisa;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= Event Player.ai_OptimalDistance;
        Ultimate Charge Percent(Event Player) == 100;
        Is Using Ultimate(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ultimate);
        Call Subroutine(aiSub_Abilities_Orisa);
    }
}
rule("AI Pharah")
{
    event
    {
        Subroutine;
        aiSub_Abilities_Pharah;
    }
    actions
    {
        Event Player.ai_IsInAbilitySub = True;
        Call Subroutine(aiSub_ReactionDelay);
        If(Event Player.ai_AbilityButton == Button(Primary Fire));
            Event Player.ai_ProjectileSpeed = Event Player.ai_ProjectileSpeeds[0];
            Press Button(Event Player, Button(Primary Fire));
        Else If(Event Player.ai_AbilityButton == Button(Secondary Fire));
            Start Holding Button(Event Player, Button(Secondary Fire));
        Else If(Event Player.ai_AbilityButton == Button(Ability 1));
            Press Button(Event Player, Button(Ability 1));
        Else If(Event Player.ai_AbilityButton == Button(Ability 2));
            Event Player.ai_ProjectileSpeed = Event Player.ai_ProjectileSpeeds[3];
            Call Subroutine(aiSub_ReactionDelay);
            Press Button(Event Player, Button(Ability 2));
        Else If(Event Player.ai_AbilityButton == Button(Ultimate));
            Event Player.ai_ProjectileSpeed = Event Player.ai_ProjectileSpeeds[4];
            Press Button(Event Player, Button(Ultimate));
            Wait Until(Is Using Ultimate(Event Player) == True, 0.250);
            Wait Until(Is Using Ultimate(Event Player) == False, 2.500);
        End;
        Event Player.ai_IsInAbilitySub = False;
    }
}
rule("AI Pharah General")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Pharah;
    }
    conditions
    {
        Is Game In Progress == True;
        Is Alive(Event Player) == True;
        Event Player.ai_AIEnabled == True;
    }
    actions
    {
        Event Player.ai_OptimalDistanceDefault = Random Real(9, 12);
        Event Player.ai_OptimalDistance = Event Player.ai_OptimalDistanceDefault;
        Event Player.ai_StrafeDistanceMod = 10;
        Event Player.ai_AimBaseDefault = 2;
        Event Player.ai_AimTypeDefault = 1;
        Event Player.ai_ProjectileSpeeds[0] = 35;
        Event Player.ai_ProjectileSpeeds[3] = 60;
        Event Player.ai_ProjectileSpeeds[4] = 45;
        Call Subroutine(aiSub_FacingReset);
        Event Player.ai_HeroInitialized = True;
    }
}
rule("AI Pharah Hover Jets")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Pharah;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Altitude Of(Event Player) <= 20;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Secondary Fire);
        Call Subroutine(aiSub_Abilities_Pharah);
        Wait(Random Real(0.250, 1.250), Ignore Condition);
        Stop Holding Button(Event Player, Button(Secondary Fire));
        Wait(Random Real(0.500, 1), Ignore Condition);
        Loop If Condition Is True;
    }
}
rule("AI Pharah Attack")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Pharah;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 35;
        Is In View Angle(Event Player, Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250 + Y Component Of(
            Eye Position(Event Player)), 0), 20) == True;
        Is Using Ultimate(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Primary Fire);
        Call Subroutine(aiSub_Abilities_Pharah);
        Wait(0.850, Ignore Condition);
        Loop If Condition Is True;
    }
}
rule("AI Pharah Jump Jet")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Pharah;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
        Altitude Of(Event Player) <= 20;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 1);
        Call Subroutine(aiSub_Abilities_Pharah);
    }
}
rule("AI Pharah Concussive Blast")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Pharah;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Is In View Angle(Event Player, Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250 + Y Component Of(
            Eye Position(Event Player)), 0), 12.500) == True;
        Ability Cooldown(Event Player, Button(Ability 2)) == 0;
        Is Using Ultimate(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 2);
        Call Subroutine(aiSub_Abilities_Pharah);
    }
}
rule("AI Pharah Barrage")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Pharah;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Ultimate Charge Percent(Event Player) == 100;
        Is Using Ultimate(Event Player) == False;
        Altitude Of(Event Player) >= 3;
        Altitude Of(Event Player) <= 12;
        Health(Players In Slot(Slot Of(Event Player), Team 1)) >= 100;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 15;
        Is In View Angle(Event Player, Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250 + Y Component Of(
            Eye Position(Event Player)), 0), 17.500) == True;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ultimate);
        Call Subroutine(aiSub_Abilities_Pharah);
    }
}
rule("AI Reaper")
{
    event
    {
        Subroutine;
        aiSub_Abilities_Reaper;
    }
    actions
    {
        Event Player.ai_IsInAbilitySub = True;
        Call Subroutine(aiSub_ReactionDelay);
        If(Event Player.ai_AbilityButton == Button(Primary Fire));
            Skip If(Is Button Held(Event Player, Button(Primary Fire)), 1);
            Start Holding Button(Event Player, Button(Primary Fire));
        Else If(Event Player.ai_AbilityButton == Button(Ability 1));
            Call Subroutine(aiSub_ButtonsReset);
            Press Button(Event Player, Button(Ability 1));
            Wait(Random Real(2, 3), Ignore Condition);
            Press Button(Event Player, Button(Primary Fire));
        Else If(Event Player.ai_AbilityButton == Button(Ability 2));
            Press Button(Event Player, Button(Ability 2));
            Event Player.ai_LookAtVector = Position Of(Players In Slot(Slot Of(Event Player), Team 1) + Vector(Random Real(0, 5), 0,
                Random Real(0, 5)));
            Call Subroutine(aiSub_FacingLookAt);
            Press Button(Event Player, Button(Primary Fire));
            Wait(1.500, Ignore Condition);
            Event Player.ai_CanAim = True;
        Else If(Event Player.ai_AbilityButton == Button(Ultimate));
            Press Button(Event Player, Button(Ultimate));
            Wait Until(Is Using Ultimate(Event Player), 0.500);
            Wait Until(Is Using Ultimate(Event Player) == False, 3);
        End;
        Event Player.ai_IsInAbilitySub = False;
    }
}
rule("AI Reaper General")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Reaper;
    }
    conditions
    {
        Is Game In Progress == True;
        Is Alive(Event Player) == True;
        Event Player.ai_AIEnabled == True;
    }
    actions
    {
        Event Player.ai_OptimalDistanceDefault = Random Real(3, 7);
        Event Player.ai_OptimalDistance = Event Player.ai_OptimalDistanceDefault;
        Event Player.ai_AimBaseDefault = 0;
        Event Player.ai_AimTypeDefault = 0;
        Call Subroutine(aiSub_FacingReset);
        Event Player.ai_HeroInitialized = True;
    }
}
rule("AI Reaper Attack")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Reaper;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Event Player.ai_HeroInitialized == True;
        Is Using Ability 1(Event Player) == False;
        Is Using Ability 2(Event Player) == False;
        Is Using Ultimate(Event Player) == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 25;
        Is In View Angle(Event Player, Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250 + Y Component Of(
            Eye Position(Event Player)), 0), 12.500) == True;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Primary Fire);
        Call Subroutine(aiSub_Abilities_Reaper);
        Wait(0.500, Ignore Condition);
        Loop If Condition Is True;
        Stop Holding Button(Event Player, Button(Primary Fire));
    }
}
rule("AI Reaper Wraith Form")
{
    event
    {
        Player Took Damage;
        Team 2;
        Reaper;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Health(Event Player) < 100;
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
        Is Using Ability 1(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 1);
        Call Subroutine(aiSub_Abilities_Reaper);
    }
}
rule("AI Reaper Shadow Step")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Reaper;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) > 20;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1).p_HomeVector)
            < Global.c_BubbleRadius;
        Ability Cooldown(Event Player, Button(Ability 2)) == 0;
        Is Using Ability 2(Event Player) == False;
    }
    actions
    {
        Wait(0.250, Abort When False);
        Event Player.ai_AbilityButton = Button(Ability 2);
        Call Subroutine(aiSub_Abilities_Reaper);
    }
}
rule("AI Reaper Death Blossom")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Reaper;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Ultimate Charge Percent(Event Player) == 100;
        Is Using Ultimate(Event Player) == False;
        Health(Players In Slot(Slot Of(Event Player), Team 1)) >= 100;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) < 8;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ultimate);
        Call Subroutine(aiSub_Abilities_Reaper);
    }
}
rule("AI Reinhardt")
{
    event
    {
        Subroutine;
        aiSub_Abilities_Reinhardt;
    }
    actions
    {
        Event Player.ai_IsInAbilitySub = True;
        Call Subroutine(aiSub_ReactionDelay);
        If(Event Player.ai_AbilityButton == Button(Primary Fire));
            Skip If(Is Button Held(Event Player, Button(Primary Fire)), 2);
            Call Subroutine(aiSub_ButtonsReset);
            Start Holding Button(Event Player, Button(Primary Fire));
        Else If(Event Player.ai_AbilityButton == Button(Secondary Fire));
            Start Holding Button(Event Player, Button(Secondary Fire));
            Wait Until(Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) < 6.500, Random Real(0.500, 2.750));
            Stop Holding Button(Event Player, Button(Secondary Fire));
        Else If(Event Player.ai_AbilityButton == Button(Ability 1));
            Press Button(Event Player, Button(Ability 1));
            Event Player.bot_MoveJumpEnabled = False;
        Else If(Event Player.ai_AbilityButton == Button(Ability 2));
            Call Subroutine(aiSub_ButtonsReset);
            Event Player.ai_AimType = 1;
            Event Player.ai_AimBase = 3;
            Event Player.ai_FacingRelPosMod = Vector(0, 0.750, 0);
            Event Player.ai_ProjectileSpeed = Event Player.ai_ProjectileSpeeds[3];
            Call Subroutine(aiSub_FacingStart);
            Wait(Random Real(0.150, 0.250), Ignore Condition);
            Press Button(Event Player, Button(Ability 2));
            Wait(1.120, Ignore Condition);
            Call Subroutine(aiSub_FacingReset);
        Else If(Event Player.ai_AbilityButton == Button(Ultimate));
            Call Subroutine(aiSub_ButtonsReset);
            Press Button(Event Player, Button(Ultimate));
            Wait(0.950, Ignore Condition);
            If(Has Status(Players In Slot(Slot Of(Event Player), Team 1), Knocked Down));
                Event Player.bot_MoveCrouchEnabled = False;
                Event Player.ai_OptimalDistance = Random Real(1.500, 3);
                If(Ability Cooldown(Event Player, Button(Ability 1)) == 0);
                    Press Button(Event Player, Button(Ability 1));
                End;
            End;
        End;
        Event Player.ai_IsInAbilitySub = False;
    }
}
rule("AI Reinhardt General")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Reinhardt;
    }
    conditions
    {
        Is Game In Progress == True;
        Is Alive(Event Player) == True;
        Event Player.ai_AIEnabled == True;
    }
    actions
    {
        Event Player.ai_OptimalDistanceDefault = Random Real(2.250, 4.250);
        Event Player.ai_OptimalDistance = Event Player.ai_OptimalDistanceDefault;
        Event Player.ai_StrafeDistanceMod = 0;
        Event Player.ai_AimBaseDefault = 0;
        Event Player.ai_AimTypeDefault = 0;
        Event Player.ai_ProjectileSpeeds[3] = 25;
        Call Subroutine(aiSub_FacingReset);
        Event Player.ai_HeroInitialized = True;
    }
}
rule("AI Reinhardt Attack")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Reinhardt;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) < 10;
        Is In View Angle(Event Player, Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250 + Y Component Of(
            Eye Position(Event Player)), 0), 30) == True;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Primary Fire);
        Call Subroutine(aiSub_Abilities_Reinhardt);
        Wait(0.960, Ignore Condition);
        Loop If Condition Is True;
        Stop Holding Button(Event Player, Button(Primary Fire));
    }
}
rule("AI Reinhardt Use Shield")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Reinhardt;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Health(Event Player) < 450;
        Is In View Angle(Players In Slot(Slot Of(Event Player), Team 1), Eye Position(Event Player) - Vector(0, 0.250 + Y Component Of(
            Eye Position(Players In Slot(Slot Of(Event Player), Team 1))), 0), 10) == True;
        (Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) >= 7.500 || Health(Event Player) <= 250) == True;
        Distance Between(Players In Slot(Slot Of(Event Player), Team 1), Players In Slot(Slot Of(Event Player), Team 1).p_HomeVector)
            < Global.c_BubbleRadius;
        Has Status(Players In Slot(Slot Of(Event Player), Team 1), Knocked Down) == False;
        Is Using Ultimate(Event Player) == False;
    }
    actions
    {
        If(Random Real(0, 1) < 0.650 + Event Player.ai_ChanceMod);
            Event Player.ai_AbilityButton = Button(Secondary Fire);
            Call Subroutine(aiSub_Abilities_Reinhardt);
        End;
        Loop If Condition Is True;
        Stop Holding Button(Event Player, Button(Secondary Fire));
    }
}
rule("AI Reinhardt Charge")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Reinhardt;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Is In View Angle(Event Player, Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250 + Y Component Of(
            Eye Position(Event Player)), 0), 12.500) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 10;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1).p_HomeVector) < Players In Slot(Slot Of(
            Event Player), Team 1).p_EnemyDistanceMax - 2.500;
        Health(Players In Slot(Slot Of(Event Player), Team 1)) >= 75;
        Altitude Of(Players In Slot(Slot Of(Event Player), Team 1)) < 2;
        Altitude Of(Event Player) < 2;
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 1);
        Call Subroutine(aiSub_Abilities_Reinhardt);
    }
}
rule("AI Reinhardt Charge Gap Closer")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Reinhardt;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Is In View Angle(Event Player, Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250 + Y Component Of(
            Eye Position(Event Player)), 0), 12.500) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) > 20;
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 1);
        Call Subroutine(aiSub_Abilities_Reinhardt);
    }
}
rule("AI Reinhardt Firestrike")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Reinhardt;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Is In View Angle(Event Player, Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250 + Y Component Of(
            Eye Position(Event Player)), 0), 15) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) < 20;
        Ability Cooldown(Event Player, Button(Ability 2)) == 0;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 2);
        Call Subroutine(aiSub_Abilities_Reinhardt);
    }
}
rule("AI Reinhardt Earthshatter")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Reinhardt;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Ultimate Charge Percent(Event Player) == 100;
        Is Using Ultimate(Event Player) == False;
        Is In View Angle(Event Player, Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250 + Y Component Of(
            Eye Position(Event Player)), 0), 15) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 16;
        Health(Players In Slot(Slot Of(Event Player), Team 1)) >= 100;
        Health(Event Player) >= 50;
        Is On Ground(Event Player) == True;
        Is On Ground(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        (Hero Of(Players In Slot(Slot Of(Event Player), Team 1)) == Hero(Reinhardt) ? Is Firing Secondary(Players In Slot(Slot Of(
            Event Player), Team 1)) == False : True) == True;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ultimate);
        Call Subroutine(aiSub_Abilities_Reinhardt);
        Wait Until(Has Status(Players In Slot(Slot Of(Event Player), Team 1), Knocked Down) == False, 2.500);
        Event Player.bot_MoveCrouchEnabled = True;
        Event Player.ai_OptimalDistance = Event Player.ai_OptimalDistanceDefault;
    }
}
rule("AI Roadhog")
{
    event
    {
        Subroutine;
        aiSub_Abilities_Roadhog;
    }
    actions
    {
        Event Player.ai_IsInAbilitySub = True;
        Call Subroutine(aiSub_ReactionDelay);
        If(Event Player.ai_AbilityButton == Button(Primary Fire));
            Event Player.ai_ProjectileSpeed = Event Player.ai_ProjectileSpeeds[0];
            Skip If(Is Button Held(Event Player, Button(Primary Fire)), 2);
            Call Subroutine(aiSub_ButtonsReset);
            Start Holding Button(Event Player, Button(Primary Fire));
        Else If(Event Player.ai_AbilityButton == Button(Secondary Fire));
            Event Player.ai_ProjectileSpeed = Event Player.ai_ProjectileSpeeds[0];
            Skip If(Is Button Held(Event Player, Button(Secondary Fire)), 2);
            Call Subroutine(aiSub_ButtonsReset);
            Start Holding Button(Event Player, Button(Secondary Fire));
        Else If(Event Player.ai_AbilityButton == Button(Ability 1));
            Event Player.ai_ProjectileSpeed = Event Player.ai_ProjectileSpeeds[2];
            Wait(Random Real(0.100, 0.250), Ignore Condition);
            Event Player.bot_MoveWASDEnabled = False;
            Start Throttle In Direction(Event Player, Forward, 1, To Player, Replace existing throttle, None);
            Press Button(Event Player, Button(Ability 1));
            Wait Until(Is Using Ability 1(Event Player), 1);
            Wait Until(Is Using Ability 1(Event Player) == False, 1);
            Start Holding Button(Event Player, Button(Primary Fire));
            Wait(0.250, Ignore Condition);
            Press Button(Event Player, Button(Melee));
            Wait(0.750, Ignore Condition);
            Stop Holding Button(Event Player, Button(Primary Fire));
            Call Subroutine(botSub_ThrottleStop);
            Event Player.bot_MoveWASDEnabled = True;
        Else If(Event Player.ai_AbilityButton == Button(Ability 2));
            Press Button(Event Player, Button(Ability 2));
        Else If(Event Player.ai_AbilityButton == Button(Ultimate));
            Press Button(Event Player, Button(Ultimate));
        End;
        Event Player.ai_IsInAbilitySub = False;
    }
}
rule("AI Roadhog General")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Roadhog;
    }
    conditions
    {
        Is Game In Progress == True;
        Is Alive(Event Player) == True;
        Event Player.ai_AIEnabled == True;
    }
    actions
    {
        Event Player.ai_OptimalDistanceDefault = Random Real(9, 12);
        Event Player.ai_OptimalDistance = Event Player.ai_OptimalDistanceDefault;
        Event Player.ai_AimBaseDefault = 0;
        Event Player.ai_AimBase = Event Player.ai_AimBaseDefault;
        Event Player.ai_AimType = 1;
        Event Player.ai_ProjectileSpeeds[0] = 80;
        Event Player.ai_ProjectileSpeeds[2] = 40;
        Event Player.ai_HeroInitialized = True;
    }
}
rule("AI Roadhog Attack Primary")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Roadhog;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 15;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 20 + Event Player.ai_ViewAngleMod) == True;
        Is Using Ability 1(Event Player) == False;
        Is Using Ability 2(Event Player) == False;
        Is Using Ultimate(Event Player) == False;
        Is Firing Secondary(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Primary Fire);
        Call Subroutine(aiSub_Abilities_Roadhog);
        Wait(0.850, Ignore Condition);
        Loop If Condition Is True;
        Stop Holding Button(Event Player, Button(Primary Fire));
    }
}
rule("AI Roadhog Attack Secondary")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Roadhog;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) > 15;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 38;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 20 + Event Player.ai_ViewAngleMod) == True;
        Is Using Ability 1(Event Player) == False;
        Is Using Ability 2(Event Player) == False;
        Is Using Ultimate(Event Player) == False;
        Is Firing Primary(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Secondary Fire);
        Call Subroutine(aiSub_Abilities_Roadhog);
        Wait(0.850, Ignore Condition);
        Loop If Condition Is True;
        Stop Holding Button(Event Player, Button(Secondary Fire));
    }
}
rule("AI Roadhog Chain Hook")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Roadhog;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Ammo(Event Player, 0) > 1;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Health(Players In Slot(Slot Of(Event Player), Team 1)) >= 75;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 4 + Event Player.ai_ViewAngleMod) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 20;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1).p_HomeVector) <= Players In Slot(Slot Of(
            Event Player), Team 1).p_ZoneRadius;
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
        Is Using Ability 1(Event Player) == False;
        Is Using Ability 2(Event Player) == False;
        Is Using Ultimate(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 1);
        Call Subroutine(aiSub_Abilities_Roadhog);
    }
}
rule("AI Roadhog Take A Breather")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Roadhog;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Health(Event Player) < 100;
        Ability Cooldown(Event Player, Button(Ability 2)) == 0;
        Is Using Ability 1(Event Player) == False;
        Is Using Ability 2(Event Player) == False;
        Is Using Ultimate(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 2);
        Call Subroutine(aiSub_Abilities_Roadhog);
    }
}
rule("AI Roadhog Whole Hog")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Roadhog;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Ultimate Charge Percent(Event Player) == 100;
        Is Using Ultimate(Event Player) == False;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 15;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 20 + Event Player.ai_ViewAngleMod) == True;
        Is Using Ability 1(Event Player) == False;
        Is Using Ability 2(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ultimate);
        Call Subroutine(aiSub_Abilities_Roadhog);
    }
}
rule("AI Sigma")
{
    event
    {
        Subroutine;
        aiSub_Abilities_Sigma;
    }
    actions
    {
        Event Player.ai_IsInAbilitySub = True;
        Call Subroutine(aiSub_ReactionDelay);
        If(Event Player.ai_AbilityButton == Button(Primary Fire));
            If(Event Player.ai_AimType != 2 || Event Player.ai_AimBase != 0);
                Event Player.ai_AimType = 2;
                Event Player.ai_AimBase = 0;
                Call Subroutine(aiSub_FacingStart);
            End;
            Event Player.ai_ProjectileSpeed = Event Player.ai_ProjectileSpeeds[0];
            Skip If(Is Button Held(Event Player, Button(Primary Fire)), 2);
            Call Subroutine(aiSub_ButtonsReset);
            Start Holding Button(Event Player, Button(Primary Fire));
        Else If(Event Player.ai_AbilityButton == Button(Secondary Fire));
            If(Event Player.ai_AimType != 0 || Event Player.ai_AimBase != 0);
                Event Player.ai_AimType = 0;
                Event Player.ai_AimBase = 0;
                Call Subroutine(aiSub_FacingStart);
            End;
            Call Subroutine(aiSub_ButtonsReset);
            Start Holding Button(Event Player, Button(Secondary Fire));
            Wait(Random Real(0.150, 0.400), Ignore Condition);
            Stop Holding Button(Event Player, Button(Secondary Fire));
        Else If(Event Player.ai_AbilityButton == Button(Ability 1));
            If(Event Player.ai_AimType != 0 || Event Player.ai_AimBase != 0);
                Event Player.ai_AimType = 0;
                Event Player.ai_AimBase = 0;
                Call Subroutine(aiSub_FacingStart);
            End;
            Press Button(Event Player, Button(Ability 1));
            Wait(0.100, Ignore Condition);
            Wait Until(Is Using Ability 1(Event Player) == False, 2);
        Else If(Event Player.ai_AbilityButton == Button(Ability 2));
            If(Event Player.ai_AimType != 2 || Event Player.ai_AimBase != 0);
                Event Player.ai_AimType = 2;
                Event Player.ai_AimBase = 0;
                Call Subroutine(aiSub_FacingStart);
            End;
            Event Player.ai_ProjectileSpeed = Event Player.ai_ProjectileSpeeds[3];
            Call Subroutine(aiSub_ReactionDelay);
            Press Button(Event Player, Button(Ability 2));
            Wait(0.650, Ignore Condition);
        Else If(Event Player.ai_AbilityButton == Button(Ultimate));
            If(Event Player.ai_AimType != 0 || Event Player.ai_AimBase != 2);
                Event Player.ai_AimType = 0;
                Event Player.ai_AimBase = 2;
                Call Subroutine(aiSub_FacingStart);
            End;
            Press Button(Event Player, Button(Ultimate));
            Start Holding Button(Event Player, Button(Jump));
            Wait(Random Real(0.750, 1.500), Ignore Condition);
            Wait Until(Is In View Angle(Event Player, Position Of(Players In Slot(Slot Of(Event Player), Team 1)), 10), 4);
            Start Holding Button(Event Player, Button(Primary Fire));
            Event Player.ai_AimType = 0;
            Event Player.ai_AimBase = 0;
            Call Subroutine(aiSub_FacingStart);
            Wait Until(Is Using Ultimate(Event Player) == False, 5);
        End;
        Event Player.ai_IsInAbilitySub = False;
    }
}
rule("AI Sigma General")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Sigma;
    }
    conditions
    {
        Is Game In Progress == True;
        Is Alive(Event Player) == True;
        Event Player.ai_AIEnabled == True;
    }
    actions
    {
        Event Player.ai_OptimalDistanceDefault = Random Real(12, 15);
        Event Player.ai_OptimalDistance = Event Player.ai_OptimalDistanceDefault;
        Event Player.ai_AimBaseDefault = 0;
        Event Player.ai_AimTypeDefault = 2;
        Event Player.ai_ProjectileSpeeds[0] = 50;
        Event Player.ai_ProjectileSpeeds[3] = 37.500;
        Event Player.ai_AimDistanceMod = 15;
        Call Subroutine(aiSub_FacingReset);
        Event Player.ai_HeroInitialized = True;
    }
}
rule("AI Sigma Attack")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Sigma;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 25;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 30 + Event Player.ai_ViewAngleMod) == True;
        Is Using Ability 1(Event Player) == False;
        Is Using Ability 2(Event Player) == False;
        Is Using Ultimate(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Primary Fire);
        Call Subroutine(aiSub_Abilities_Sigma);
        Wait(1.500, Ignore Condition);
        Loop If Condition Is True;
        Stop Holding Button(Event Player, Button(Primary Fire));
    }
}
rule("AI Sigma Experimental Barrier")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Sigma;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 30 + Event Player.ai_ViewAngleMod) == True;
        Ability Cooldown(Event Player, Button(Secondary Fire)) == 0;
        Is Firing Secondary(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Secondary Fire);
        Call Subroutine(aiSub_Abilities_Sigma);
        Wait(4, Ignore Condition);
        Press Button(Event Player, Button(Secondary Fire));
        Loop If Condition Is True;
    }
}
rule("AI Sigma Kinetic Grasp")
{
    event
    {
        Player Took Damage;
        Team 2;
        Sigma;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.ai_ViewAngleMod) == True;
        Is In View Angle(Players In Slot(Slot Of(Event Player), Team 1), Event Player, 15 + Event Player.ai_ViewAngleMod) == True;
        Array Contains(Global.c_ProjectileHeroes, Hero Of(Players In Slot(Slot Of(Event Player), Team 1))) == True;
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
        Is Using Ability 1(Event Player) == False;
    }
    actions
    {
        If(Random Real(0, 1) < 0.650 + Event Player.ai_ChanceMod);
            Event Player.ai_AbilityButton = Button(Ability 1);
            Call Subroutine(aiSub_Abilities_Sigma);
        End;
    }
}
rule("AI Sigma Accretion")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Sigma;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 20;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.ai_ViewAngleMod) == True;
        Speed Of(Players In Slot(Slot Of(Event Player), Team 1)) <= 3;
        Ability Cooldown(Event Player, Button(Ability 2)) == 0;
        Is Using Ability 2(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 2);
        Call Subroutine(aiSub_Abilities_Sigma);
    }
}
rule("AI Sigma Gravitic Flux")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Sigma;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Ultimate Charge Percent(Event Player) == 100;
        Is Using Ultimate(Event Player) == False;
        Health(Players In Slot(Slot Of(Event Player), Team 1)) >= 125;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 20;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.ai_ViewAngleMod) == True;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ultimate);
        Call Subroutine(aiSub_Abilities_Sigma);
    }
}
rule("AI Soldier: 76")
{
    event
    {
        Subroutine;
        aiSub_Abilities_Soldier76;
    }
    actions
    {
        Event Player.ai_IsInAbilitySub = True;
        Call Subroutine(aiSub_ReactionDelay);
        If(Event Player.ai_AbilityButton == Button(Primary Fire));
            Skip If(Is Button Held(Event Player, Button(Primary Fire)), 2);
            Call Subroutine(aiSub_ButtonsReset);
            Start Holding Button(Event Player, Button(Primary Fire));
        Else If(Event Player.ai_AbilityButton == Button(Secondary Fire));
            Event Player.ai_AimType = 1;
            Event Player.ai_AimBase = 2;
            Event Player.ai_ProjectileSpeed = Event Player.ai_ProjectileSpeeds[1];
            Call Subroutine(aiSub_FacingStart);
            Wait(Random Real(0.150, 0.250), Ignore Condition);
            Press Button(Event Player, Button(Secondary Fire));
            Wait(0.250, Ignore Condition);
            Call Subroutine(aiSub_FacingReset);
        Else If(Event Player.ai_AbilityButton == Button(Ability 1));
            Call Subroutine(aiSub_ButtonsReset);
            Start Holding Button(Event Player, Button(Ability 1));
            Wait Until(Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) < Event Player.ai_OptimalDistance + 5,
                9999);
            Stop Holding Button(Event Player, Button(Ability 1));
        Else If(Event Player.ai_AbilityButton == Button(Ability 2));
            Press Button(Event Player, Button(Ability 2));
        Else If(Event Player.ai_AbilityButton == Button(Ultimate));
            Press Button(Event Player, Button(Ultimate));
        End;
        Event Player.ai_IsInAbilitySub = False;
    }
}
rule("AI Soldier: 76 General")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Soldier: 76;
    }
    conditions
    {
        Is Game In Progress == True;
        Is Alive(Event Player) == True;
        Event Player.ai_AIEnabled == True;
    }
    actions
    {
        Event Player.ai_OptimalDistanceDefault = Random Real(15, 20);
        Event Player.ai_OptimalDistance = Event Player.ai_OptimalDistanceDefault;
        Event Player.ai_AimBaseDefault = 0;
        Event Player.ai_AimTypeDefault = 0;
        Event Player.ai_ProjectileSpeeds[1] = 50;
        Call Subroutine(aiSub_FacingReset);
        Event Player.ai_HeroInitialized = True;
    }
}
rule("AI Soldier: 76 Attack")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Soldier: 76;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 50;
        Is In View Angle(Event Player, Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250 + Y Component Of(
            Eye Position(Event Player)), 0), 12.500) == True;
        Is Using Ability 1(Event Player) == False;
        Is Firing Secondary(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Primary Fire);
        Call Subroutine(aiSub_Abilities_Soldier76);
        Wait(0.250, Ignore Condition);
        Loop If Condition Is True;
        Stop Holding Button(Event Player, Button(Primary Fire));
    }
}
rule("AI Soldier: 76 Helix Rockets")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Soldier: 76;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Is In View Angle(Event Player, Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250 + Y Component Of(
            Eye Position(Event Player)), 0), 12.500) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 20;
        Ability Cooldown(Event Player, Button(Secondary Fire)) == 0;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Secondary Fire);
        Call Subroutine(aiSub_Abilities_Soldier76);
    }
}
rule("AI Soldier: 76 Sprint")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Soldier: 76;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) > Event Player.ai_OptimalDistance + 5;
        Distance Between(Players In Slot(Slot Of(Event Player), Team 1), Players In Slot(Slot Of(Event Player), Team 1).p_HomeVector)
            < Global.c_BubbleRadius;
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
        Is Using Ability 1(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 1);
        Call Subroutine(aiSub_Abilities_Soldier76);
    }
}
rule("AI Soldier: 76 Biotic Field")
{
    event
    {
        Player Took Damage;
        Team 2;
        Soldier: 76;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Health(Event Player) < 100;
        Ability Cooldown(Event Player, Button(Ability 2)) == 0;
        Is Using Ability 2(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 2);
        Call Subroutine(aiSub_Abilities_Soldier76);
    }
}
rule("AI Soldier: 76 Tactical Visor")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Soldier: 76;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Ultimate Charge Percent(Event Player) == 100;
        Is Using Ultimate(Event Player) == False;
        Health(Event Player) >= 50;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ultimate);
        Call Subroutine(aiSub_Abilities_Soldier76);
    }
}
rule("AI Sombra")
{
    event
    {
        Subroutine;
        aiSub_Abilities_Sombra;
    }
    actions
    {
        Event Player.ai_IsInAbilitySub = True;
        Call Subroutine(aiSub_ReactionDelay);
        If(Event Player.ai_AbilityButton == Button(Primary Fire));
            Skip If(Is Button Held(Event Player, Button(Primary Fire)), 2);
            Call Subroutine(aiSub_ButtonsReset);
            Start Holding Button(Event Player, Button(Primary Fire));
        Else If(Event Player.ai_AbilityButton == Button(Secondary Fire));
            If(Is Using Ability 1(Event Player) == True);
                Press Button(Event Player, Button(Ability 1));
                Wait(0.800, Ignore Condition);
            End;
            Start Holding Button(Event Player, Button(Secondary Fire));
            Wait(0.750, Ignore Condition);
            Stop Holding Button(Event Player, Button(Secondary Fire));
        Else If(Event Player.ai_AbilityButton == Button(Ability 1));
        Else If(Event Player.ai_AbilityButton == Button(Ability 2));
            If(Is Using Ability 2(Event Player));
                If(Ability Cooldown(Event Player, Button(Ability 1)) == 0);
                    Press Button(Event Player, Button(Ability 1));
                    Wait(1 / 60, Ignore Condition);
                End;
                Press Button(Event Player, Button(Ability 2));
                Wait(0.250, Ignore Condition);
                Heal(Event Player, Null, 75);
            Else;
                Event Player.ai_LookAtVector = Position Of(Event Player) + World Vector Of(Vector(Random Real(-5, 5), Random Real(1, 3),
                    Random Real(-10, -15)), Event Player, Rotation);
                Call Subroutine(aiSub_FacingLookAt);
                Press Button(Event Player, Button(Ability 2));
                Wait(0.100, Ignore Condition);
                Event Player.ai_CanAim = True;
            End;
        Else If(Event Player.ai_AbilityButton == Button(Ultimate));
            Press Button(Event Player, Button(Ultimate));
            Wait(0.100, Ignore Condition);
            Wait Until(Is Using Ultimate(Event Player) == False, 0.650);
        End;
        Event Player.ai_IsInAbilitySub = False;
    }
}
rule("AI Sombra General")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Sombra;
    }
    conditions
    {
        Is Game In Progress == True;
        Is Alive(Event Player) == True;
        Event Player.ai_AIEnabled == True;
    }
    actions
    {
        Event Player.ai_OptimalDistanceDefault = Random Real(5, 8);
        Event Player.ai_OptimalDistance = Event Player.ai_OptimalDistanceDefault;
        Event Player.ai_AimBaseDefault = 0;
        Event Player.ai_AimBase = Event Player.ai_AimBaseDefault;
        Event Player.ai_AimType = 0;
        If(Ability Cooldown(Event Player, Button(Ability 1)) == 0);
            Press Button(Event Player, Button(Ability 1));
        End;
        Event Player.ai_HeroInitialized = True;
    }
}
rule("AI Sombra Attack")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Sombra;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 30;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.ai_ViewAngleMod) == True;
        Is Using Ability 1(Event Player) == False;
        Is Button Held(Event Player, Button(Secondary Fire)) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Primary Fire);
        Call Subroutine(aiSub_Abilities_Sombra);
        Wait(0.250, Ignore Condition);
        Loop If Condition Is True;
        Stop Holding Button(Event Player, Button(Primary Fire));
    }
}
rule("AI Sombra Hack")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Sombra;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 10;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 7.500 + Event Player.ai_ViewAngleMod) == True;
        Is In View Angle(Players In Slot(Slot Of(Event Player), Team 1), Event Player, 15 + Event Player.ai_ViewAngleMod) == False;
        Ability Cooldown(Event Player, Button(Secondary Fire)) == 0;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Secondary Fire);
        Call Subroutine(aiSub_Abilities_Sombra);
    }
}
rule("AI Sombra Stealth")
{
    event
    {
        Player Dealt Final Blow;
        Team 2;
        Sombra;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
        Is Using Ability 1(Event Player) == False;
    }
    actions
    {
        Call Subroutine(aiSub_ReactionDelay);
        Press Button(Event Player, Button(Ability 1));
    }
}
rule("AI Sombra Translocator Place")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Sombra;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Using Ability 2(Event Player) == False;
        Is Firing Secondary(Event Player) == False;
        Ability Cooldown(Event Player, Button(Ability 2)) == 0;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 2);
        Call Subroutine(aiSub_Abilities_Sombra);
    }
}
rule("AI Sombra Translocator Use")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Sombra;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Health(Event Player) <= 75;
        Is Using Ability 1(Event Player) == False;
        Is Using Ability 2(Event Player) == True;
        Ability Cooldown(Event Player, Button(Ability 2)) == 0;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 2);
        Call Subroutine(aiSub_Abilities_Sombra);
    }
}
rule("AI Sombra EMP")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Sombra;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Ultimate Charge Percent(Event Player) == 100;
        Is Using Ultimate(Event Player) == False;
        Health(Players In Slot(Slot Of(Event Player), Team 1)) >= 75;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 15;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ultimate);
        Call Subroutine(aiSub_Abilities_Sombra);
    }
}
rule("AI Symmetra")
{
    event
    {
        Subroutine;
        aiSub_Abilities_Symmetra;
    }
    actions
    {
        Event Player.ai_IsInAbilitySub = True;
        Call Subroutine(aiSub_ReactionDelay);
        If(Event Player.ai_AbilityButton == Button(Primary Fire));
            Skip If(Is Button Held(Event Player, Button(Primary Fire)), 2);
            Call Subroutine(aiSub_ButtonsReset);
            Event Player.ai_AimType = 0;
            Event Player.ai_AimBase = 0;
            Start Holding Button(Event Player, Button(Primary Fire));
        Else If(Event Player.ai_AbilityButton == Button(Secondary Fire));
            Event Player.ai_AimType = 1;
            Event Player.ai_AimBase = 0;
            Event Player.ai_ProjectileSpeed = Event Player.ai_ProjectileSpeeds[1];
            Call Subroutine(aiSub_ButtonsReset);
            Start Holding Button(Event Player, Button(Secondary Fire));
            Wait(Random Real(0.500, 1), Ignore Condition);
            Stop Holding Button(Event Player, Button(Primary Fire));
        Else If(Event Player.ai_AbilityButton == Button(Ability 1));
            Event Player.ai_LookAtVector = Position Of(Players In Slot(Slot Of(Event Player), Team 1)) + Vector(Random Real(-6, 6), 0,
                Random Real(-6, 6));
            Call Subroutine(aiSub_FacingLookAt);
            Press Button(Event Player, Button(Ability 1));
            Wait(0.350, Ignore Condition);
            Event Player.ai_CanAim = True;
        Else If(Event Player.ai_AbilityButton == Button(Ultimate));
            Press Button(Event Player, Button(Ultimate));
            Wait(0.250, Ignore Condition);
            Press Button(Event Player, Button(Ultimate));
            Wait(0.250, Ignore Condition);
            Press Button(Event Player, Button(Primary Fire));
        End;
        Event Player.ai_IsInAbilitySub = False;
    }
}
rule("AI Symmetra General")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Symmetra;
    }
    conditions
    {
        Is Game In Progress == True;
        Is Alive(Event Player) == True;
        Event Player.ai_AIEnabled == True;
    }
    actions
    {
        Event Player.ai_OptimalDistanceDefault = Random Real(6, 10);
        Event Player.ai_OptimalDistance = Event Player.ai_OptimalDistanceDefault;
        Event Player.ai_AimBaseDefault = 0;
        Event Player.ai_AimBase = Event Player.ai_AimBaseDefault;
        Event Player.ai_AimType = 0;
        Event Player.ai_ProjectileSpeeds[1] = 25;
        Event Player.ai_HeroInitialized = True;
    }
}
rule("AI Symmetra Attack Primary")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Symmetra;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 12;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.ai_ViewAngleMod) == True;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Primary Fire);
        Call Subroutine(aiSub_Abilities_Symmetra);
        Wait(0.250, Ignore Condition);
        Loop If Condition Is True;
        Stop Holding Button(Event Player, Button(Primary Fire));
    }
}
rule("AI Symmetra Attack Secondary")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Symmetra;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 40;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) > 12;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.ai_ViewAngleMod) == True;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Secondary Fire);
        Call Subroutine(aiSub_Abilities_Symmetra);
        Loop If Condition Is True;
        Event Player.ai_AimType = 0;
    }
}
rule("AI Symmetra Sentry Turret")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Symmetra;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Is On Ground(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 20;
        Is In View Angle(Players In Slot(Slot Of(Event Player), Team 1), Event Player, 15 + Event Player.ai_ViewAngleMod) == True;
        Ability Charge(Event Player, Button(Ability 1)) > 0;
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 1);
        Call Subroutine(aiSub_Abilities_Symmetra);
    }
}
rule("AI Symmetra Photon Barrier")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Symmetra;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Ultimate Charge Percent(Event Player) == 100;
        Is Using Ultimate(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ultimate);
        Call Subroutine(aiSub_Abilities_Symmetra);
    }
}
rule("AI Torbjorn")
{
    event
    {
        Subroutine;
        aiSub_Abilities_Torbjorn;
    }
    actions
    {
        Event Player.ai_IsInAbilitySub = True;
        Call Subroutine(aiSub_ReactionDelay);
        If(Event Player.ai_AbilityButton == Button(Primary Fire));
            Event Player.ai_ProjectileSpeed = Event Player.ai_ProjectileSpeeds[0];
            Event Player.ai_AimDistanceMod = 5;
            Skip If(Is Button Held(Event Player, Button(Primary Fire)), 2);
            Call Subroutine(aiSub_ButtonsReset);
            Start Holding Button(Event Player, Button(Primary Fire));
        Else If(Event Player.ai_AbilityButton == Button(Secondary Fire));
            Event Player.ai_ProjectileSpeed = Event Player.ai_ProjectileSpeeds[1];
            Skip If(Is Button Held(Event Player, Button(Secondary Fire)), 2);
            Call Subroutine(aiSub_ButtonsReset);
            Start Holding Button(Event Player, Button(Secondary Fire));
        Else If(Event Player.ai_AbilityButton == Button(Ability 1));
            Event Player.ai_LookAtVector = Position Of(Event Player) + World Vector Of(Vector(Random Real(-8, 8), 0, Random Real(0, 3)),
                Event Player, Rotation);
            Call Subroutine(aiSub_FacingLookAt);
            Press Button(Event Player, Button(Ability 1));
            Call Subroutine(aiSub_ReactionDelay);
            Event Player.ai_CanAim = True;
            Call Subroutine(aiSub_FacingReset);
        Else If(Event Player.ai_AbilityButton == Button(Ability 2));
            Press Button(Event Player, Button(Ability 2));
        Else If(Event Player.ai_AbilityButton == Button(Ultimate));
            Call Subroutine(aiSub_ButtonsReset);
            Event Player.ai_ProjectileSpeed = Event Player.ai_ProjectileSpeeds[4];
            Event Player.ai_AimDistanceMod = -30;
            Call Subroutine(aiSub_ReactionDelay);
            Press Button(Event Player, Button(Ultimate));
            Wait(1, Ignore Condition);
            While(Is Using Ultimate(Event Player));
                Press Button(Event Player, Button(Primary Fire));
                Wait(Random Real(0.150, 0.500), Ignore Condition);
            End;
            Call Subroutine(aiSub_FacingReset);
            Event Player.ai_AimDistanceMod = 5;
        End;
        Event Player.ai_IsInAbilitySub = False;
    }
}
rule("AI Torbjorn General")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Torbjörn;
    }
    conditions
    {
        Is Game In Progress == True;
        Is Alive(Event Player) == True;
        Event Player.ai_AIEnabled == True;
    }
    actions
    {
        Event Player.ai_OptimalDistanceDefault = Random Real(15, 20);
        Event Player.ai_OptimalDistance = Event Player.ai_OptimalDistanceDefault;
        Event Player.ai_AimBaseDefault = 1;
        Event Player.ai_AimTypeDefault = 2;
        Event Player.ai_AimDistanceMod = 5;
        Event Player.ai_ProjectileSpeeds[0] = 70;
        Event Player.ai_ProjectileSpeeds[1] = 120;
        Event Player.ai_ProjectileSpeeds[4] = 40;
        Call Subroutine(aiSub_FacingReset);
        Event Player.ai_HeroInitialized = True;
    }
}
rule("AI Torbjorn Attack Primary")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Torbjörn;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 40;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) > 10;
        Is In View Angle(Event Player, Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250 + Y Component Of(
            Eye Position(Event Player)), 0), 15) == True;
        Is Using Ultimate(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Primary Fire);
        Call Subroutine(aiSub_Abilities_Torbjorn);
        Wait(0.600, Ignore Condition);
        Loop If Condition Is True;
        Stop Holding Button(Event Player, Button(Primary Fire));
    }
}
rule("AI Torbjorn Attack Secondary")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Torbjörn;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 10;
        Is In View Angle(Event Player, Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250 + Y Component Of(
            Eye Position(Event Player)), 0), 15) == True;
        Is Using Ultimate(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Secondary Fire);
        Call Subroutine(aiSub_Abilities_Torbjorn);
        Wait(0.800, Ignore Condition);
        Loop If Condition Is True;
        Stop Holding Button(Event Player, Button(Secondary Fire));
    }
}
rule("AI Torbjorn Deploy Turret")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Torbjörn;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Is Using Ultimate(Event Player) == False;
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
        Is Using Ability 1(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 1);
        Call Subroutine(aiSub_Abilities_Torbjorn);
    }
}
rule("AI Torbjorn Overload")
{
    event
    {
        Player Took Damage;
        Team 2;
        Torbjörn;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Health(Event Player) <= 90;
        Ability Cooldown(Event Player, Button(Ability 2)) == 0;
        Is Using Ability 2(Event Player) == False;
        Is Using Ultimate(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 2);
        Call Subroutine(aiSub_Abilities_Torbjorn);
    }
}
rule("AI Torbjorn Molten Core")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Torbjörn;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Ultimate Charge Percent(Event Player) == 100;
        Is Using Ultimate(Event Player) == False;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 30;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ultimate);
        Call Subroutine(aiSub_Abilities_Torbjorn);
    }
}
rule("AI Tracer")
{
    event
    {
        Subroutine;
        aiSub_Abilities_Tracer;
    }
    actions
    {
        Event Player.ai_IsInAbilitySub = True;
        Call Subroutine(aiSub_ReactionDelay);
        If(Event Player.ai_AbilityButton == Button(Primary Fire));
            Skip If(Is Button Held(Event Player, Button(Primary Fire)), 1);
            Start Holding Button(Event Player, Button(Primary Fire));
        Else If(Event Player.ai_AbilityButton == Button(Ability 1));
            Press Button(Event Player, Button(Ability 1));
            Wait(0.100, Ignore Condition);
        Else If(Event Player.ai_AbilityButton == Button(Ability 2));
            Press Button(Event Player, Button(Ability 2));
        Else If(Event Player.ai_AbilityButton == Button(Ultimate));
            Event Player.ai_ProjectileSpeed = Event Player.ai_ProjectileSpeeds[4];
            Event Player.ai_AimType = 2;
            Call Subroutine(aiSub_FacingStart);
            Wait(Random Real(0.150, 0.250), Ignore Condition);
            Press Button(Event Player, Button(Ultimate));
            Wait(0.150, Ignore Condition);
            Event Player.ai_OptimalDistance = Event Player.ai_OptimalDistanceDefault;
            Event Player.ai_AimType = 0;
            Call Subroutine(aiSub_FacingStart);
        End;
        Event Player.ai_IsInAbilitySub = False;
    }
}
rule("AI Tracer General")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Tracer;
    }
    conditions
    {
        Is Game In Progress == True;
        Is Alive(Event Player) == True;
        Event Player.ai_AIEnabled == True;
    }
    actions
    {
        Event Player.ai_OptimalDistanceDefault = Random Real(4, 6);
        Event Player.ai_OptimalDistance = Event Player.ai_OptimalDistanceDefault;
        Event Player.ai_AimBaseDefault = 0;
        Event Player.ai_AimTypeDefault = 0;
        Event Player.ai_ProjectileSpeeds[4] = 15;
        Call Subroutine(aiSub_FacingReset);
        Event Player.ai_HeroInitialized = True;
    }
}
rule("AI Tracer Attack")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Tracer;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 23;
        Is In View Angle(Event Player, Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250 + Y Component Of(
            Eye Position(Event Player)), 0), 12.500) == True;
        Is Reloading(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Primary Fire);
        Call Subroutine(aiSub_Abilities_Tracer);
        Wait(1, Ignore Condition);
        Loop If Condition Is True;
        Stop Holding Button(Event Player, Button(Primary Fire));
    }
}
rule("AI Tracer Blink")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Tracer;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 20;
        Is In View Angle(Players In Slot(Slot Of(Event Player), Team 1), Eye Position(Event Player) - Vector(0, 0.250 + Y Component Of(
            Eye Position(Players In Slot(Slot Of(Event Player), Team 1))), 0), 5) == True;
        Ability Charge(Event Player, Button(Ability 1)) > 0;
        Is Using Ability 1(Event Player) == False;
    }
    actions
    {
        If(Random Real(0, 1) < 0.500 + Event Player.ai_ChanceMod);
            Event Player.ai_AbilityButton = Button(Ability 1);
            Call Subroutine(aiSub_Abilities_Tracer);
        End;
    }
}
rule("AI Tracer Recall")
{
    event
    {
        Player Took Damage;
        Team 2;
        Tracer;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Health(Event Player) < 70;
        Ability Cooldown(Event Player, Button(Ability 2)) == 0;
        Is Using Ability 2(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 2);
        Call Subroutine(aiSub_Abilities_Tracer);
    }
}
rule("AI Tracer Pulse Bomb Update Range")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Tracer;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Health(Players In Slot(Slot Of(Event Player), Team 1)) >= 100;
        Ultimate Charge Percent(Event Player) == 100;
        Is Using Ultimate(Event Player) == False;
    }
    actions
    {
        Event Player.ai_OptimalDistance = Random Real(1, 3);
    }
}
rule("AI Tracer Pulse Bomb Toss")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Tracer;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Health(Players In Slot(Slot Of(Event Player), Team 1)) >= 75;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 5;
        Is In View Angle(Event Player, Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250 + Y Component Of(
            Eye Position(Event Player)), 0), 10) == True;
        Ultimate Charge Percent(Event Player) == 100;
        Is Using Ultimate(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ultimate);
        Call Subroutine(aiSub_Abilities_Tracer);
    }
}
rule("AI Tracer Pulse Bomb Stick Recall")
{
    event
    {
        Player Dealt Damage;
        Team 2;
        Tracer;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Event Damage == 5;
        Ultimate Charge Percent(Event Player) == 0;
        Ability Cooldown(Event Player, Button(Ability 2)) == 0;
        Is Using Ability 2(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 2);
        Call Subroutine(aiSub_Abilities_Tracer);
    }
}
rule("AI Widowmaker")
{
    event
    {
        Subroutine;
        aiSub_Abilities_Widowmaker;
    }
    actions
    {
        Event Player.ai_IsInAbilitySub = True;
        Call Subroutine(aiSub_ReactionDelay);
        If(Event Player.ai_AbilityButton == Button(Primary Fire));
            If(Is Firing Secondary(Event Player));
                If(Random Real(0, 1) < Players In Slot(Slot Of(Event Player), Team 1).p_Difficulty / 20);
                    Call Subroutine(aiSub_FlickIn);
                    Press Button(Event Player, Button(Primary Fire));
                    Call Subroutine(aiSub_FlickOut);
                Else;
                    Press Button(Event Player, Button(Primary Fire));
                End;
                Event Player.ai_WeaponChargeTime = Total Time Elapsed;
            Else;
                Skip If(Is Button Held(Event Player, Button(Primary Fire)), 2);
                Call Subroutine(aiSub_ButtonsReset);
                Start Holding Button(Event Player, Button(Primary Fire));
            End;
        Else If(Event Player.ai_AbilityButton == Button(Secondary Fire));
            If(Is Button Held(Event Player, Button(Secondary Fire)));
                Stop Holding Button(Event Player, Button(Secondary Fire));
                If(Event Player.ai_AimType != 0 || Event Player.ai_AimBase != 0);
                    Event Player.ai_AimType = 0;
                    Event Player.ai_AimBase = 0;
                    Call Subroutine(aiSub_FacingStart);
                End;
            Else;
                Event Player.bot_MoveJumpEnabled = False;
                Call Subroutine(aiSub_ButtonsReset);
                Start Holding Button(Event Player, Button(Secondary Fire));
                Wait(0.333, Ignore Condition);
                Event Player.ai_WeaponChargeTime = Total Time Elapsed;
                If(Event Player.ai_AimType != 0 || Event Player.ai_AimBase != 1);
                    Call Subroutine(aiSub_FacingReset);
                End;
            End;
        Else If(Event Player.ai_AbilityButton == Button(Ability 1));
            Event Player.ai_CanAttack = False;
            Call Subroutine(aiSub_ButtonsReset);
            Call Subroutine(aiSub_FacingLookAt);
            Press Button(Event Player, Button(Ability 1));
            Stop Facing(Event Player);
            Wait Until(Is Using Ability 1(Event Player) == True, 2);
            Wait Until(Is Using Ability 1(Event Player) == False, 2);
            Event Player.ai_CanAim = True;
            Event Player.ai_CanAttack = True;
        Else If(Event Player.ai_AbilityButton == Button(Ability 2));
            Stop Holding Button(Event Player, Button(Secondary Fire));
            Event Player.ai_AimType = 2;
            Event Player.ai_AimBase = 2;
            Event Player.ai_ProjectileSpeed = Event Player.ai_ProjectileSpeeds[3];
            Call Subroutine(aiSub_FacingStart);
            Call Subroutine(aiSub_ReactionDelay);
            Press Button(Event Player, Button(Ability 2));
            Wait(0.150, Ignore Condition);
            Call Subroutine(aiSub_FacingReset);
        Else If(Event Player.ai_AbilityButton == Button(Ultimate));
            Stop Holding Button(Event Player, Button(Secondary Fire));
            Press Button(Event Player, Button(Ultimate));
        End;
        Event Player.ai_IsInAbilitySub = False;
    }
}
rule("AI Widowmaker General")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Widowmaker;
    }
    conditions
    {
        Is Game In Progress == True;
        Is Alive(Event Player) == True;
        Event Player.ai_AIEnabled == True;
    }
    actions
    {
        Event Player.ai_OptimalDistanceDefault = Random Integer(20, 40);
        Event Player.ai_OptimalDistance = Event Player.ai_OptimalDistanceDefault;
        Event Player.ai_StrafeDistanceMod = 10;
        Event Player.ai_AimBaseDefault = 1;
        Event Player.ai_AimTypeDefault = 0;
        Event Player.ai_ProjectileSpeeds[3] = 20;
        Event Player.ai_AimDistanceMod = -10;
        Call Subroutine(aiSub_FacingReset);
        Event Player.ai_HeroInitialized = True;
    }
}
rule("AI Widowmaker Scope In")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Widowmaker;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) >= 7.500;
        Distance Between(Players In Slot(Slot Of(Event Player), Team 1), Players In Slot(Slot Of(Event Player), Team 1).p_HomeVector)
            < Global.c_BubbleRadius;
        Is Using Ability 1(Event Player) == False;
        Is Button Held(Event Player, Button(Secondary Fire)) == False;
        Is Reloading(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Secondary Fire);
        Call Subroutine(aiSub_Abilities_Widowmaker);
    }
}
rule("AI Widowmaker Scope Out")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Widowmaker;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        (Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) < 7.500 || Is Alive(Players In Slot(Slot Of(
            Event Player), Team 1)) == False) == True;
        Is Using Ability 1(Event Player) == False;
        Is Firing Secondary(Event Player) == True;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Secondary Fire);
        Call Subroutine(aiSub_Abilities_Widowmaker);
    }
}
rule("AI Widowmaker Scope Out Reloading")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Widowmaker;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_IsInAbilitySub == False;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Is Using Ability 1(Event Player) == False;
        Is Button Held(Event Player, Button(Secondary Fire)) == True;
        Is Reloading(Event Player) == True;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Secondary Fire);
        Call Subroutine(aiSub_Abilities_Widowmaker);
    }
}
rule("AI Widowmaker Charge And Fire")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Widowmaker;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Is Firing Secondary(Event Player) == True;
        Players in View Angle(Event Player, Team 1, 1.250 + Event Player.ai_ViewAngleMod) == Players In Slot(Slot Of(Event Player),
            Team 1);
        Is Using Ability 1(Event Player) == False;
        Total Time Elapsed >= Event Player.ai_WeaponChargeTime + 1.250;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Primary Fire);
        Call Subroutine(aiSub_Abilities_Widowmaker);
    }
}
rule("AI Widowmaker Attack SMG")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Widowmaker;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) < 7.500;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.ai_ViewAngleMod) == True;
        Is Using Ability 1(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Primary Fire);
        Call Subroutine(aiSub_Abilities_Widowmaker);
        Wait(0.250, Ignore Condition);
        Loop If Condition Is True;
        Stop Holding Button(Event Player, Button(Primary Fire));
    }
}
rule("AI Widowmaker Grappling Hook Closer")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Widowmaker;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Is Using Ability 1(Event Player) == False;
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) > Event Player.ai_OptimalDistance + 5;
        Distance Between(Players In Slot(Slot Of(Event Player), Team 1), Players In Slot(Slot Of(Event Player), Team 1).p_HomeVector)
            < Global.c_BubbleRadius;
    }
    actions
    {
        Event Player.ai_LookAtVector = Position Of(Event Player) + World Vector Of(Vector(Random Real(-8, 8), 0, Random Real(8, 16)),
            Event Player, Rotation);
        Event Player.ai_AbilityButton = Button(Ability 1);
        Call Subroutine(aiSub_Abilities_Widowmaker);
    }
}
rule("AI Widowmaker Grappling Hook Farther")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Widowmaker;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Is Using Ability 1(Event Player) == False;
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) < Event Player.ai_OptimalDistance - 5;
    }
    actions
    {
        Event Player.ai_LookAtVector = Position Of(Event Player) + World Vector Of(Vector(Random Real(-8, 8), 0, Random Real(-8, -16)),
            Event Player, Rotation);
        Event Player.ai_AbilityButton = Button(Ability 1);
        Call Subroutine(aiSub_Abilities_Widowmaker);
    }
}
rule("AI Widowmaker Venom Mine")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Widowmaker;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Is Using Ability 1(Event Player) == False;
        Is Using Ability 2(Event Player) == False;
        Ability Cooldown(Event Player, Button(Ability 2)) == 0;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= Event Player.ai_OptimalDistance;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 2);
        Call Subroutine(aiSub_Abilities_Widowmaker);
    }
}
rule("AI Widowmaker Infra-Sight")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Widowmaker;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Ultimate Charge Percent(Event Player) == 100;
        Is Using Ultimate(Event Player) == False;
        Health(Event Player) >= 75;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ultimate);
        Call Subroutine(aiSub_Abilities_Widowmaker);
    }
}
rule("AI Winston")
{
    event
    {
        Subroutine;
        aiSub_Abilities_Winston;
    }
    actions
    {
        Event Player.ai_IsInAbilitySub = True;
        Call Subroutine(aiSub_ReactionDelay);
        If(Event Player.ai_AbilityButton == Button(Primary Fire));
            Skip If(Is Button Held(Event Player, Button(Primary Fire)), 2);
            Call Subroutine(aiSub_ButtonsReset);
            Start Holding Button(Event Player, Button(Primary Fire));
        Else If(Event Player.ai_AbilityButton == Button(Secondary Fire));
        Else If(Event Player.ai_AbilityButton == Button(Ability 1));
            Event Player.bot_MoveWASDEnabled = False;
            Start Throttle In Direction(Event Player, Direction Towards(Event Player, Players In Slot(Slot Of(Event Player), Team 1)), 1,
                To World, Replace existing throttle, Direction and Magnitude);
            Event Player.ai_AimType = 2;
            Event Player.ai_AimBase = 2;
            Event Player.ai_ProjectileSpeed = Event Player.ai_ProjectileSpeeds[2];
            Call Subroutine(aiSub_FacingStart);
            Wait(Random Real(0.250, 0.750), Ignore Condition);
            Press Button(Event Player, Button(Ability 1));
            Wait(0.100, Ignore Condition);
            Event Player.bot_MoveWASDEnabled = True;
            Call Subroutine(aiSub_FacingReset);
        Else If(Event Player.ai_AbilityButton == Button(Ability 2));
            Press Button(Event Player, Button(Ability 2));
        Else If(Event Player.ai_AbilityButton == Button(Ultimate));
            Press Button(Event Player, Button(Ultimate));
            Event Player.ai_OptimalDistance = Random Real(1.500, 3);
            Wait Until(Is Using Ultimate(Event Player) == True, 0.250);
        End;
        Event Player.ai_IsInAbilitySub = False;
    }
}
rule("AI Winston General")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Winston;
    }
    conditions
    {
        Is Game In Progress == True;
        Is Alive(Event Player) == True;
        Event Player.ai_AIEnabled == True;
    }
    actions
    {
        Event Player.ai_OptimalDistanceDefault = Random Real(3, 6);
        Event Player.ai_OptimalDistance = Event Player.ai_OptimalDistanceDefault;
        Event Player.ai_AimBaseDefault = 0;
        Event Player.ai_AimTypeDefault = 0;
        Event Player.ai_ProjectileSpeeds[2] = 30;
        Event Player.ai_StrafeDistanceMod = 1.500;
        Call Subroutine(aiSub_FacingReset);
        Event Player.ai_HeroInitialized = True;
    }
}
rule("AI Winston Attack")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Winston;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 8;
        Is In View Angle(Event Player, Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250 + Y Component Of(
            Eye Position(Event Player)), 0), 30) == True;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Primary Fire);
        Call Subroutine(aiSub_Abilities_Winston);
        Wait(0.250, Ignore Condition);
        Loop If Condition Is True;
        Stop Holding Button(Event Player, Button(Primary Fire));
    }
}
rule("AI Winston Jump Pack")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Winston;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Is In View Angle(Event Player, Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250 + Y Component Of(
            Eye Position(Event Player)), 0), 12.500) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) >= 12;
        Distance Between(Players In Slot(Slot Of(Event Player), Team 1), Players In Slot(Slot Of(Event Player), Team 1).p_HomeVector)
            < Global.c_BubbleRadius;
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
        Is Using Ability 1(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 1);
        Call Subroutine(aiSub_Abilities_Winston);
    }
}
rule("AI Winston Barrier Projector")
{
    event
    {
        Player Took Damage;
        Team 2;
        Winston;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Health(Event Player) <= 350;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= Event Player.ai_OptimalDistance + 10;
        Ability Cooldown(Event Player, Button(Ability 2)) == 0;
        Is Using Ability 2(Event Player) == False;
    }
    actions
    {
        If(Random Real(0, 1) < 0.700 + Event Player.ai_ChanceMod);
            Event Player.ai_AbilityButton = Button(Ability 2);
            Call Subroutine(aiSub_Abilities_Winston);
        End;
    }
}
rule("AI Winston Primal Rage")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Winston;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Event Player.ai_HeroInitialized == True;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Ultimate Charge Percent(Event Player) == 100;
        Is Using Ultimate(Event Player) == False;
        Health(Players In Slot(Slot Of(Event Player), Team 1)) >= 100;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 20;
        Is In View Angle(Event Player, Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250 + Y Component Of(
            Eye Position(Event Player)), 0), 15) == True;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ultimate);
        Call Subroutine(aiSub_Abilities_Winston);
        Wait Until(Is Using Ultimate(Event Player) == False, 10);
        Event Player.ai_OptimalDistance = Event Player.ai_OptimalDistanceDefault;
    }
}
rule("AI Wrecking Ball")
{
    event
    {
        Subroutine;
        aiSub_Abilities_WreckingBall;
    }
    actions
    {
        Event Player.ai_IsInAbilitySub = True;
        Call Subroutine(aiSub_ReactionDelay);
        If(Event Player.ai_AbilityButton == Button(Primary Fire));
            Skip If(Is Button Held(Event Player, Button(Primary Fire)), 2);
            Call Subroutine(aiSub_ButtonsReset);
            Start Holding Button(Event Player, Button(Primary Fire));
        Else If(Event Player.ai_AbilityButton == Button(Crouch));
            Event Player.bot_MoveCrouchEnabled = False;
            Press Button(Event Player, Button(Jump));
            Wait(0.250, Ignore Condition);
            Press Button(Event Player, Button(Crouch));
            Event Player.bot_MoveCrouchEnabled = True;
        Else If(Event Player.ai_AbilityButton == Button(Ability 1));
            Press Button(Event Player, Button(Ability 1));
        Else If(Event Player.ai_AbilityButton == Button(Ability 2));
            Press Button(Event Player, Button(Ability 2));
        Else If(Event Player.ai_AbilityButton == Button(Ultimate));
            Press Button(Event Player, Button(Ultimate));
        End;
        Event Player.ai_IsInAbilitySub = False;
    }
}
rule("AI Wrecking Ball General")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Wrecking Ball;
    }
    conditions
    {
        Is Game In Progress == True;
        Is Alive(Event Player) == True;
        Event Player.ai_AIEnabled == True;
    }
    actions
    {
        Event Player.ai_OptimalDistanceDefault = Random Real(5, 10);
        Event Player.ai_OptimalDistance = Event Player.ai_OptimalDistanceDefault;
        Event Player.ai_AimBaseDefault = 0;
        Event Player.ai_AimBase = Event Player.ai_AimBaseDefault;
        Event Player.bot_MoveJumpEnabled = False;
        Event Player.ai_AimType = 0;
        Event Player.ai_HeroInitialized = True;
    }
}
rule("AI Wrecking Ball Attack")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Wrecking Ball;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 10;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 10 + Event Player.ai_ViewAngleMod) == True;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Primary Fire);
        Call Subroutine(aiSub_Abilities_WreckingBall);
        Wait(0.250, Ignore Condition);
        Loop If Condition Is True;
        Stop Holding Button(Event Player, Button(Primary Fire));
    }
}
rule("AI Wrecking Ball Roll")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Wrecking Ball;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) >= 15;
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
        Is Using Ability 1(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 1);
        Call Subroutine(aiSub_Abilities_WreckingBall);
    }
}
rule("AI Wrecking Ball Adaptive Shield")
{
    event
    {
        Player Took Damage;
        Team 2;
        Wrecking Ball;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Health(Event Player) <= 150;
        Ability Cooldown(Event Player, Button(Ability 2)) == 0;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 2);
        Call Subroutine(aiSub_Abilities_WreckingBall);
    }
}
rule("AI Wrecking Ball Piledriver")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Wrecking Ball;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 8;
        Ability Cooldown(Event Player, Button(Crouch)) == 0;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Crouch);
        Call Subroutine(aiSub_Abilities_WreckingBall);
    }
}
rule("AI Wrecking Ball Minefield")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Wrecking Ball;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Ultimate Charge Percent(Event Player) == 100;
        Is Using Ultimate(Event Player) == False;
        Health(Players In Slot(Slot Of(Event Player), Team 1)) > 50;
        Is In Air(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 12.500;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ultimate);
        Call Subroutine(aiSub_Abilities_WreckingBall);
    }
}
rule("AI Zarya")
{
    event
    {
        Subroutine;
        aiSub_Abilities_Zarya;
    }
    actions
    {
        Event Player.ai_IsInAbilitySub = True;
        Call Subroutine(aiSub_ReactionDelay);
        If(Event Player.ai_AbilityButton == Button(Primary Fire));
            If(Event Player.ai_AimType != 0 || Event Player.ai_AimBase != 0);
                Call Subroutine(aiSub_FacingReset);
            End;
            Skip If(Is Button Held(Event Player, Button(Primary Fire)), 2);
            Call Subroutine(aiSub_ButtonsReset);
            Start Holding Button(Event Player, Button(Primary Fire));
        Else If(Event Player.ai_AbilityButton == Button(Secondary Fire));
            If(Event Player.ai_AimType != 2 || Event Player.ai_AimBase != 2);
                Event Player.ai_AimType = 2;
                Event Player.ai_AimBase = 2;
                Event Player.ai_ProjectileSpeed = Event Player.ai_ProjectileSpeeds[1];
                Call Subroutine(aiSub_FacingStart);
            End;
            Skip If(Is Button Held(Event Player, Button(Secondary Fire)), 2);
            Call Subroutine(aiSub_ButtonsReset);
            Start Holding Button(Event Player, Button(Secondary Fire));
        Else If(Event Player.ai_AbilityButton == Button(Ability 1));
            Press Button(Event Player, Button(Ability 1));
        Else If(Event Player.ai_AbilityButton == Button(Ability 2));
        Else If(Event Player.ai_AbilityButton == Button(Ultimate));
            Event Player.ai_AimType = 2;
            Event Player.ai_AimBase = 2;
            Event Player.ai_ProjectileSpeed = Event Player.ai_ProjectileSpeeds[4];
            Call Subroutine(aiSub_FacingStart);
            Call Subroutine(aiSub_ReactionDelay);
            Press Button(Event Player, Button(Ultimate));
            Wait(0.150, Ignore Condition);
            Call Subroutine(aiSub_FacingReset);
        End;
        Event Player.ai_IsInAbilitySub = False;
    }
}
rule("AI Zarya General")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Zarya;
    }
    conditions
    {
        Is Game In Progress == True;
        Is Alive(Event Player) == True;
        Event Player.ai_AIEnabled == True;
    }
    actions
    {
        Event Player.ai_OptimalDistanceDefault = Random Real(5, 10);
        Event Player.ai_OptimalDistance = Event Player.ai_OptimalDistanceDefault;
        Event Player.ai_AimBaseDefault = 0;
        Event Player.ai_AimTypeDefault = 0;
        Event Player.ai_ProjectileSpeeds[1] = 25;
        Event Player.ai_ProjectileSpeeds[4] = 25;
        Event Player.ai_AimDistanceMod = 16;
        Call Subroutine(aiSub_FacingReset);
        Event Player.ai_HeroInitialized = True;
    }
}
rule("AI Zarya Attack Primary")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Zarya;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 15;
        Is In View Angle(Event Player, Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250 + Y Component Of(
            Eye Position(Event Player)), 0), 15) == True;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Primary Fire);
        Call Subroutine(aiSub_Abilities_Zarya);
        Wait(0.250, Ignore Condition);
        Loop If Condition Is True;
        Stop Holding Button(Event Player, Button(Primary Fire));
    }
}
rule("AI Zarya Attack Secondary")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Zarya;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) > 15;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 50;
        Is In View Angle(Event Player, Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250 + Y Component Of(
            Eye Position(Event Player)), 0), 30) == True;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Secondary Fire);
        Call Subroutine(aiSub_Abilities_Zarya);
        Wait(1, Ignore Condition);
        Loop If Condition Is True;
        Stop Holding Button(Event Player, Button(Secondary Fire));
    }
}
rule("AI Zarya Use Bubble")
{
    event
    {
        Player Took Damage;
        Team 2;
        Zarya;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Is In View Angle(Players In Slot(Slot Of(Event Player), Team 1), Eye Position(Event Player) - Vector(0, 0.250 + Y Component Of(
            Eye Position(Players In Slot(Slot Of(Event Player), Team 1))), 0), 15) == True;
        Ability Cooldown(Event Player, Button(Ability 1)) == 0;
        Is Using Ability 1(Event Player) == False;
    }
    actions
    {
        If(Random Real(0, 1) < 0.700 + Event Player.ai_ChanceMod);
            Event Player.ai_AbilityButton = Button(Ability 1);
            Call Subroutine(aiSub_Abilities_Zarya);
        End;
    }
}
rule("AI Zarya Graviton Surge")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Zarya;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Ultimate Charge Percent(Event Player) == 100;
        Is Using Ultimate(Event Player) == False;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 15;
        Is In View Angle(Event Player, Eye Position(Players In Slot(Slot Of(Event Player), Team 1)) - Vector(0, 0.250 + Y Component Of(
            Eye Position(Event Player)), 0), 12.500) == True;
        Health(Players In Slot(Slot Of(Event Player), Team 1)) >= 100;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ultimate);
        Call Subroutine(aiSub_Abilities_Zarya);
    }
}
rule("AI Zenyatta")
{
    event
    {
        Subroutine;
        aiSub_Abilities_Zenyatta;
    }
    actions
    {
        Event Player.ai_IsInAbilitySub = True;
        Call Subroutine(aiSub_ReactionDelay);
        If(Event Player.ai_AbilityButton == Button(Primary Fire));
            Skip If(Is Button Held(Event Player, Button(Primary Fire)), 2);
            Call Subroutine(aiSub_ButtonsReset);
            Start Holding Button(Event Player, Button(Primary Fire));
        Else If(Event Player.ai_AbilityButton == Button(Secondary Fire));
            Call Subroutine(aiSub_ButtonsReset);
            Start Holding Button(Event Player, Button(Secondary Fire));
            Wait(Random Integer(3, 5) * 0.520, Ignore Condition);
            Stop Holding Button(Event Player, Button(Secondary Fire));
        Else If(Event Player.ai_AbilityButton == Button(Ability 1));
        Else If(Event Player.ai_AbilityButton == Button(Ability 2));
            Press Button(Event Player, Button(Ability 2));
        Else If(Event Player.ai_AbilityButton == Button(Ultimate));
            Press Button(Event Player, Button(Ultimate));
        End;
        Event Player.ai_IsInAbilitySub = False;
    }
}
rule("AI Zenyatta General")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Zenyatta;
    }
    conditions
    {
        Is Game In Progress == True;
        Is Alive(Event Player) == True;
        Event Player.ai_AIEnabled == True;
    }
    actions
    {
        Event Player.ai_OptimalDistanceDefault = Random Real(12, 16);
        Event Player.ai_OptimalDistance = Event Player.ai_OptimalDistanceDefault;
        Event Player.ai_AimBaseDefault = 0;
        Event Player.ai_AimBase = Event Player.ai_AimBaseDefault;
        Event Player.ai_AimType = 1;
        Event Player.ai_ProjectileSpeed = 90;
        Event Player.ai_HeroInitialized = True;
    }
}
rule("AI Zenyatta Attack Primary")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Zenyatta;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Is Using Ultimate(Event Player) == False;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 35;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 15 + Event Player.ai_ViewAngleMod) == True;
        Is Firing Primary(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Primary Fire);
        Call Subroutine(aiSub_Abilities_Zenyatta);
        Wait(0.400, Ignore Condition);
        Loop If Condition Is True;
        Stop Holding Button(Event Player, Button(Primary Fire));
    }
}
rule("AI Zenyatta Attack Secondary")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Zenyatta;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanAttack == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Is Using Ultimate(Event Player) == False;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) >= 10;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 12;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 30 + Event Player.ai_ViewAngleMod) == True;
        Is Firing Primary(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Secondary Fire);
        Call Subroutine(aiSub_Abilities_Zenyatta);
        Loop If Condition Is True;
    }
}
rule("AI Zenyatta Orb of Discord")
{
    event
    {
        Ongoing - Each Player;
        Team 2;
        Zenyatta;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Is In View Angle(Event Player, Players In Slot(Slot Of(Event Player), Team 1), 7.500 + Event Player.ai_ViewAngleMod) == True;
        Distance Between(Event Player, Players In Slot(Slot Of(Event Player), Team 1)) <= 75;
        Is Using Ability 2(Event Player) == False;
        Is Using Ultimate(Event Player) == False;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ability 2);
        Call Subroutine(aiSub_Abilities_Zenyatta);
    }
}
rule("AI Zenyatta Transcendence")
{
    event
    {
        Player Took Damage;
        Team 2;
        Zenyatta;
    }
    conditions
    {
        Event Player.ai_AIEnabled == True;
        Event Player.ai_CanUseAbilities == True;
        Event Player.ai_IsInAbilitySub == False;
        Is Alive(Event Player) == True;
        Is Alive(Players In Slot(Slot Of(Event Player), Team 1)) == True;
        Ultimate Charge Percent(Event Player) == 100;
        Is Using Ultimate(Event Player) == False;
        Health(Event Player) < 50;
    }
    actions
    {
        Event Player.ai_AbilityButton = Button(Ultimate);
        Call Subroutine(aiSub_Abilities_Zenyatta);
    }
}
